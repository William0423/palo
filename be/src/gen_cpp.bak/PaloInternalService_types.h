/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PaloInternalService_TYPES_H
#define PaloInternalService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Status_types.h"
#include "Types_types.h"
#include "Exprs_types.h"
#include "Descriptors_types.h"
#include "PlanNodes_types.h"
#include "Planner_types.h"
#include "DataSinks_types.h"
#include "Data_types.h"
#include "RuntimeProfile_types.h"
#include "PaloService_types.h"


namespace palo {

struct TQueryType {
  enum type {
    SELECT = 0,
    LOAD = 1
  };
};

extern const std::map<int, const char*> _TQueryType_VALUES_TO_NAMES;

struct TErrorHubType {
  enum type {
    MYSQL = 0,
    NULL_TYPE = 1
  };
};

extern const std::map<int, const char*> _TErrorHubType_VALUES_TO_NAMES;

struct PaloInternalServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _PaloInternalServiceVersion_VALUES_TO_NAMES;

class TMysqlErrorHubInfo;

class TLoadErrorHubInfo;

class TQueryOptions;

class TScanRangeParams;

class TPlanFragmentDestination;

class TPlanFragmentExecParams;

class TQueryGlobals;

class TExecPlanFragmentParams;

class TExecPlanFragmentResult;

class TCancelPlanFragmentParams;

class TCancelPlanFragmentResult;

class TTransmitDataParams;

class TTransmitDataResult;

class TFetchDataParams;

class TFetchDataResult;

class TFetchStartKey;

class TFetchEndKey;

class TCondition;

class TFetchRequest;

class TShowHintsRequest;

class TExportStatusResult;


class TMysqlErrorHubInfo {
 public:

  TMysqlErrorHubInfo(const TMysqlErrorHubInfo&);
  TMysqlErrorHubInfo& operator=(const TMysqlErrorHubInfo&);
  TMysqlErrorHubInfo() : host(), port(0), user(), passwd(), db(), table() {
  }

  virtual ~TMysqlErrorHubInfo() throw();
  std::string host;
  int32_t port;
  std::string user;
  std::string passwd;
  std::string db;
  std::string table;

  void __set_host(const std::string& val);

  void __set_port(const int32_t val);

  void __set_user(const std::string& val);

  void __set_passwd(const std::string& val);

  void __set_db(const std::string& val);

  void __set_table(const std::string& val);

  bool operator == (const TMysqlErrorHubInfo & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(db == rhs.db))
      return false;
    if (!(table == rhs.table))
      return false;
    return true;
  }
  bool operator != (const TMysqlErrorHubInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMysqlErrorHubInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMysqlErrorHubInfo &a, TMysqlErrorHubInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TMysqlErrorHubInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TLoadErrorHubInfo__isset {
  _TLoadErrorHubInfo__isset() : mysql_info(false) {}
  bool mysql_info :1;
} _TLoadErrorHubInfo__isset;

class TLoadErrorHubInfo {
 public:

  TLoadErrorHubInfo(const TLoadErrorHubInfo&);
  TLoadErrorHubInfo& operator=(const TLoadErrorHubInfo&);
  TLoadErrorHubInfo() : type((TErrorHubType::type)1) {
    type = (TErrorHubType::type)1;

  }

  virtual ~TLoadErrorHubInfo() throw();
  TErrorHubType::type type;
  TMysqlErrorHubInfo mysql_info;

  _TLoadErrorHubInfo__isset __isset;

  void __set_type(const TErrorHubType::type val);

  void __set_mysql_info(const TMysqlErrorHubInfo& val);

  bool operator == (const TLoadErrorHubInfo & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.mysql_info != rhs.__isset.mysql_info)
      return false;
    else if (__isset.mysql_info && !(mysql_info == rhs.mysql_info))
      return false;
    return true;
  }
  bool operator != (const TLoadErrorHubInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLoadErrorHubInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLoadErrorHubInfo &a, TLoadErrorHubInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TLoadErrorHubInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TQueryOptions__isset {
  _TQueryOptions__isset() : abort_on_error(true), max_errors(true), disable_codegen(true), batch_size(true), num_nodes(true), max_scan_range_length(true), num_scanner_threads(true), max_io_buffers(true), allow_unsupported_formats(true), default_order_by_limit(true), debug_action(true), mem_limit(true), abort_on_default_limit_exceeded(true), query_timeout(true), is_report_success(true), codegen_level(true), kudu_latest_observed_ts(true), query_type(true) {}
  bool abort_on_error :1;
  bool max_errors :1;
  bool disable_codegen :1;
  bool batch_size :1;
  bool num_nodes :1;
  bool max_scan_range_length :1;
  bool num_scanner_threads :1;
  bool max_io_buffers :1;
  bool allow_unsupported_formats :1;
  bool default_order_by_limit :1;
  bool debug_action :1;
  bool mem_limit :1;
  bool abort_on_default_limit_exceeded :1;
  bool query_timeout :1;
  bool is_report_success :1;
  bool codegen_level :1;
  bool kudu_latest_observed_ts :1;
  bool query_type :1;
} _TQueryOptions__isset;

class TQueryOptions {
 public:

  TQueryOptions(const TQueryOptions&);
  TQueryOptions& operator=(const TQueryOptions&);
  TQueryOptions() : abort_on_error(false), max_errors(0), disable_codegen(true), batch_size(0), num_nodes(0), max_scan_range_length(0LL), num_scanner_threads(0), max_io_buffers(0), allow_unsupported_formats(false), default_order_by_limit(-1LL), debug_action(""), mem_limit(2147483648LL), abort_on_default_limit_exceeded(false), query_timeout(3600), is_report_success(false), codegen_level(0), kudu_latest_observed_ts(9223372036854775807LL), query_type((TQueryType::type)0) {
    query_type = (TQueryType::type)0;

  }

  virtual ~TQueryOptions() throw();
  bool abort_on_error;
  int32_t max_errors;
  bool disable_codegen;
  int32_t batch_size;
  int32_t num_nodes;
  int64_t max_scan_range_length;
  int32_t num_scanner_threads;
  int32_t max_io_buffers;
  bool allow_unsupported_formats;
  int64_t default_order_by_limit;
  std::string debug_action;
  int64_t mem_limit;
  bool abort_on_default_limit_exceeded;
  int32_t query_timeout;
  bool is_report_success;
  int32_t codegen_level;
  int64_t kudu_latest_observed_ts;
  TQueryType::type query_type;

  _TQueryOptions__isset __isset;

  void __set_abort_on_error(const bool val);

  void __set_max_errors(const int32_t val);

  void __set_disable_codegen(const bool val);

  void __set_batch_size(const int32_t val);

  void __set_num_nodes(const int32_t val);

  void __set_max_scan_range_length(const int64_t val);

  void __set_num_scanner_threads(const int32_t val);

  void __set_max_io_buffers(const int32_t val);

  void __set_allow_unsupported_formats(const bool val);

  void __set_default_order_by_limit(const int64_t val);

  void __set_debug_action(const std::string& val);

  void __set_mem_limit(const int64_t val);

  void __set_abort_on_default_limit_exceeded(const bool val);

  void __set_query_timeout(const int32_t val);

  void __set_is_report_success(const bool val);

  void __set_codegen_level(const int32_t val);

  void __set_kudu_latest_observed_ts(const int64_t val);

  void __set_query_type(const TQueryType::type val);

  bool operator == (const TQueryOptions & rhs) const
  {
    if (__isset.abort_on_error != rhs.__isset.abort_on_error)
      return false;
    else if (__isset.abort_on_error && !(abort_on_error == rhs.abort_on_error))
      return false;
    if (__isset.max_errors != rhs.__isset.max_errors)
      return false;
    else if (__isset.max_errors && !(max_errors == rhs.max_errors))
      return false;
    if (__isset.disable_codegen != rhs.__isset.disable_codegen)
      return false;
    else if (__isset.disable_codegen && !(disable_codegen == rhs.disable_codegen))
      return false;
    if (__isset.batch_size != rhs.__isset.batch_size)
      return false;
    else if (__isset.batch_size && !(batch_size == rhs.batch_size))
      return false;
    if (__isset.num_nodes != rhs.__isset.num_nodes)
      return false;
    else if (__isset.num_nodes && !(num_nodes == rhs.num_nodes))
      return false;
    if (__isset.max_scan_range_length != rhs.__isset.max_scan_range_length)
      return false;
    else if (__isset.max_scan_range_length && !(max_scan_range_length == rhs.max_scan_range_length))
      return false;
    if (__isset.num_scanner_threads != rhs.__isset.num_scanner_threads)
      return false;
    else if (__isset.num_scanner_threads && !(num_scanner_threads == rhs.num_scanner_threads))
      return false;
    if (__isset.max_io_buffers != rhs.__isset.max_io_buffers)
      return false;
    else if (__isset.max_io_buffers && !(max_io_buffers == rhs.max_io_buffers))
      return false;
    if (__isset.allow_unsupported_formats != rhs.__isset.allow_unsupported_formats)
      return false;
    else if (__isset.allow_unsupported_formats && !(allow_unsupported_formats == rhs.allow_unsupported_formats))
      return false;
    if (__isset.default_order_by_limit != rhs.__isset.default_order_by_limit)
      return false;
    else if (__isset.default_order_by_limit && !(default_order_by_limit == rhs.default_order_by_limit))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    if (__isset.mem_limit != rhs.__isset.mem_limit)
      return false;
    else if (__isset.mem_limit && !(mem_limit == rhs.mem_limit))
      return false;
    if (__isset.abort_on_default_limit_exceeded != rhs.__isset.abort_on_default_limit_exceeded)
      return false;
    else if (__isset.abort_on_default_limit_exceeded && !(abort_on_default_limit_exceeded == rhs.abort_on_default_limit_exceeded))
      return false;
    if (__isset.query_timeout != rhs.__isset.query_timeout)
      return false;
    else if (__isset.query_timeout && !(query_timeout == rhs.query_timeout))
      return false;
    if (__isset.is_report_success != rhs.__isset.is_report_success)
      return false;
    else if (__isset.is_report_success && !(is_report_success == rhs.is_report_success))
      return false;
    if (__isset.codegen_level != rhs.__isset.codegen_level)
      return false;
    else if (__isset.codegen_level && !(codegen_level == rhs.codegen_level))
      return false;
    if (__isset.kudu_latest_observed_ts != rhs.__isset.kudu_latest_observed_ts)
      return false;
    else if (__isset.kudu_latest_observed_ts && !(kudu_latest_observed_ts == rhs.kudu_latest_observed_ts))
      return false;
    if (__isset.query_type != rhs.__isset.query_type)
      return false;
    else if (__isset.query_type && !(query_type == rhs.query_type))
      return false;
    return true;
  }
  bool operator != (const TQueryOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TQueryOptions &a, TQueryOptions &b);

inline std::ostream& operator<<(std::ostream& out, const TQueryOptions& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TScanRangeParams__isset {
  _TScanRangeParams__isset() : volume_id(true) {}
  bool volume_id :1;
} _TScanRangeParams__isset;

class TScanRangeParams {
 public:

  TScanRangeParams(const TScanRangeParams&);
  TScanRangeParams& operator=(const TScanRangeParams&);
  TScanRangeParams() : volume_id(-1) {
  }

  virtual ~TScanRangeParams() throw();
   ::palo::TScanRange scan_range;
  int32_t volume_id;

  _TScanRangeParams__isset __isset;

  void __set_scan_range(const  ::palo::TScanRange& val);

  void __set_volume_id(const int32_t val);

  bool operator == (const TScanRangeParams & rhs) const
  {
    if (!(scan_range == rhs.scan_range))
      return false;
    if (__isset.volume_id != rhs.__isset.volume_id)
      return false;
    else if (__isset.volume_id && !(volume_id == rhs.volume_id))
      return false;
    return true;
  }
  bool operator != (const TScanRangeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRangeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScanRangeParams &a, TScanRangeParams &b);

inline std::ostream& operator<<(std::ostream& out, const TScanRangeParams& obj)
{
  obj.printTo(out);
  return out;
}


class TPlanFragmentDestination {
 public:

  TPlanFragmentDestination(const TPlanFragmentDestination&);
  TPlanFragmentDestination& operator=(const TPlanFragmentDestination&);
  TPlanFragmentDestination() {
  }

  virtual ~TPlanFragmentDestination() throw();
   ::palo::TUniqueId fragment_instance_id;
   ::palo::TNetworkAddress server;

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val);

  void __set_server(const  ::palo::TNetworkAddress& val);

  bool operator == (const TPlanFragmentDestination & rhs) const
  {
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(server == rhs.server))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentDestination &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentDestination & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlanFragmentDestination &a, TPlanFragmentDestination &b);

inline std::ostream& operator<<(std::ostream& out, const TPlanFragmentDestination& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPlanFragmentExecParams__isset {
  _TPlanFragmentExecParams__isset() : destinations(false), debug_node_id(false), debug_phase(false), debug_action(false), sender_id(false) {}
  bool destinations :1;
  bool debug_node_id :1;
  bool debug_phase :1;
  bool debug_action :1;
  bool sender_id :1;
} _TPlanFragmentExecParams__isset;

class TPlanFragmentExecParams {
 public:

  TPlanFragmentExecParams(const TPlanFragmentExecParams&);
  TPlanFragmentExecParams& operator=(const TPlanFragmentExecParams&);
  TPlanFragmentExecParams() : debug_node_id(0), debug_phase(( ::palo::TExecNodePhase::type)0), debug_action(( ::palo::TDebugAction::type)0), sender_id(0) {
  }

  virtual ~TPlanFragmentExecParams() throw();
   ::palo::TUniqueId query_id;
   ::palo::TUniqueId fragment_instance_id;
  std::map< ::palo::TPlanNodeId, std::vector<TScanRangeParams> >  per_node_scan_ranges;
  std::map< ::palo::TPlanNodeId, int32_t>  per_exch_num_senders;
  std::vector<TPlanFragmentDestination>  destinations;
   ::palo::TPlanNodeId debug_node_id;
   ::palo::TExecNodePhase::type debug_phase;
   ::palo::TDebugAction::type debug_action;
  int32_t sender_id;

  _TPlanFragmentExecParams__isset __isset;

  void __set_query_id(const  ::palo::TUniqueId& val);

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val);

  void __set_per_node_scan_ranges(const std::map< ::palo::TPlanNodeId, std::vector<TScanRangeParams> > & val);

  void __set_per_exch_num_senders(const std::map< ::palo::TPlanNodeId, int32_t> & val);

  void __set_destinations(const std::vector<TPlanFragmentDestination> & val);

  void __set_debug_node_id(const  ::palo::TPlanNodeId val);

  void __set_debug_phase(const  ::palo::TExecNodePhase::type val);

  void __set_debug_action(const  ::palo::TDebugAction::type val);

  void __set_sender_id(const int32_t val);

  bool operator == (const TPlanFragmentExecParams & rhs) const
  {
    if (!(query_id == rhs.query_id))
      return false;
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(per_node_scan_ranges == rhs.per_node_scan_ranges))
      return false;
    if (!(per_exch_num_senders == rhs.per_exch_num_senders))
      return false;
    if (!(destinations == rhs.destinations))
      return false;
    if (__isset.debug_node_id != rhs.__isset.debug_node_id)
      return false;
    else if (__isset.debug_node_id && !(debug_node_id == rhs.debug_node_id))
      return false;
    if (__isset.debug_phase != rhs.__isset.debug_phase)
      return false;
    else if (__isset.debug_phase && !(debug_phase == rhs.debug_phase))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    if (__isset.sender_id != rhs.__isset.sender_id)
      return false;
    else if (__isset.sender_id && !(sender_id == rhs.sender_id))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentExecParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentExecParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlanFragmentExecParams &a, TPlanFragmentExecParams &b);

inline std::ostream& operator<<(std::ostream& out, const TPlanFragmentExecParams& obj)
{
  obj.printTo(out);
  return out;
}


class TQueryGlobals {
 public:

  TQueryGlobals(const TQueryGlobals&);
  TQueryGlobals& operator=(const TQueryGlobals&);
  TQueryGlobals() : now_string() {
  }

  virtual ~TQueryGlobals() throw();
  std::string now_string;

  void __set_now_string(const std::string& val);

  bool operator == (const TQueryGlobals & rhs) const
  {
    if (!(now_string == rhs.now_string))
      return false;
    return true;
  }
  bool operator != (const TQueryGlobals &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryGlobals & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TQueryGlobals &a, TQueryGlobals &b);

inline std::ostream& operator<<(std::ostream& out, const TQueryGlobals& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TExecPlanFragmentParams__isset {
  _TExecPlanFragmentParams__isset() : fragment(false), desc_tbl(false), params(false), coord(false), backend_num(false), query_globals(false), query_options(false), is_report_success(false), resource_info(false), import_label(false), db_name(false), load_job_id(false), load_error_hub_info(false) {}
  bool fragment :1;
  bool desc_tbl :1;
  bool params :1;
  bool coord :1;
  bool backend_num :1;
  bool query_globals :1;
  bool query_options :1;
  bool is_report_success :1;
  bool resource_info :1;
  bool import_label :1;
  bool db_name :1;
  bool load_job_id :1;
  bool load_error_hub_info :1;
} _TExecPlanFragmentParams__isset;

class TExecPlanFragmentParams {
 public:

  TExecPlanFragmentParams(const TExecPlanFragmentParams&);
  TExecPlanFragmentParams& operator=(const TExecPlanFragmentParams&);
  TExecPlanFragmentParams() : protocol_version((PaloInternalServiceVersion::type)0), backend_num(0), is_report_success(0), import_label(), db_name(), load_job_id(0) {
  }

  virtual ~TExecPlanFragmentParams() throw();
  PaloInternalServiceVersion::type protocol_version;
   ::palo::TPlanFragment fragment;
   ::palo::TDescriptorTable desc_tbl;
  TPlanFragmentExecParams params;
   ::palo::TNetworkAddress coord;
  int32_t backend_num;
  TQueryGlobals query_globals;
  TQueryOptions query_options;
  bool is_report_success;
   ::palo::TResourceInfo resource_info;
  std::string import_label;
  std::string db_name;
  int64_t load_job_id;
  TLoadErrorHubInfo load_error_hub_info;

  _TExecPlanFragmentParams__isset __isset;

  void __set_protocol_version(const PaloInternalServiceVersion::type val);

  void __set_fragment(const  ::palo::TPlanFragment& val);

  void __set_desc_tbl(const  ::palo::TDescriptorTable& val);

  void __set_params(const TPlanFragmentExecParams& val);

  void __set_coord(const  ::palo::TNetworkAddress& val);

  void __set_backend_num(const int32_t val);

  void __set_query_globals(const TQueryGlobals& val);

  void __set_query_options(const TQueryOptions& val);

  void __set_is_report_success(const bool val);

  void __set_resource_info(const  ::palo::TResourceInfo& val);

  void __set_import_label(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_load_job_id(const int64_t val);

  void __set_load_error_hub_info(const TLoadErrorHubInfo& val);

  bool operator == (const TExecPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment != rhs.__isset.fragment)
      return false;
    else if (__isset.fragment && !(fragment == rhs.fragment))
      return false;
    if (__isset.desc_tbl != rhs.__isset.desc_tbl)
      return false;
    else if (__isset.desc_tbl && !(desc_tbl == rhs.desc_tbl))
      return false;
    if (__isset.params != rhs.__isset.params)
      return false;
    else if (__isset.params && !(params == rhs.params))
      return false;
    if (__isset.coord != rhs.__isset.coord)
      return false;
    else if (__isset.coord && !(coord == rhs.coord))
      return false;
    if (__isset.backend_num != rhs.__isset.backend_num)
      return false;
    else if (__isset.backend_num && !(backend_num == rhs.backend_num))
      return false;
    if (__isset.query_globals != rhs.__isset.query_globals)
      return false;
    else if (__isset.query_globals && !(query_globals == rhs.query_globals))
      return false;
    if (__isset.query_options != rhs.__isset.query_options)
      return false;
    else if (__isset.query_options && !(query_options == rhs.query_options))
      return false;
    if (__isset.is_report_success != rhs.__isset.is_report_success)
      return false;
    else if (__isset.is_report_success && !(is_report_success == rhs.is_report_success))
      return false;
    if (__isset.resource_info != rhs.__isset.resource_info)
      return false;
    else if (__isset.resource_info && !(resource_info == rhs.resource_info))
      return false;
    if (__isset.import_label != rhs.__isset.import_label)
      return false;
    else if (__isset.import_label && !(import_label == rhs.import_label))
      return false;
    if (__isset.db_name != rhs.__isset.db_name)
      return false;
    else if (__isset.db_name && !(db_name == rhs.db_name))
      return false;
    if (__isset.load_job_id != rhs.__isset.load_job_id)
      return false;
    else if (__isset.load_job_id && !(load_job_id == rhs.load_job_id))
      return false;
    if (__isset.load_error_hub_info != rhs.__isset.load_error_hub_info)
      return false;
    else if (__isset.load_error_hub_info && !(load_error_hub_info == rhs.load_error_hub_info))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExecPlanFragmentParams &a, TExecPlanFragmentParams &b);

inline std::ostream& operator<<(std::ostream& out, const TExecPlanFragmentParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TExecPlanFragmentResult__isset {
  _TExecPlanFragmentResult__isset() : status(false) {}
  bool status :1;
} _TExecPlanFragmentResult__isset;

class TExecPlanFragmentResult {
 public:

  TExecPlanFragmentResult(const TExecPlanFragmentResult&);
  TExecPlanFragmentResult& operator=(const TExecPlanFragmentResult&);
  TExecPlanFragmentResult() {
  }

  virtual ~TExecPlanFragmentResult() throw();
   ::palo::TStatus status;

  _TExecPlanFragmentResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val);

  bool operator == (const TExecPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExecPlanFragmentResult &a, TExecPlanFragmentResult &b);

inline std::ostream& operator<<(std::ostream& out, const TExecPlanFragmentResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCancelPlanFragmentParams__isset {
  _TCancelPlanFragmentParams__isset() : fragment_instance_id(false) {}
  bool fragment_instance_id :1;
} _TCancelPlanFragmentParams__isset;

class TCancelPlanFragmentParams {
 public:

  TCancelPlanFragmentParams(const TCancelPlanFragmentParams&);
  TCancelPlanFragmentParams& operator=(const TCancelPlanFragmentParams&);
  TCancelPlanFragmentParams() : protocol_version((PaloInternalServiceVersion::type)0) {
  }

  virtual ~TCancelPlanFragmentParams() throw();
  PaloInternalServiceVersion::type protocol_version;
   ::palo::TUniqueId fragment_instance_id;

  _TCancelPlanFragmentParams__isset __isset;

  void __set_protocol_version(const PaloInternalServiceVersion::type val);

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val);

  bool operator == (const TCancelPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment_instance_id != rhs.__isset.fragment_instance_id)
      return false;
    else if (__isset.fragment_instance_id && !(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelPlanFragmentParams &a, TCancelPlanFragmentParams &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelPlanFragmentParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCancelPlanFragmentResult__isset {
  _TCancelPlanFragmentResult__isset() : status(false) {}
  bool status :1;
} _TCancelPlanFragmentResult__isset;

class TCancelPlanFragmentResult {
 public:

  TCancelPlanFragmentResult(const TCancelPlanFragmentResult&);
  TCancelPlanFragmentResult& operator=(const TCancelPlanFragmentResult&);
  TCancelPlanFragmentResult() {
  }

  virtual ~TCancelPlanFragmentResult() throw();
   ::palo::TStatus status;

  _TCancelPlanFragmentResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val);

  bool operator == (const TCancelPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelPlanFragmentResult &a, TCancelPlanFragmentResult &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelPlanFragmentResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTransmitDataParams__isset {
  _TTransmitDataParams__isset() : dest_fragment_instance_id(false), dest_node_id(false), row_batch(false), eos(false), be_number(false), packet_seq(false), sender_id(false) {}
  bool dest_fragment_instance_id :1;
  bool dest_node_id :1;
  bool row_batch :1;
  bool eos :1;
  bool be_number :1;
  bool packet_seq :1;
  bool sender_id :1;
} _TTransmitDataParams__isset;

class TTransmitDataParams {
 public:

  TTransmitDataParams(const TTransmitDataParams&);
  TTransmitDataParams& operator=(const TTransmitDataParams&);
  TTransmitDataParams() : protocol_version((PaloInternalServiceVersion::type)0), dest_node_id(0), eos(0), be_number(0), packet_seq(0), sender_id(0) {
  }

  virtual ~TTransmitDataParams() throw();
  PaloInternalServiceVersion::type protocol_version;
   ::palo::TUniqueId dest_fragment_instance_id;
   ::palo::TPlanNodeId dest_node_id;
   ::palo::TRowBatch row_batch;
  bool eos;
  int32_t be_number;
  int64_t packet_seq;
  int32_t sender_id;

  _TTransmitDataParams__isset __isset;

  void __set_protocol_version(const PaloInternalServiceVersion::type val);

  void __set_dest_fragment_instance_id(const  ::palo::TUniqueId& val);

  void __set_dest_node_id(const  ::palo::TPlanNodeId val);

  void __set_row_batch(const  ::palo::TRowBatch& val);

  void __set_eos(const bool val);

  void __set_be_number(const int32_t val);

  void __set_packet_seq(const int64_t val);

  void __set_sender_id(const int32_t val);

  bool operator == (const TTransmitDataParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.dest_fragment_instance_id != rhs.__isset.dest_fragment_instance_id)
      return false;
    else if (__isset.dest_fragment_instance_id && !(dest_fragment_instance_id == rhs.dest_fragment_instance_id))
      return false;
    if (__isset.dest_node_id != rhs.__isset.dest_node_id)
      return false;
    else if (__isset.dest_node_id && !(dest_node_id == rhs.dest_node_id))
      return false;
    if (__isset.row_batch != rhs.__isset.row_batch)
      return false;
    else if (__isset.row_batch && !(row_batch == rhs.row_batch))
      return false;
    if (__isset.eos != rhs.__isset.eos)
      return false;
    else if (__isset.eos && !(eos == rhs.eos))
      return false;
    if (__isset.be_number != rhs.__isset.be_number)
      return false;
    else if (__isset.be_number && !(be_number == rhs.be_number))
      return false;
    if (__isset.packet_seq != rhs.__isset.packet_seq)
      return false;
    else if (__isset.packet_seq && !(packet_seq == rhs.packet_seq))
      return false;
    if (__isset.sender_id != rhs.__isset.sender_id)
      return false;
    else if (__isset.sender_id && !(sender_id == rhs.sender_id))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTransmitDataParams &a, TTransmitDataParams &b);

inline std::ostream& operator<<(std::ostream& out, const TTransmitDataParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTransmitDataResult__isset {
  _TTransmitDataResult__isset() : status(false), packet_seq(false), dest_fragment_instance_id(false), dest_node_id(false) {}
  bool status :1;
  bool packet_seq :1;
  bool dest_fragment_instance_id :1;
  bool dest_node_id :1;
} _TTransmitDataResult__isset;

class TTransmitDataResult {
 public:

  TTransmitDataResult(const TTransmitDataResult&);
  TTransmitDataResult& operator=(const TTransmitDataResult&);
  TTransmitDataResult() : packet_seq(0), dest_node_id(0) {
  }

  virtual ~TTransmitDataResult() throw();
   ::palo::TStatus status;
  int64_t packet_seq;
   ::palo::TUniqueId dest_fragment_instance_id;
   ::palo::TPlanNodeId dest_node_id;

  _TTransmitDataResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val);

  void __set_packet_seq(const int64_t val);

  void __set_dest_fragment_instance_id(const  ::palo::TUniqueId& val);

  void __set_dest_node_id(const  ::palo::TPlanNodeId val);

  bool operator == (const TTransmitDataResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.packet_seq != rhs.__isset.packet_seq)
      return false;
    else if (__isset.packet_seq && !(packet_seq == rhs.packet_seq))
      return false;
    if (__isset.dest_fragment_instance_id != rhs.__isset.dest_fragment_instance_id)
      return false;
    else if (__isset.dest_fragment_instance_id && !(dest_fragment_instance_id == rhs.dest_fragment_instance_id))
      return false;
    if (__isset.dest_node_id != rhs.__isset.dest_node_id)
      return false;
    else if (__isset.dest_node_id && !(dest_node_id == rhs.dest_node_id))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTransmitDataResult &a, TTransmitDataResult &b);

inline std::ostream& operator<<(std::ostream& out, const TTransmitDataResult& obj)
{
  obj.printTo(out);
  return out;
}


class TFetchDataParams {
 public:

  TFetchDataParams(const TFetchDataParams&);
  TFetchDataParams& operator=(const TFetchDataParams&);
  TFetchDataParams() : protocol_version((PaloInternalServiceVersion::type)0) {
  }

  virtual ~TFetchDataParams() throw();
  PaloInternalServiceVersion::type protocol_version;
   ::palo::TUniqueId fragment_instance_id;

  void __set_protocol_version(const PaloInternalServiceVersion::type val);

  void __set_fragment_instance_id(const  ::palo::TUniqueId& val);

  bool operator == (const TFetchDataParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    return true;
  }
  bool operator != (const TFetchDataParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchDataParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchDataParams &a, TFetchDataParams &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchDataParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TFetchDataResult__isset {
  _TFetchDataResult__isset() : status(false) {}
  bool status :1;
} _TFetchDataResult__isset;

class TFetchDataResult {
 public:

  TFetchDataResult(const TFetchDataResult&);
  TFetchDataResult& operator=(const TFetchDataResult&);
  TFetchDataResult() : eos(0), packet_num(0) {
  }

  virtual ~TFetchDataResult() throw();
   ::palo::TResultBatch result_batch;
  bool eos;
  int32_t packet_num;
   ::palo::TStatus status;

  _TFetchDataResult__isset __isset;

  void __set_result_batch(const  ::palo::TResultBatch& val);

  void __set_eos(const bool val);

  void __set_packet_num(const int32_t val);

  void __set_status(const  ::palo::TStatus& val);

  bool operator == (const TFetchDataResult & rhs) const
  {
    if (!(result_batch == rhs.result_batch))
      return false;
    if (!(eos == rhs.eos))
      return false;
    if (!(packet_num == rhs.packet_num))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TFetchDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchDataResult &a, TFetchDataResult &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchDataResult& obj)
{
  obj.printTo(out);
  return out;
}


class TFetchStartKey {
 public:

  TFetchStartKey(const TFetchStartKey&);
  TFetchStartKey& operator=(const TFetchStartKey&);
  TFetchStartKey() {
  }

  virtual ~TFetchStartKey() throw();
  std::vector<std::string>  key;

  void __set_key(const std::vector<std::string> & val);

  bool operator == (const TFetchStartKey & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const TFetchStartKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchStartKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchStartKey &a, TFetchStartKey &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchStartKey& obj)
{
  obj.printTo(out);
  return out;
}


class TFetchEndKey {
 public:

  TFetchEndKey(const TFetchEndKey&);
  TFetchEndKey& operator=(const TFetchEndKey&);
  TFetchEndKey() {
  }

  virtual ~TFetchEndKey() throw();
  std::vector<std::string>  key;

  void __set_key(const std::vector<std::string> & val);

  bool operator == (const TFetchEndKey & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    return true;
  }
  bool operator != (const TFetchEndKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchEndKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchEndKey &a, TFetchEndKey &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchEndKey& obj)
{
  obj.printTo(out);
  return out;
}


class TCondition {
 public:

  TCondition(const TCondition&);
  TCondition& operator=(const TCondition&);
  TCondition() : column_name(), condition_op() {
  }

  virtual ~TCondition() throw();
  std::string column_name;
  std::string condition_op;
  std::vector<std::string>  condition_values;

  void __set_column_name(const std::string& val);

  void __set_condition_op(const std::string& val);

  void __set_condition_values(const std::vector<std::string> & val);

  bool operator == (const TCondition & rhs) const
  {
    if (!(column_name == rhs.column_name))
      return false;
    if (!(condition_op == rhs.condition_op))
      return false;
    if (!(condition_values == rhs.condition_values))
      return false;
    return true;
  }
  bool operator != (const TCondition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCondition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCondition &a, TCondition &b);

inline std::ostream& operator<<(std::ostream& out, const TCondition& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TFetchRequest__isset {
  _TFetchRequest__isset() : num_rows(false), user(false), output(false), range(false), end_range(false), aggregation(false) {}
  bool num_rows :1;
  bool user :1;
  bool output :1;
  bool range :1;
  bool end_range :1;
  bool aggregation :1;
} _TFetchRequest__isset;

class TFetchRequest {
 public:

  TFetchRequest(const TFetchRequest&);
  TFetchRequest& operator=(const TFetchRequest&);
  TFetchRequest() : use_compression(0), num_rows(0), schema_hash(0), tablet_id(0), version(0), version_hash(0), user(), output(), range(), end_range(), aggregation(0) {
  }

  virtual ~TFetchRequest() throw();
  bool use_compression;
  int32_t num_rows;
  int32_t schema_hash;
   ::palo::TTabletId tablet_id;
  int32_t version;
  int64_t version_hash;
  std::vector<std::string>  field;
  std::string user;
  std::string output;
  std::string range;
  std::vector<TFetchStartKey>  start_key;
  std::vector<TFetchEndKey>  end_key;
  std::vector<TCondition>  where;
  std::string end_range;
  bool aggregation;

  _TFetchRequest__isset __isset;

  void __set_use_compression(const bool val);

  void __set_num_rows(const int32_t val);

  void __set_schema_hash(const int32_t val);

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_version(const int32_t val);

  void __set_version_hash(const int64_t val);

  void __set_field(const std::vector<std::string> & val);

  void __set_user(const std::string& val);

  void __set_output(const std::string& val);

  void __set_range(const std::string& val);

  void __set_start_key(const std::vector<TFetchStartKey> & val);

  void __set_end_key(const std::vector<TFetchEndKey> & val);

  void __set_where(const std::vector<TCondition> & val);

  void __set_end_range(const std::string& val);

  void __set_aggregation(const bool val);

  bool operator == (const TFetchRequest & rhs) const
  {
    if (!(use_compression == rhs.use_compression))
      return false;
    if (__isset.num_rows != rhs.__isset.num_rows)
      return false;
    else if (__isset.num_rows && !(num_rows == rhs.num_rows))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    if (!(field == rhs.field))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.output != rhs.__isset.output)
      return false;
    else if (__isset.output && !(output == rhs.output))
      return false;
    if (__isset.range != rhs.__isset.range)
      return false;
    else if (__isset.range && !(range == rhs.range))
      return false;
    if (!(start_key == rhs.start_key))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    if (!(where == rhs.where))
      return false;
    if (__isset.end_range != rhs.__isset.end_range)
      return false;
    else if (__isset.end_range && !(end_range == rhs.end_range))
      return false;
    if (__isset.aggregation != rhs.__isset.aggregation)
      return false;
    else if (__isset.aggregation && !(aggregation == rhs.aggregation))
      return false;
    return true;
  }
  bool operator != (const TFetchRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchRequest &a, TFetchRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TShowHintsRequest__isset {
  _TShowHintsRequest__isset() : end_range(true) {}
  bool end_range :1;
} _TShowHintsRequest__isset;

class TShowHintsRequest {
 public:

  TShowHintsRequest(const TShowHintsRequest&);
  TShowHintsRequest& operator=(const TShowHintsRequest&);
  TShowHintsRequest() : tablet_id(0), schema_hash(0), block_row_count(0), end_range("lt") {
  }

  virtual ~TShowHintsRequest() throw();
   ::palo::TTabletId tablet_id;
  int32_t schema_hash;
  int32_t block_row_count;
  std::string end_range;
  std::vector<TFetchStartKey>  start_key;
  std::vector<TFetchEndKey>  end_key;

  _TShowHintsRequest__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const int32_t val);

  void __set_block_row_count(const int32_t val);

  void __set_end_range(const std::string& val);

  void __set_start_key(const std::vector<TFetchStartKey> & val);

  void __set_end_key(const std::vector<TFetchEndKey> & val);

  bool operator == (const TShowHintsRequest & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(block_row_count == rhs.block_row_count))
      return false;
    if (__isset.end_range != rhs.__isset.end_range)
      return false;
    else if (__isset.end_range && !(end_range == rhs.end_range))
      return false;
    if (!(start_key == rhs.start_key))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    return true;
  }
  bool operator != (const TShowHintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowHintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowHintsRequest &a, TShowHintsRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TShowHintsRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TExportStatusResult__isset {
  _TExportStatusResult__isset() : files(false) {}
  bool files :1;
} _TExportStatusResult__isset;

class TExportStatusResult {
 public:

  TExportStatusResult(const TExportStatusResult&);
  TExportStatusResult& operator=(const TExportStatusResult&);
  TExportStatusResult() : state(( ::palo::TExportState::type)0) {
  }

  virtual ~TExportStatusResult() throw();
   ::palo::TStatus status;
   ::palo::TExportState::type state;
  std::vector<std::string>  files;

  _TExportStatusResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val);

  void __set_state(const  ::palo::TExportState::type val);

  void __set_files(const std::vector<std::string> & val);

  bool operator == (const TExportStatusResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.files != rhs.__isset.files)
      return false;
    else if (__isset.files && !(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const TExportStatusResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExportStatusResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExportStatusResult &a, TExportStatusResult &b);

inline std::ostream& operator<<(std::ostream& out, const TExportStatusResult& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
