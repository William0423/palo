/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DataSinks_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTDataSinkTypeValues[] = {
  TDataSinkType::DATA_STREAM_SINK,
  TDataSinkType::RESULT_SINK,
  TDataSinkType::DATA_SPLIT_SINK,
  TDataSinkType::MYSQL_TABLE_SINK,
  TDataSinkType::EXPORT_SINK
};
const char* _kTDataSinkTypeNames[] = {
  "DATA_STREAM_SINK",
  "RESULT_SINK",
  "DATA_SPLIT_SINK",
  "MYSQL_TABLE_SINK",
  "EXPORT_SINK"
};
const std::map<int, const char*> _TDataSinkType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDataSinkTypeValues, _kTDataSinkTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TDataStreamSink::~TDataStreamSink() throw() {
}


void TDataStreamSink::__set_dest_node_id(const  ::palo::TPlanNodeId val) {
  this->dest_node_id = val;
}

void TDataStreamSink::__set_output_partition(const  ::palo::TDataPartition& val) {
  this->output_partition = val;
}

void TDataStreamSink::__set_ignore_not_found(const bool val) {
  this->ignore_not_found = val;
__isset.ignore_not_found = true;
}

uint32_t TDataStreamSink::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dest_node_id = false;
  bool isset_output_partition = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          isset_dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->output_partition.read(iprot);
          isset_output_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignore_not_found);
          this->__isset.ignore_not_found = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dest_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataStreamSink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataStreamSink");

  xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dest_node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_partition", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->output_partition.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ignore_not_found) {
    xfer += oprot->writeFieldBegin("ignore_not_found", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->ignore_not_found);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataStreamSink &a, TDataStreamSink &b) {
  using ::std::swap;
  swap(a.dest_node_id, b.dest_node_id);
  swap(a.output_partition, b.output_partition);
  swap(a.ignore_not_found, b.ignore_not_found);
  swap(a.__isset, b.__isset);
}

TDataStreamSink::TDataStreamSink(const TDataStreamSink& other0) {
  dest_node_id = other0.dest_node_id;
  output_partition = other0.output_partition;
  ignore_not_found = other0.ignore_not_found;
  __isset = other0.__isset;
}
TDataStreamSink& TDataStreamSink::operator=(const TDataStreamSink& other1) {
  dest_node_id = other1.dest_node_id;
  output_partition = other1.output_partition;
  ignore_not_found = other1.ignore_not_found;
  __isset = other1.__isset;
  return *this;
}
void TDataStreamSink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataStreamSink(";
  out << "dest_node_id=" << to_string(dest_node_id);
  out << ", " << "output_partition=" << to_string(output_partition);
  out << ", " << "ignore_not_found="; (__isset.ignore_not_found ? (out << to_string(ignore_not_found)) : (out << "<null>"));
  out << ")";
}


TResultSink::~TResultSink() throw() {
}


uint32_t TResultSink::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TResultSink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResultSink");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResultSink &a, TResultSink &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TResultSink::TResultSink(const TResultSink& other2) {
  (void) other2;
}
TResultSink& TResultSink::operator=(const TResultSink& other3) {
  (void) other3;
  return *this;
}
void TResultSink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResultSink(";
  out << ")";
}


TMysqlTableSink::~TMysqlTableSink() throw() {
}


void TMysqlTableSink::__set_host(const std::string& val) {
  this->host = val;
}

void TMysqlTableSink::__set_port(const int32_t val) {
  this->port = val;
}

void TMysqlTableSink::__set_user(const std::string& val) {
  this->user = val;
}

void TMysqlTableSink::__set_passwd(const std::string& val) {
  this->passwd = val;
}

void TMysqlTableSink::__set_db(const std::string& val) {
  this->db = val;
}

void TMysqlTableSink::__set_table(const std::string& val) {
  this->table = val;
}

uint32_t TMysqlTableSink::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_port = false;
  bool isset_user = false;
  bool isset_passwd = false;
  bool isset_db = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          isset_passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_passwd)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMysqlTableSink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMysqlTableSink");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMysqlTableSink &a, TMysqlTableSink &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.db, b.db);
  swap(a.table, b.table);
}

TMysqlTableSink::TMysqlTableSink(const TMysqlTableSink& other4) {
  host = other4.host;
  port = other4.port;
  user = other4.user;
  passwd = other4.passwd;
  db = other4.db;
  table = other4.table;
}
TMysqlTableSink& TMysqlTableSink::operator=(const TMysqlTableSink& other5) {
  host = other5.host;
  port = other5.port;
  user = other5.user;
  passwd = other5.passwd;
  db = other5.db;
  table = other5.table;
  return *this;
}
void TMysqlTableSink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMysqlTableSink(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ", " << "user=" << to_string(user);
  out << ", " << "passwd=" << to_string(passwd);
  out << ", " << "db=" << to_string(db);
  out << ", " << "table=" << to_string(table);
  out << ")";
}


TRollupSchema::~TRollupSchema() throw() {
}


void TRollupSchema::__set_keys(const std::vector< ::palo::TExpr> & val) {
  this->keys = val;
}

void TRollupSchema::__set_values(const std::vector< ::palo::TExpr> & val) {
  this->values = val;
}

void TRollupSchema::__set_value_ops(const std::vector< ::palo::TAggregationType::type> & val) {
  this->value_ops = val;
}

void TRollupSchema::__set_keys_type(const std::string& val) {
  this->keys_type = val;
__isset.keys_type = true;
}

uint32_t TRollupSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keys = false;
  bool isset_values = false;
  bool isset_value_ops = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->keys.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->keys[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->values.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->values[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value_ops.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->value_ops.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              int32_t ecast21;
              xfer += iprot->readI32(ecast21);
              this->value_ops[_i20] = ( ::palo::TAggregationType::type)ecast21;
            }
            xfer += iprot->readListEnd();
          }
          isset_value_ops = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->keys_type);
          this->__isset.keys_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value_ops)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRollupSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRollupSchema");

  xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->keys.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter22;
    for (_iter22 = this->keys.begin(); _iter22 != this->keys.end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter23;
    for (_iter23 = this->values.begin(); _iter23 != this->values.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value_ops", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->value_ops.size()));
    std::vector< ::palo::TAggregationType::type> ::const_iterator _iter24;
    for (_iter24 = this->value_ops.begin(); _iter24 != this->value_ops.end(); ++_iter24)
    {
      xfer += oprot->writeI32((int32_t)(*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.keys_type) {
    xfer += oprot->writeFieldBegin("keys_type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->keys_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRollupSchema &a, TRollupSchema &b) {
  using ::std::swap;
  swap(a.keys, b.keys);
  swap(a.values, b.values);
  swap(a.value_ops, b.value_ops);
  swap(a.keys_type, b.keys_type);
  swap(a.__isset, b.__isset);
}

TRollupSchema::TRollupSchema(const TRollupSchema& other25) {
  keys = other25.keys;
  values = other25.values;
  value_ops = other25.value_ops;
  keys_type = other25.keys_type;
  __isset = other25.__isset;
}
TRollupSchema& TRollupSchema::operator=(const TRollupSchema& other26) {
  keys = other26.keys;
  values = other26.values;
  value_ops = other26.value_ops;
  keys_type = other26.keys_type;
  __isset = other26.__isset;
  return *this;
}
void TRollupSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRollupSchema(";
  out << "keys=" << to_string(keys);
  out << ", " << "values=" << to_string(values);
  out << ", " << "value_ops=" << to_string(value_ops);
  out << ", " << "keys_type="; (__isset.keys_type ? (out << to_string(keys_type)) : (out << "<null>"));
  out << ")";
}


TDataSplitSink::~TDataSplitSink() throw() {
}


void TDataSplitSink::__set_partition_exprs(const std::vector< ::palo::TExpr> & val) {
  this->partition_exprs = val;
}

void TDataSplitSink::__set_partition_infos(const std::vector< ::palo::TRangePartition> & val) {
  this->partition_infos = val;
}

void TDataSplitSink::__set_rollup_schemas(const std::map<std::string, TRollupSchema> & val) {
  this->rollup_schemas = val;
}

uint32_t TDataSplitSink::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_exprs = false;
  bool isset_partition_infos = false;
  bool isset_rollup_schemas = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_exprs.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->partition_exprs.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->partition_exprs[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_infos.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->partition_infos.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->partition_infos[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->rollup_schemas.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _ktype38;
            ::apache::thrift::protocol::TType _vtype39;
            xfer += iprot->readMapBegin(_ktype38, _vtype39, _size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              std::string _key42;
              xfer += iprot->readString(_key42);
              TRollupSchema& _val43 = this->rollup_schemas[_key42];
              xfer += _val43.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_rollup_schemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_infos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rollup_schemas)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataSplitSink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataSplitSink");

  xfer += oprot->writeFieldBegin("partition_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter44;
    for (_iter44 = this->partition_exprs.begin(); _iter44 != this->partition_exprs.end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
    std::vector< ::palo::TRangePartition> ::const_iterator _iter45;
    for (_iter45 = this->partition_infos.begin(); _iter45 != this->partition_infos.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rollup_schemas", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rollup_schemas.size()));
    std::map<std::string, TRollupSchema> ::const_iterator _iter46;
    for (_iter46 = this->rollup_schemas.begin(); _iter46 != this->rollup_schemas.end(); ++_iter46)
    {
      xfer += oprot->writeString(_iter46->first);
      xfer += _iter46->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataSplitSink &a, TDataSplitSink &b) {
  using ::std::swap;
  swap(a.partition_exprs, b.partition_exprs);
  swap(a.partition_infos, b.partition_infos);
  swap(a.rollup_schemas, b.rollup_schemas);
}

TDataSplitSink::TDataSplitSink(const TDataSplitSink& other47) {
  partition_exprs = other47.partition_exprs;
  partition_infos = other47.partition_infos;
  rollup_schemas = other47.rollup_schemas;
}
TDataSplitSink& TDataSplitSink::operator=(const TDataSplitSink& other48) {
  partition_exprs = other48.partition_exprs;
  partition_infos = other48.partition_infos;
  rollup_schemas = other48.rollup_schemas;
  return *this;
}
void TDataSplitSink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataSplitSink(";
  out << "partition_exprs=" << to_string(partition_exprs);
  out << ", " << "partition_infos=" << to_string(partition_infos);
  out << ", " << "rollup_schemas=" << to_string(rollup_schemas);
  out << ")";
}


TExportSink::~TExportSink() throw() {
}


void TExportSink::__set_file_type(const  ::palo::TFileType::type val) {
  this->file_type = val;
}

void TExportSink::__set_export_path(const std::string& val) {
  this->export_path = val;
}

void TExportSink::__set_column_separator(const std::string& val) {
  this->column_separator = val;
}

void TExportSink::__set_line_delimiter(const std::string& val) {
  this->line_delimiter = val;
}

void TExportSink::__set_broker_addresses(const std::vector< ::palo::TNetworkAddress> & val) {
  this->broker_addresses = val;
__isset.broker_addresses = true;
}

void TExportSink::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

uint32_t TExportSink::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_type = false;
  bool isset_export_path = false;
  bool isset_column_separator = false;
  bool isset_line_delimiter = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast49;
          xfer += iprot->readI32(ecast49);
          this->file_type = ( ::palo::TFileType::type)ecast49;
          isset_file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->export_path);
          isset_export_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_separator);
          isset_column_separator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delimiter);
          isset_line_delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->broker_addresses.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->broker_addresses.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += this->broker_addresses[_i54].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.broker_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _ktype56;
            ::apache::thrift::protocol::TType _vtype57;
            xfer += iprot->readMapBegin(_ktype56, _vtype57, _size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              std::string _key60;
              xfer += iprot->readString(_key60);
              std::string& _val61 = this->properties[_key60];
              xfer += iprot->readString(_val61);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_export_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_separator)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_line_delimiter)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExportSink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExportSink");

  xfer += oprot->writeFieldBegin("file_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->file_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("export_path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->export_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_separator", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_separator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delimiter", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->line_delimiter);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.broker_addresses) {
    xfer += oprot->writeFieldBegin("broker_addresses", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->broker_addresses.size()));
      std::vector< ::palo::TNetworkAddress> ::const_iterator _iter62;
      for (_iter62 = this->broker_addresses.begin(); _iter62 != this->broker_addresses.end(); ++_iter62)
      {
        xfer += (*_iter62).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter63;
      for (_iter63 = this->properties.begin(); _iter63 != this->properties.end(); ++_iter63)
      {
        xfer += oprot->writeString(_iter63->first);
        xfer += oprot->writeString(_iter63->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExportSink &a, TExportSink &b) {
  using ::std::swap;
  swap(a.file_type, b.file_type);
  swap(a.export_path, b.export_path);
  swap(a.column_separator, b.column_separator);
  swap(a.line_delimiter, b.line_delimiter);
  swap(a.broker_addresses, b.broker_addresses);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

TExportSink::TExportSink(const TExportSink& other64) {
  file_type = other64.file_type;
  export_path = other64.export_path;
  column_separator = other64.column_separator;
  line_delimiter = other64.line_delimiter;
  broker_addresses = other64.broker_addresses;
  properties = other64.properties;
  __isset = other64.__isset;
}
TExportSink& TExportSink::operator=(const TExportSink& other65) {
  file_type = other65.file_type;
  export_path = other65.export_path;
  column_separator = other65.column_separator;
  line_delimiter = other65.line_delimiter;
  broker_addresses = other65.broker_addresses;
  properties = other65.properties;
  __isset = other65.__isset;
  return *this;
}
void TExportSink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExportSink(";
  out << "file_type=" << to_string(file_type);
  out << ", " << "export_path=" << to_string(export_path);
  out << ", " << "column_separator=" << to_string(column_separator);
  out << ", " << "line_delimiter=" << to_string(line_delimiter);
  out << ", " << "broker_addresses="; (__isset.broker_addresses ? (out << to_string(broker_addresses)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ")";
}


TDataSink::~TDataSink() throw() {
}


void TDataSink::__set_type(const TDataSinkType::type val) {
  this->type = val;
}

void TDataSink::__set_stream_sink(const TDataStreamSink& val) {
  this->stream_sink = val;
__isset.stream_sink = true;
}

void TDataSink::__set_result_sink(const TResultSink& val) {
  this->result_sink = val;
__isset.result_sink = true;
}

void TDataSink::__set_split_sink(const TDataSplitSink& val) {
  this->split_sink = val;
__isset.split_sink = true;
}

void TDataSink::__set_mysql_table_sink(const TMysqlTableSink& val) {
  this->mysql_table_sink = val;
__isset.mysql_table_sink = true;
}

void TDataSink::__set_export_sink(const TExportSink& val) {
  this->export_sink = val;
__isset.export_sink = true;
}

uint32_t TDataSink::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          this->type = (TDataSinkType::type)ecast66;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stream_sink.read(iprot);
          this->__isset.stream_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_sink.read(iprot);
          this->__isset.result_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->split_sink.read(iprot);
          this->__isset.split_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mysql_table_sink.read(iprot);
          this->__isset.mysql_table_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->export_sink.read(iprot);
          this->__isset.export_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataSink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataSink");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stream_sink) {
    xfer += oprot->writeFieldBegin("stream_sink", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->stream_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_sink) {
    xfer += oprot->writeFieldBegin("result_sink", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->result_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.split_sink) {
    xfer += oprot->writeFieldBegin("split_sink", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->split_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mysql_table_sink) {
    xfer += oprot->writeFieldBegin("mysql_table_sink", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->mysql_table_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_sink) {
    xfer += oprot->writeFieldBegin("export_sink", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->export_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataSink &a, TDataSink &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.stream_sink, b.stream_sink);
  swap(a.result_sink, b.result_sink);
  swap(a.split_sink, b.split_sink);
  swap(a.mysql_table_sink, b.mysql_table_sink);
  swap(a.export_sink, b.export_sink);
  swap(a.__isset, b.__isset);
}

TDataSink::TDataSink(const TDataSink& other67) {
  type = other67.type;
  stream_sink = other67.stream_sink;
  result_sink = other67.result_sink;
  split_sink = other67.split_sink;
  mysql_table_sink = other67.mysql_table_sink;
  export_sink = other67.export_sink;
  __isset = other67.__isset;
}
TDataSink& TDataSink::operator=(const TDataSink& other68) {
  type = other68.type;
  stream_sink = other68.stream_sink;
  result_sink = other68.result_sink;
  split_sink = other68.split_sink;
  mysql_table_sink = other68.mysql_table_sink;
  export_sink = other68.export_sink;
  __isset = other68.__isset;
  return *this;
}
void TDataSink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataSink(";
  out << "type=" << to_string(type);
  out << ", " << "stream_sink="; (__isset.stream_sink ? (out << to_string(stream_sink)) : (out << "<null>"));
  out << ", " << "result_sink="; (__isset.result_sink ? (out << to_string(result_sink)) : (out << "<null>"));
  out << ", " << "split_sink="; (__isset.split_sink ? (out << to_string(split_sink)) : (out << "<null>"));
  out << ", " << "mysql_table_sink="; (__isset.mysql_table_sink ? (out << to_string(mysql_table_sink)) : (out << "<null>"));
  out << ", " << "export_sink="; (__isset.export_sink ? (out << to_string(export_sink)) : (out << "<null>"));
  out << ")";
}

} // namespace
