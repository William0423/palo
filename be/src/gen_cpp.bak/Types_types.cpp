/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTStorageTypeValues[] = {
  TStorageType::ROW,
  TStorageType::COLUMN
};
const char* _kTStorageTypeNames[] = {
  "ROW",
  "COLUMN"
};
const std::map<int, const char*> _TStorageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTStorageTypeValues, _kTStorageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTStorageMediumValues[] = {
  TStorageMedium::HDD,
  TStorageMedium::SSD
};
const char* _kTStorageMediumNames[] = {
  "HDD",
  "SSD"
};
const std::map<int, const char*> _TStorageMedium_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTStorageMediumValues, _kTStorageMediumNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTVarTypeValues[] = {
  TVarType::SESSION,
  TVarType::GLOBAL
};
const char* _kTVarTypeNames[] = {
  "SESSION",
  "GLOBAL"
};
const std::map<int, const char*> _TVarType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTVarTypeValues, _kTVarTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPrimitiveTypeValues[] = {
  TPrimitiveType::INVALID_TYPE,
  TPrimitiveType::NULL_TYPE,
  TPrimitiveType::BOOLEAN,
  TPrimitiveType::TINYINT,
  TPrimitiveType::SMALLINT,
  TPrimitiveType::INT,
  TPrimitiveType::BIGINT,
  TPrimitiveType::FLOAT,
  TPrimitiveType::DOUBLE,
  TPrimitiveType::DATE,
  TPrimitiveType::DATETIME,
  TPrimitiveType::BINARY,
  TPrimitiveType::DECIMAL,
  TPrimitiveType::CHAR,
  TPrimitiveType::LARGEINT,
  TPrimitiveType::VARCHAR,
  TPrimitiveType::HLL
};
const char* _kTPrimitiveTypeNames[] = {
  "INVALID_TYPE",
  "NULL_TYPE",
  "BOOLEAN",
  "TINYINT",
  "SMALLINT",
  "INT",
  "BIGINT",
  "FLOAT",
  "DOUBLE",
  "DATE",
  "DATETIME",
  "BINARY",
  "DECIMAL",
  "CHAR",
  "LARGEINT",
  "VARCHAR",
  "HLL"
};
const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kTPrimitiveTypeValues, _kTPrimitiveTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTypeNodeTypeValues[] = {
  TTypeNodeType::SCALAR,
  TTypeNodeType::ARRAY,
  TTypeNodeType::MAP,
  TTypeNodeType::STRUCT
};
const char* _kTTypeNodeTypeNames[] = {
  "SCALAR",
  "ARRAY",
  "MAP",
  "STRUCT"
};
const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTTypeNodeTypeValues, _kTTypeNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAggregationTypeValues[] = {
  TAggregationType::SUM,
  TAggregationType::MAX,
  TAggregationType::MIN,
  TAggregationType::REPLACE,
  TAggregationType::HLL_UNION,
  TAggregationType::NONE
};
const char* _kTAggregationTypeNames[] = {
  "SUM",
  "MAX",
  "MIN",
  "REPLACE",
  "HLL_UNION",
  "NONE"
};
const std::map<int, const char*> _TAggregationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTAggregationTypeValues, _kTAggregationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPushTypeValues[] = {
  TPushType::LOAD,
  TPushType::DELETE,
  TPushType::LOAD_DELETE
};
const char* _kTPushTypeNames[] = {
  "LOAD",
  "DELETE",
  "LOAD_DELETE"
};
const std::map<int, const char*> _TPushType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTPushTypeValues, _kTPushTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTaskTypeValues[] = {
  TTaskType::CREATE,
  TTaskType::DROP,
  TTaskType::PUSH,
  TTaskType::CLONE,
  TTaskType::STORAGE_MEDIUM_MIGRATE,
  TTaskType::ROLLUP,
  TTaskType::SCHEMA_CHANGE,
  TTaskType::CANCEL_DELETE,
  TTaskType::MAKE_SNAPSHOT,
  TTaskType::RELEASE_SNAPSHOT,
  TTaskType::CHECK_CONSISTENCY,
  TTaskType::UPLOAD,
  TTaskType::RESTORE,
  TTaskType::CLEAR_REMOTE_FILE
};
const char* _kTTaskTypeNames[] = {
  "CREATE",
  "DROP",
  "PUSH",
  "CLONE",
  "STORAGE_MEDIUM_MIGRATE",
  "ROLLUP",
  "SCHEMA_CHANGE",
  "CANCEL_DELETE",
  "MAKE_SNAPSHOT",
  "RELEASE_SNAPSHOT",
  "CHECK_CONSISTENCY",
  "UPLOAD",
  "RESTORE",
  "CLEAR_REMOTE_FILE"
};
const std::map<int, const char*> _TTaskType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(14, _kTTaskTypeValues, _kTTaskTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTStmtTypeValues[] = {
  TStmtType::QUERY,
  TStmtType::DDL,
  TStmtType::DML,
  TStmtType::EXPLAIN
};
const char* _kTStmtTypeNames[] = {
  "QUERY",
  "DDL",
  "DML",
  "EXPLAIN"
};
const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTStmtTypeValues, _kTStmtTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExplainLevelValues[] = {
  TExplainLevel::NORMAL,
  TExplainLevel::VERBOSE
};
const char* _kTExplainLevelNames[] = {
  "NORMAL",
  "VERBOSE"
};
const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTExplainLevelValues, _kTExplainLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kQueryStateValues[] = {
  QueryState::CREATED,
  QueryState::INITIALIZED,
  QueryState::COMPILED,
  QueryState::RUNNING,
  QueryState::FINISHED,
  QueryState::EXCEPTION
};
const char* _kQueryStateNames[] = {
  "CREATED",
  "INITIALIZED",
  "COMPILED",
  "RUNNING",
  "FINISHED",
  "EXCEPTION"
};
const std::map<int, const char*> _QueryState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kQueryStateValues, _kQueryStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFunctionTypeValues[] = {
  TFunctionType::SCALAR,
  TFunctionType::AGGREGATE
};
const char* _kTFunctionTypeNames[] = {
  "SCALAR",
  "AGGREGATE"
};
const std::map<int, const char*> _TFunctionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTFunctionTypeValues, _kTFunctionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFunctionBinaryTypeValues[] = {
  TFunctionBinaryType::BUILTIN,
  TFunctionBinaryType::HIVE,
  TFunctionBinaryType::NATIVE,
  TFunctionBinaryType::IR
};
const char* _kTFunctionBinaryTypeNames[] = {
  "BUILTIN",
  "HIVE",
  "NATIVE",
  "IR"
};
const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTFunctionBinaryTypeValues, _kTFunctionBinaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTLoadJobStateValues[] = {
  TLoadJobState::PENDING,
  TLoadJobState::ETL,
  TLoadJobState::LOADING,
  TLoadJobState::FINISHED,
  TLoadJobState::CANCELLED
};
const char* _kTLoadJobStateNames[] = {
  "PENDING",
  "ETL",
  "LOADING",
  "FINISHED",
  "CANCELLED"
};
const std::map<int, const char*> _TLoadJobState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTLoadJobStateValues, _kTLoadJobStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTEtlStateValues[] = {
  TEtlState::RUNNING,
  TEtlState::FINISHED,
  TEtlState::CANCELLED,
  TEtlState::UNKNOWN
};
const char* _kTEtlStateNames[] = {
  "RUNNING",
  "FINISHED",
  "CANCELLED",
  "UNKNOWN"
};
const std::map<int, const char*> _TEtlState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTEtlStateValues, _kTEtlStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTableTypeValues[] = {
  TTableType::MYSQL_TABLE,
  TTableType::OLAP_TABLE,
  TTableType::SCHEMA_TABLE,
  TTableType::KUDU_TABLE,
  TTableType::BROKER_TABLE
};
const char* _kTTableTypeNames[] = {
  "MYSQL_TABLE",
  "OLAP_TABLE",
  "SCHEMA_TABLE",
  "KUDU_TABLE",
  "BROKER_TABLE"
};
const std::map<int, const char*> _TTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTTableTypeValues, _kTTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTKeysTypeValues[] = {
  TKeysType::PRIMARY_KEYS,
  TKeysType::DUP_KEYS,
  TKeysType::UNIQUE_KEYS,
  TKeysType::AGG_KEYS
};
const char* _kTKeysTypeNames[] = {
  "PRIMARY_KEYS",
  "DUP_KEYS",
  "UNIQUE_KEYS",
  "AGG_KEYS"
};
const std::map<int, const char*> _TKeysType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTKeysTypeValues, _kTKeysTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPriorityValues[] = {
  TPriority::NORMAL,
  TPriority::HIGH
};
const char* _kTPriorityNames[] = {
  "NORMAL",
  "HIGH"
};
const std::map<int, const char*> _TPriority_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTPriorityValues, _kTPriorityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExportStateValues[] = {
  TExportState::RUNNING,
  TExportState::FINISHED,
  TExportState::CANCELLED,
  TExportState::UNKNOWN
};
const char* _kTExportStateNames[] = {
  "RUNNING",
  "FINISHED",
  "CANCELLED",
  "UNKNOWN"
};
const std::map<int, const char*> _TExportState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExportStateValues, _kTExportStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFileTypeValues[] = {
  TFileType::FILE_LOCAL,
  TFileType::FILE_BROKER
};
const char* _kTFileTypeNames[] = {
  "FILE_LOCAL",
  "FILE_BROKER"
};
const std::map<int, const char*> _TFileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTFileTypeValues, _kTFileTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TScalarType::~TScalarType() throw() {
}


void TScalarType::__set_type(const TPrimitiveType::type val) {
  this->type = val;
}

void TScalarType::__set_len(const int32_t val) {
  this->len = val;
__isset.len = true;
}

void TScalarType::__set_precision(const int32_t val) {
  this->precision = val;
__isset.precision = true;
}

void TScalarType::__set_scale(const int32_t val) {
  this->scale = val;
__isset.scale = true;
}

uint32_t TScalarType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (TPrimitiveType::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScalarType");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.len) {
    xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.precision) {
    xfer += oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->precision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scale) {
    xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->scale);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarType &a, TScalarType &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.len, b.len);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.__isset, b.__isset);
}

TScalarType::TScalarType(const TScalarType& other1) {
  type = other1.type;
  len = other1.len;
  precision = other1.precision;
  scale = other1.scale;
  __isset = other1.__isset;
}
TScalarType& TScalarType::operator=(const TScalarType& other2) {
  type = other2.type;
  len = other2.len;
  precision = other2.precision;
  scale = other2.scale;
  __isset = other2.__isset;
  return *this;
}
void TScalarType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScalarType(";
  out << "type=" << to_string(type);
  out << ", " << "len="; (__isset.len ? (out << to_string(len)) : (out << "<null>"));
  out << ", " << "precision="; (__isset.precision ? (out << to_string(precision)) : (out << "<null>"));
  out << ", " << "scale="; (__isset.scale ? (out << to_string(scale)) : (out << "<null>"));
  out << ")";
}


TStructField::~TStructField() throw() {
}


void TStructField::__set_name(const std::string& val) {
  this->name = val;
}

void TStructField::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

uint32_t TStructField::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStructField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStructField");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStructField &a, TStructField &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

TStructField::TStructField(const TStructField& other3) {
  name = other3.name;
  comment = other3.comment;
  __isset = other3.__isset;
}
TStructField& TStructField::operator=(const TStructField& other4) {
  name = other4.name;
  comment = other4.comment;
  __isset = other4.__isset;
  return *this;
}
void TStructField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStructField(";
  out << "name=" << to_string(name);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


TTypeNode::~TTypeNode() throw() {
}


void TTypeNode::__set_type(const TTypeNodeType::type val) {
  this->type = val;
}

void TTypeNode::__set_scalar_type(const TScalarType& val) {
  this->scalar_type = val;
__isset.scalar_type = true;
}

void TTypeNode::__set_struct_fields(const std::vector<TStructField> & val) {
  this->struct_fields = val;
__isset.struct_fields = true;
}

uint32_t TTypeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->type = (TTypeNodeType::type)ecast5;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_type.read(iprot);
          this->__isset.scalar_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->struct_fields.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->struct_fields.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->struct_fields[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.struct_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeNode");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.scalar_type) {
    xfer += oprot->writeFieldBegin("scalar_type", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->scalar_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_fields) {
    xfer += oprot->writeFieldBegin("struct_fields", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_fields.size()));
      std::vector<TStructField> ::const_iterator _iter11;
      for (_iter11 = this->struct_fields.begin(); _iter11 != this->struct_fields.end(); ++_iter11)
      {
        xfer += (*_iter11).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeNode &a, TTypeNode &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.scalar_type, b.scalar_type);
  swap(a.struct_fields, b.struct_fields);
  swap(a.__isset, b.__isset);
}

TTypeNode::TTypeNode(const TTypeNode& other12) {
  type = other12.type;
  scalar_type = other12.scalar_type;
  struct_fields = other12.struct_fields;
  __isset = other12.__isset;
}
TTypeNode& TTypeNode::operator=(const TTypeNode& other13) {
  type = other13.type;
  scalar_type = other13.scalar_type;
  struct_fields = other13.struct_fields;
  __isset = other13.__isset;
  return *this;
}
void TTypeNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeNode(";
  out << "type=" << to_string(type);
  out << ", " << "scalar_type="; (__isset.scalar_type ? (out << to_string(scalar_type)) : (out << "<null>"));
  out << ", " << "struct_fields="; (__isset.struct_fields ? (out << to_string(struct_fields)) : (out << "<null>"));
  out << ")";
}


TTypeDesc::~TTypeDesc() throw() {
}


void TTypeDesc::__set_types(const std::vector<TTypeNode> & val) {
  this->types = val;
}

uint32_t TTypeDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->types.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->types[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeDesc");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<TTypeNode> ::const_iterator _iter19;
    for (_iter19 = this->types.begin(); _iter19 != this->types.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeDesc &a, TTypeDesc &b) {
  using ::std::swap;
  swap(a.types, b.types);
  swap(a.__isset, b.__isset);
}

TTypeDesc::TTypeDesc(const TTypeDesc& other20) {
  types = other20.types;
  __isset = other20.__isset;
}
TTypeDesc& TTypeDesc::operator=(const TTypeDesc& other21) {
  types = other21.types;
  __isset = other21.__isset;
  return *this;
}
void TTypeDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeDesc(";
  out << "types=" << to_string(types);
  out << ")";
}


TColumnType::~TColumnType() throw() {
}


void TColumnType::__set_type(const TPrimitiveType::type val) {
  this->type = val;
}

void TColumnType::__set_len(const int32_t val) {
  this->len = val;
__isset.len = true;
}

void TColumnType::__set_index_len(const int32_t val) {
  this->index_len = val;
__isset.index_len = true;
}

void TColumnType::__set_precision(const int32_t val) {
  this->precision = val;
__isset.precision = true;
}

void TColumnType::__set_scale(const int32_t val) {
  this->scale = val;
__isset.scale = true;
}

uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->type = (TPrimitiveType::type)ecast22;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index_len);
          this->__isset.index_len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.len) {
    xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_len) {
    xfer += oprot->writeFieldBegin("index_len", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->index_len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.precision) {
    xfer += oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->precision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scale) {
    xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->scale);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.len, b.len);
  swap(a.index_len, b.index_len);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other23) {
  type = other23.type;
  len = other23.len;
  index_len = other23.index_len;
  precision = other23.precision;
  scale = other23.scale;
  __isset = other23.__isset;
}
TColumnType& TColumnType::operator=(const TColumnType& other24) {
  type = other24.type;
  len = other24.len;
  index_len = other24.index_len;
  precision = other24.precision;
  scale = other24.scale;
  __isset = other24.__isset;
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "type=" << to_string(type);
  out << ", " << "len="; (__isset.len ? (out << to_string(len)) : (out << "<null>"));
  out << ", " << "index_len="; (__isset.index_len ? (out << to_string(index_len)) : (out << "<null>"));
  out << ", " << "precision="; (__isset.precision ? (out << to_string(precision)) : (out << "<null>"));
  out << ", " << "scale="; (__isset.scale ? (out << to_string(scale)) : (out << "<null>"));
  out << ")";
}


TNetworkAddress::~TNetworkAddress() throw() {
}


void TNetworkAddress::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TNetworkAddress::__set_port(const int32_t val) {
  this->port = val;
}

uint32_t TNetworkAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostname = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TNetworkAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNetworkAddress");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNetworkAddress &a, TNetworkAddress &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.port, b.port);
}

TNetworkAddress::TNetworkAddress(const TNetworkAddress& other25) {
  hostname = other25.hostname;
  port = other25.port;
}
TNetworkAddress& TNetworkAddress::operator=(const TNetworkAddress& other26) {
  hostname = other26.hostname;
  port = other26.port;
  return *this;
}
void TNetworkAddress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNetworkAddress(";
  out << "hostname=" << to_string(hostname);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


TUniqueId::~TUniqueId() throw() {
}


void TUniqueId::__set_hi(const int64_t val) {
  this->hi = val;
}

void TUniqueId::__set_lo(const int64_t val) {
  this->lo = val;
}

uint32_t TUniqueId::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hi = false;
  bool isset_lo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hi);
          isset_hi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lo);
          isset_lo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hi)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUniqueId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUniqueId");

  xfer += oprot->writeFieldBegin("hi", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->hi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniqueId &a, TUniqueId &b) {
  using ::std::swap;
  swap(a.hi, b.hi);
  swap(a.lo, b.lo);
}

TUniqueId::TUniqueId(const TUniqueId& other27) {
  hi = other27.hi;
  lo = other27.lo;
}
TUniqueId& TUniqueId::operator=(const TUniqueId& other28) {
  hi = other28.hi;
  lo = other28.lo;
  return *this;
}
void TUniqueId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUniqueId(";
  out << "hi=" << to_string(hi);
  out << ", " << "lo=" << to_string(lo);
  out << ")";
}


TFunctionName::~TFunctionName() throw() {
}


void TFunctionName::__set_db_name(const std::string& val) {
  this->db_name = val;
__isset.db_name = true;
}

void TFunctionName::__set_function_name(const std::string& val) {
  this->function_name = val;
}

uint32_t TFunctionName::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_function_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunctionName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFunctionName");

  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunctionName &a, TFunctionName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.function_name, b.function_name);
  swap(a.__isset, b.__isset);
}

TFunctionName::TFunctionName(const TFunctionName& other29) {
  db_name = other29.db_name;
  function_name = other29.function_name;
  __isset = other29.__isset;
}
TFunctionName& TFunctionName::operator=(const TFunctionName& other30) {
  db_name = other30.db_name;
  function_name = other30.function_name;
  __isset = other30.__isset;
  return *this;
}
void TFunctionName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFunctionName(";
  out << "db_name="; (__isset.db_name ? (out << to_string(db_name)) : (out << "<null>"));
  out << ", " << "function_name=" << to_string(function_name);
  out << ")";
}


TScalarFunction::~TScalarFunction() throw() {
}


void TScalarFunction::__set_symbol(const std::string& val) {
  this->symbol = val;
}

void TScalarFunction::__set_prepare_fn_symbol(const std::string& val) {
  this->prepare_fn_symbol = val;
__isset.prepare_fn_symbol = true;
}

void TScalarFunction::__set_close_fn_symbol(const std::string& val) {
  this->close_fn_symbol = val;
__isset.close_fn_symbol = true;
}

uint32_t TScalarFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_symbol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->symbol);
          isset_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prepare_fn_symbol);
          this->__isset.prepare_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->close_fn_symbol);
          this->__isset.close_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScalarFunction");

  xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->symbol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.prepare_fn_symbol) {
    xfer += oprot->writeFieldBegin("prepare_fn_symbol", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->prepare_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.close_fn_symbol) {
    xfer += oprot->writeFieldBegin("close_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->close_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarFunction &a, TScalarFunction &b) {
  using ::std::swap;
  swap(a.symbol, b.symbol);
  swap(a.prepare_fn_symbol, b.prepare_fn_symbol);
  swap(a.close_fn_symbol, b.close_fn_symbol);
  swap(a.__isset, b.__isset);
}

TScalarFunction::TScalarFunction(const TScalarFunction& other31) {
  symbol = other31.symbol;
  prepare_fn_symbol = other31.prepare_fn_symbol;
  close_fn_symbol = other31.close_fn_symbol;
  __isset = other31.__isset;
}
TScalarFunction& TScalarFunction::operator=(const TScalarFunction& other32) {
  symbol = other32.symbol;
  prepare_fn_symbol = other32.prepare_fn_symbol;
  close_fn_symbol = other32.close_fn_symbol;
  __isset = other32.__isset;
  return *this;
}
void TScalarFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScalarFunction(";
  out << "symbol=" << to_string(symbol);
  out << ", " << "prepare_fn_symbol="; (__isset.prepare_fn_symbol ? (out << to_string(prepare_fn_symbol)) : (out << "<null>"));
  out << ", " << "close_fn_symbol="; (__isset.close_fn_symbol ? (out << to_string(close_fn_symbol)) : (out << "<null>"));
  out << ")";
}


TAggregateFunction::~TAggregateFunction() throw() {
}


void TAggregateFunction::__set_intermediate_type(const TTypeDesc& val) {
  this->intermediate_type = val;
}

void TAggregateFunction::__set_update_fn_symbol(const std::string& val) {
  this->update_fn_symbol = val;
__isset.update_fn_symbol = true;
}

void TAggregateFunction::__set_init_fn_symbol(const std::string& val) {
  this->init_fn_symbol = val;
__isset.init_fn_symbol = true;
}

void TAggregateFunction::__set_serialize_fn_symbol(const std::string& val) {
  this->serialize_fn_symbol = val;
__isset.serialize_fn_symbol = true;
}

void TAggregateFunction::__set_merge_fn_symbol(const std::string& val) {
  this->merge_fn_symbol = val;
__isset.merge_fn_symbol = true;
}

void TAggregateFunction::__set_finalize_fn_symbol(const std::string& val) {
  this->finalize_fn_symbol = val;
__isset.finalize_fn_symbol = true;
}

void TAggregateFunction::__set_get_value_fn_symbol(const std::string& val) {
  this->get_value_fn_symbol = val;
__isset.get_value_fn_symbol = true;
}

void TAggregateFunction::__set_remove_fn_symbol(const std::string& val) {
  this->remove_fn_symbol = val;
__isset.remove_fn_symbol = true;
}

uint32_t TAggregateFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_intermediate_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->intermediate_type.read(iprot);
          isset_intermediate_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_fn_symbol);
          this->__isset.update_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->init_fn_symbol);
          this->__isset.init_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serialize_fn_symbol);
          this->__isset.serialize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->merge_fn_symbol);
          this->__isset.merge_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finalize_fn_symbol);
          this->__isset.finalize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->get_value_fn_symbol);
          this->__isset.get_value_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remove_fn_symbol);
          this->__isset.remove_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_intermediate_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregateFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAggregateFunction");

  xfer += oprot->writeFieldBegin("intermediate_type", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->intermediate_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.update_fn_symbol) {
    xfer += oprot->writeFieldBegin("update_fn_symbol", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->update_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.init_fn_symbol) {
    xfer += oprot->writeFieldBegin("init_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->init_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serialize_fn_symbol) {
    xfer += oprot->writeFieldBegin("serialize_fn_symbol", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->serialize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_fn_symbol) {
    xfer += oprot->writeFieldBegin("merge_fn_symbol", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->merge_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finalize_fn_symbol) {
    xfer += oprot->writeFieldBegin("finalize_fn_symbol", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->finalize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_value_fn_symbol) {
    xfer += oprot->writeFieldBegin("get_value_fn_symbol", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->get_value_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remove_fn_symbol) {
    xfer += oprot->writeFieldBegin("remove_fn_symbol", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->remove_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregateFunction &a, TAggregateFunction &b) {
  using ::std::swap;
  swap(a.intermediate_type, b.intermediate_type);
  swap(a.update_fn_symbol, b.update_fn_symbol);
  swap(a.init_fn_symbol, b.init_fn_symbol);
  swap(a.serialize_fn_symbol, b.serialize_fn_symbol);
  swap(a.merge_fn_symbol, b.merge_fn_symbol);
  swap(a.finalize_fn_symbol, b.finalize_fn_symbol);
  swap(a.get_value_fn_symbol, b.get_value_fn_symbol);
  swap(a.remove_fn_symbol, b.remove_fn_symbol);
  swap(a.__isset, b.__isset);
}

TAggregateFunction::TAggregateFunction(const TAggregateFunction& other33) {
  intermediate_type = other33.intermediate_type;
  update_fn_symbol = other33.update_fn_symbol;
  init_fn_symbol = other33.init_fn_symbol;
  serialize_fn_symbol = other33.serialize_fn_symbol;
  merge_fn_symbol = other33.merge_fn_symbol;
  finalize_fn_symbol = other33.finalize_fn_symbol;
  get_value_fn_symbol = other33.get_value_fn_symbol;
  remove_fn_symbol = other33.remove_fn_symbol;
  __isset = other33.__isset;
}
TAggregateFunction& TAggregateFunction::operator=(const TAggregateFunction& other34) {
  intermediate_type = other34.intermediate_type;
  update_fn_symbol = other34.update_fn_symbol;
  init_fn_symbol = other34.init_fn_symbol;
  serialize_fn_symbol = other34.serialize_fn_symbol;
  merge_fn_symbol = other34.merge_fn_symbol;
  finalize_fn_symbol = other34.finalize_fn_symbol;
  get_value_fn_symbol = other34.get_value_fn_symbol;
  remove_fn_symbol = other34.remove_fn_symbol;
  __isset = other34.__isset;
  return *this;
}
void TAggregateFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregateFunction(";
  out << "intermediate_type=" << to_string(intermediate_type);
  out << ", " << "update_fn_symbol="; (__isset.update_fn_symbol ? (out << to_string(update_fn_symbol)) : (out << "<null>"));
  out << ", " << "init_fn_symbol="; (__isset.init_fn_symbol ? (out << to_string(init_fn_symbol)) : (out << "<null>"));
  out << ", " << "serialize_fn_symbol="; (__isset.serialize_fn_symbol ? (out << to_string(serialize_fn_symbol)) : (out << "<null>"));
  out << ", " << "merge_fn_symbol="; (__isset.merge_fn_symbol ? (out << to_string(merge_fn_symbol)) : (out << "<null>"));
  out << ", " << "finalize_fn_symbol="; (__isset.finalize_fn_symbol ? (out << to_string(finalize_fn_symbol)) : (out << "<null>"));
  out << ", " << "get_value_fn_symbol="; (__isset.get_value_fn_symbol ? (out << to_string(get_value_fn_symbol)) : (out << "<null>"));
  out << ", " << "remove_fn_symbol="; (__isset.remove_fn_symbol ? (out << to_string(remove_fn_symbol)) : (out << "<null>"));
  out << ")";
}


TFunction::~TFunction() throw() {
}


void TFunction::__set_name(const TFunctionName& val) {
  this->name = val;
}

void TFunction::__set_binary_type(const TFunctionBinaryType::type val) {
  this->binary_type = val;
}

void TFunction::__set_arg_types(const std::vector<TTypeDesc> & val) {
  this->arg_types = val;
}

void TFunction::__set_ret_type(const TTypeDesc& val) {
  this->ret_type = val;
}

void TFunction::__set_has_var_args(const bool val) {
  this->has_var_args = val;
}

void TFunction::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void TFunction::__set_signature(const std::string& val) {
  this->signature = val;
__isset.signature = true;
}

void TFunction::__set_hdfs_location(const std::string& val) {
  this->hdfs_location = val;
__isset.hdfs_location = true;
}

void TFunction::__set_scalar_fn(const TScalarFunction& val) {
  this->scalar_fn = val;
__isset.scalar_fn = true;
}

void TFunction::__set_aggregate_fn(const TAggregateFunction& val) {
  this->aggregate_fn = val;
__isset.aggregate_fn = true;
}

void TFunction::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

uint32_t TFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_binary_type = false;
  bool isset_arg_types = false;
  bool isset_ret_type = false;
  bool isset_has_var_args = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->name.read(iprot);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast35;
          xfer += iprot->readI32(ecast35);
          this->binary_type = (TFunctionBinaryType::type)ecast35;
          isset_binary_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arg_types.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->arg_types.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->arg_types[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_arg_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ret_type.read(iprot);
          isset_ret_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_var_args);
          isset_has_var_args = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_location);
          this->__isset.hdfs_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_fn.read(iprot);
          this->__isset.scalar_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aggregate_fn.read(iprot);
          this->__isset.aggregate_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_binary_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_arg_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ret_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_var_args)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFunction");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->binary_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg_types", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arg_types.size()));
    std::vector<TTypeDesc> ::const_iterator _iter41;
    for (_iter41 = this->arg_types.begin(); _iter41 != this->arg_types.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ret_type", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->ret_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_var_args", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->has_var_args);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_location) {
    xfer += oprot->writeFieldBegin("hdfs_location", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->hdfs_location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scalar_fn) {
    xfer += oprot->writeFieldBegin("scalar_fn", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->scalar_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggregate_fn) {
    xfer += oprot->writeFieldBegin("aggregate_fn", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->aggregate_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunction &a, TFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.binary_type, b.binary_type);
  swap(a.arg_types, b.arg_types);
  swap(a.ret_type, b.ret_type);
  swap(a.has_var_args, b.has_var_args);
  swap(a.comment, b.comment);
  swap(a.signature, b.signature);
  swap(a.hdfs_location, b.hdfs_location);
  swap(a.scalar_fn, b.scalar_fn);
  swap(a.aggregate_fn, b.aggregate_fn);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TFunction::TFunction(const TFunction& other42) {
  name = other42.name;
  binary_type = other42.binary_type;
  arg_types = other42.arg_types;
  ret_type = other42.ret_type;
  has_var_args = other42.has_var_args;
  comment = other42.comment;
  signature = other42.signature;
  hdfs_location = other42.hdfs_location;
  scalar_fn = other42.scalar_fn;
  aggregate_fn = other42.aggregate_fn;
  id = other42.id;
  __isset = other42.__isset;
}
TFunction& TFunction::operator=(const TFunction& other43) {
  name = other43.name;
  binary_type = other43.binary_type;
  arg_types = other43.arg_types;
  ret_type = other43.ret_type;
  has_var_args = other43.has_var_args;
  comment = other43.comment;
  signature = other43.signature;
  hdfs_location = other43.hdfs_location;
  scalar_fn = other43.scalar_fn;
  aggregate_fn = other43.aggregate_fn;
  id = other43.id;
  __isset = other43.__isset;
  return *this;
}
void TFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFunction(";
  out << "name=" << to_string(name);
  out << ", " << "binary_type=" << to_string(binary_type);
  out << ", " << "arg_types=" << to_string(arg_types);
  out << ", " << "ret_type=" << to_string(ret_type);
  out << ", " << "has_var_args=" << to_string(has_var_args);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "hdfs_location="; (__isset.hdfs_location ? (out << to_string(hdfs_location)) : (out << "<null>"));
  out << ", " << "scalar_fn="; (__isset.scalar_fn ? (out << to_string(scalar_fn)) : (out << "<null>"));
  out << ", " << "aggregate_fn="; (__isset.aggregate_fn ? (out << to_string(aggregate_fn)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


TBackend::~TBackend() throw() {
}


void TBackend::__set_host(const std::string& val) {
  this->host = val;
}

void TBackend::__set_be_port(const TPort val) {
  this->be_port = val;
}

void TBackend::__set_http_port(const TPort val) {
  this->http_port = val;
}

uint32_t TBackend::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_be_port = false;
  bool isset_http_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->be_port);
          isset_be_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->http_port);
          isset_http_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_be_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_http_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBackend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBackend");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("be_port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->be_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("http_port", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->http_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBackend &a, TBackend &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.be_port, b.be_port);
  swap(a.http_port, b.http_port);
}

TBackend::TBackend(const TBackend& other44) {
  host = other44.host;
  be_port = other44.be_port;
  http_port = other44.http_port;
}
TBackend& TBackend::operator=(const TBackend& other45) {
  host = other45.host;
  be_port = other45.be_port;
  http_port = other45.http_port;
  return *this;
}
void TBackend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBackend(";
  out << "host=" << to_string(host);
  out << ", " << "be_port=" << to_string(be_port);
  out << ", " << "http_port=" << to_string(http_port);
  out << ")";
}


TResourceInfo::~TResourceInfo() throw() {
}


void TResourceInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TResourceInfo::__set_group(const std::string& val) {
  this->group = val;
}

uint32_t TResourceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;
  bool isset_group = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          isset_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_group)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResourceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResourceInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->group);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResourceInfo &a, TResourceInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.group, b.group);
}

TResourceInfo::TResourceInfo(const TResourceInfo& other46) {
  user = other46.user;
  group = other46.group;
}
TResourceInfo& TResourceInfo::operator=(const TResourceInfo& other47) {
  user = other47.user;
  group = other47.group;
  return *this;
}
void TResourceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResourceInfo(";
  out << "user=" << to_string(user);
  out << ", " << "group=" << to_string(group);
  out << ")";
}

} // namespace
