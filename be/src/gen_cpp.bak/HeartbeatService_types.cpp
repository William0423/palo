/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "HeartbeatService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {


TMasterInfo::~TMasterInfo() throw() {
}


void TMasterInfo::__set_network_address(const  ::palo::TNetworkAddress& val) {
  this->network_address = val;
}

void TMasterInfo::__set_cluster_id(const  ::palo::TClusterId val) {
  this->cluster_id = val;
}

void TMasterInfo::__set_epoch(const  ::palo::TEpoch val) {
  this->epoch = val;
}

void TMasterInfo::__set_token(const std::string& val) {
  this->token = val;
__isset.token = true;
}

uint32_t TMasterInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_network_address = false;
  bool isset_cluster_id = false;
  bool isset_epoch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->network_address.read(iprot);
          isset_network_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cluster_id);
          isset_cluster_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->epoch);
          isset_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_network_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cluster_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_epoch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMasterInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMasterInfo");

  xfer += oprot->writeFieldBegin("network_address", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->network_address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->cluster_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("epoch", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->epoch);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.token) {
    xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->token);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMasterInfo &a, TMasterInfo &b) {
  using ::std::swap;
  swap(a.network_address, b.network_address);
  swap(a.cluster_id, b.cluster_id);
  swap(a.epoch, b.epoch);
  swap(a.token, b.token);
  swap(a.__isset, b.__isset);
}

TMasterInfo::TMasterInfo(const TMasterInfo& other0) {
  network_address = other0.network_address;
  cluster_id = other0.cluster_id;
  epoch = other0.epoch;
  token = other0.token;
  __isset = other0.__isset;
}
TMasterInfo& TMasterInfo::operator=(const TMasterInfo& other1) {
  network_address = other1.network_address;
  cluster_id = other1.cluster_id;
  epoch = other1.epoch;
  token = other1.token;
  __isset = other1.__isset;
  return *this;
}
void TMasterInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMasterInfo(";
  out << "network_address=" << to_string(network_address);
  out << ", " << "cluster_id=" << to_string(cluster_id);
  out << ", " << "epoch=" << to_string(epoch);
  out << ", " << "token="; (__isset.token ? (out << to_string(token)) : (out << "<null>"));
  out << ")";
}


TBackendInfo::~TBackendInfo() throw() {
}


void TBackendInfo::__set_be_port(const  ::palo::TPort val) {
  this->be_port = val;
}

void TBackendInfo::__set_http_port(const  ::palo::TPort val) {
  this->http_port = val;
}

void TBackendInfo::__set_be_rpc_port(const  ::palo::TPort val) {
  this->be_rpc_port = val;
__isset.be_rpc_port = true;
}

uint32_t TBackendInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_be_port = false;
  bool isset_http_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->be_port);
          isset_be_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->http_port);
          isset_http_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->be_rpc_port);
          this->__isset.be_rpc_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_be_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_http_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBackendInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBackendInfo");

  xfer += oprot->writeFieldBegin("be_port", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->be_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("http_port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->http_port);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.be_rpc_port) {
    xfer += oprot->writeFieldBegin("be_rpc_port", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->be_rpc_port);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBackendInfo &a, TBackendInfo &b) {
  using ::std::swap;
  swap(a.be_port, b.be_port);
  swap(a.http_port, b.http_port);
  swap(a.be_rpc_port, b.be_rpc_port);
  swap(a.__isset, b.__isset);
}

TBackendInfo::TBackendInfo(const TBackendInfo& other2) {
  be_port = other2.be_port;
  http_port = other2.http_port;
  be_rpc_port = other2.be_rpc_port;
  __isset = other2.__isset;
}
TBackendInfo& TBackendInfo::operator=(const TBackendInfo& other3) {
  be_port = other3.be_port;
  http_port = other3.http_port;
  be_rpc_port = other3.be_rpc_port;
  __isset = other3.__isset;
  return *this;
}
void TBackendInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBackendInfo(";
  out << "be_port=" << to_string(be_port);
  out << ", " << "http_port=" << to_string(http_port);
  out << ", " << "be_rpc_port="; (__isset.be_rpc_port ? (out << to_string(be_rpc_port)) : (out << "<null>"));
  out << ")";
}


THeartbeatResult::~THeartbeatResult() throw() {
}


void THeartbeatResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
}

void THeartbeatResult::__set_backend_info(const TBackendInfo& val) {
  this->backend_info = val;
}

uint32_t THeartbeatResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_backend_info = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->backend_info.read(iprot);
          isset_backend_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_backend_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THeartbeatResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THeartbeatResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backend_info", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->backend_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THeartbeatResult &a, THeartbeatResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.backend_info, b.backend_info);
}

THeartbeatResult::THeartbeatResult(const THeartbeatResult& other4) {
  status = other4.status;
  backend_info = other4.backend_info;
}
THeartbeatResult& THeartbeatResult::operator=(const THeartbeatResult& other5) {
  status = other5.status;
  backend_info = other5.backend_info;
  return *this;
}
void THeartbeatResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THeartbeatResult(";
  out << "status=" << to_string(status);
  out << ", " << "backend_info=" << to_string(backend_info);
  out << ")";
}

} // namespace
