/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Exprs_TYPES_H
#define Exprs_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Types_types.h"
#include "Opcodes_types.h"


namespace palo {

struct TExprNodeType {
  enum type {
    AGG_EXPR = 0,
    ARITHMETIC_EXPR = 1,
    BINARY_PRED = 2,
    BOOL_LITERAL = 3,
    CASE_EXPR = 4,
    CAST_EXPR = 5,
    COMPOUND_PRED = 6,
    DATE_LITERAL = 7,
    FLOAT_LITERAL = 8,
    INT_LITERAL = 9,
    DECIMAL_LITERAL = 10,
    IN_PRED = 11,
    IS_NULL_PRED = 12,
    LIKE_PRED = 13,
    LITERAL_PRED = 14,
    NULL_LITERAL = 15,
    SLOT_REF = 16,
    STRING_LITERAL = 17,
    TUPLE_IS_NULL_PRED = 18,
    INFO_FUNC = 19,
    FUNCTION_CALL = 20,
    COMPUTE_FUNCTION_CALL = 21,
    LARGE_INT_LITERAL = 22
  };
};

extern const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES;

class TAggregateExpr;

class TBoolLiteral;

class TCaseExpr;

class TDateLiteral;

class TFloatLiteral;

class TDecimalLiteral;

class TIntLiteral;

class TLargeIntLiteral;

class TInPredicate;

class TIsNullPredicate;

class TLikePredicate;

class TLiteralPredicate;

class TTupleIsNullPredicate;

class TSlotRef;

class TStringLiteral;

class TInfoFunc;

class TFunctionCallExpr;

class TExprNode;

class TExpr;


class TAggregateExpr {
 public:

  TAggregateExpr(const TAggregateExpr&);
  TAggregateExpr& operator=(const TAggregateExpr&);
  TAggregateExpr() : is_merge_agg(0) {
  }

  virtual ~TAggregateExpr() throw();
  bool is_merge_agg;

  void __set_is_merge_agg(const bool val);

  bool operator == (const TAggregateExpr & rhs) const
  {
    if (!(is_merge_agg == rhs.is_merge_agg))
      return false;
    return true;
  }
  bool operator != (const TAggregateExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregateExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggregateExpr &a, TAggregateExpr &b);

inline std::ostream& operator<<(std::ostream& out, const TAggregateExpr& obj)
{
  obj.printTo(out);
  return out;
}


class TBoolLiteral {
 public:

  TBoolLiteral(const TBoolLiteral&);
  TBoolLiteral& operator=(const TBoolLiteral&);
  TBoolLiteral() : value(0) {
  }

  virtual ~TBoolLiteral() throw();
  bool value;

  void __set_value(const bool val);

  bool operator == (const TBoolLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBoolLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBoolLiteral &a, TBoolLiteral &b);

inline std::ostream& operator<<(std::ostream& out, const TBoolLiteral& obj)
{
  obj.printTo(out);
  return out;
}


class TCaseExpr {
 public:

  TCaseExpr(const TCaseExpr&);
  TCaseExpr& operator=(const TCaseExpr&);
  TCaseExpr() : has_case_expr(0), has_else_expr(0) {
  }

  virtual ~TCaseExpr() throw();
  bool has_case_expr;
  bool has_else_expr;

  void __set_has_case_expr(const bool val);

  void __set_has_else_expr(const bool val);

  bool operator == (const TCaseExpr & rhs) const
  {
    if (!(has_case_expr == rhs.has_case_expr))
      return false;
    if (!(has_else_expr == rhs.has_else_expr))
      return false;
    return true;
  }
  bool operator != (const TCaseExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCaseExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCaseExpr &a, TCaseExpr &b);

inline std::ostream& operator<<(std::ostream& out, const TCaseExpr& obj)
{
  obj.printTo(out);
  return out;
}


class TDateLiteral {
 public:

  TDateLiteral(const TDateLiteral&);
  TDateLiteral& operator=(const TDateLiteral&);
  TDateLiteral() : value() {
  }

  virtual ~TDateLiteral() throw();
  std::string value;

  void __set_value(const std::string& val);

  bool operator == (const TDateLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDateLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDateLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDateLiteral &a, TDateLiteral &b);

inline std::ostream& operator<<(std::ostream& out, const TDateLiteral& obj)
{
  obj.printTo(out);
  return out;
}


class TFloatLiteral {
 public:

  TFloatLiteral(const TFloatLiteral&);
  TFloatLiteral& operator=(const TFloatLiteral&);
  TFloatLiteral() : value(0) {
  }

  virtual ~TFloatLiteral() throw();
  double value;

  void __set_value(const double val);

  bool operator == (const TFloatLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TFloatLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFloatLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFloatLiteral &a, TFloatLiteral &b);

inline std::ostream& operator<<(std::ostream& out, const TFloatLiteral& obj)
{
  obj.printTo(out);
  return out;
}


class TDecimalLiteral {
 public:

  TDecimalLiteral(const TDecimalLiteral&);
  TDecimalLiteral& operator=(const TDecimalLiteral&);
  TDecimalLiteral() : value() {
  }

  virtual ~TDecimalLiteral() throw();
  std::string value;

  void __set_value(const std::string& val);

  bool operator == (const TDecimalLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDecimalLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDecimalLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDecimalLiteral &a, TDecimalLiteral &b);

inline std::ostream& operator<<(std::ostream& out, const TDecimalLiteral& obj)
{
  obj.printTo(out);
  return out;
}


class TIntLiteral {
 public:

  TIntLiteral(const TIntLiteral&);
  TIntLiteral& operator=(const TIntLiteral&);
  TIntLiteral() : value(0) {
  }

  virtual ~TIntLiteral() throw();
  int64_t value;

  void __set_value(const int64_t val);

  bool operator == (const TIntLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TIntLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIntLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIntLiteral &a, TIntLiteral &b);

inline std::ostream& operator<<(std::ostream& out, const TIntLiteral& obj)
{
  obj.printTo(out);
  return out;
}


class TLargeIntLiteral {
 public:

  TLargeIntLiteral(const TLargeIntLiteral&);
  TLargeIntLiteral& operator=(const TLargeIntLiteral&);
  TLargeIntLiteral() : value() {
  }

  virtual ~TLargeIntLiteral() throw();
  std::string value;

  void __set_value(const std::string& val);

  bool operator == (const TLargeIntLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TLargeIntLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLargeIntLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLargeIntLiteral &a, TLargeIntLiteral &b);

inline std::ostream& operator<<(std::ostream& out, const TLargeIntLiteral& obj)
{
  obj.printTo(out);
  return out;
}


class TInPredicate {
 public:

  TInPredicate(const TInPredicate&);
  TInPredicate& operator=(const TInPredicate&);
  TInPredicate() : is_not_in(0) {
  }

  virtual ~TInPredicate() throw();
  bool is_not_in;

  void __set_is_not_in(const bool val);

  bool operator == (const TInPredicate & rhs) const
  {
    if (!(is_not_in == rhs.is_not_in))
      return false;
    return true;
  }
  bool operator != (const TInPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TInPredicate &a, TInPredicate &b);

inline std::ostream& operator<<(std::ostream& out, const TInPredicate& obj)
{
  obj.printTo(out);
  return out;
}


class TIsNullPredicate {
 public:

  TIsNullPredicate(const TIsNullPredicate&);
  TIsNullPredicate& operator=(const TIsNullPredicate&);
  TIsNullPredicate() : is_not_null(0) {
  }

  virtual ~TIsNullPredicate() throw();
  bool is_not_null;

  void __set_is_not_null(const bool val);

  bool operator == (const TIsNullPredicate & rhs) const
  {
    if (!(is_not_null == rhs.is_not_null))
      return false;
    return true;
  }
  bool operator != (const TIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIsNullPredicate &a, TIsNullPredicate &b);

inline std::ostream& operator<<(std::ostream& out, const TIsNullPredicate& obj)
{
  obj.printTo(out);
  return out;
}


class TLikePredicate {
 public:

  TLikePredicate(const TLikePredicate&);
  TLikePredicate& operator=(const TLikePredicate&);
  TLikePredicate() : escape_char() {
  }

  virtual ~TLikePredicate() throw();
  std::string escape_char;

  void __set_escape_char(const std::string& val);

  bool operator == (const TLikePredicate & rhs) const
  {
    if (!(escape_char == rhs.escape_char))
      return false;
    return true;
  }
  bool operator != (const TLikePredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLikePredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLikePredicate &a, TLikePredicate &b);

inline std::ostream& operator<<(std::ostream& out, const TLikePredicate& obj)
{
  obj.printTo(out);
  return out;
}


class TLiteralPredicate {
 public:

  TLiteralPredicate(const TLiteralPredicate&);
  TLiteralPredicate& operator=(const TLiteralPredicate&);
  TLiteralPredicate() : value(0), is_null(0) {
  }

  virtual ~TLiteralPredicate() throw();
  bool value;
  bool is_null;

  void __set_value(const bool val);

  void __set_is_null(const bool val);

  bool operator == (const TLiteralPredicate & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(is_null == rhs.is_null))
      return false;
    return true;
  }
  bool operator != (const TLiteralPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLiteralPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLiteralPredicate &a, TLiteralPredicate &b);

inline std::ostream& operator<<(std::ostream& out, const TLiteralPredicate& obj)
{
  obj.printTo(out);
  return out;
}


class TTupleIsNullPredicate {
 public:

  TTupleIsNullPredicate(const TTupleIsNullPredicate&);
  TTupleIsNullPredicate& operator=(const TTupleIsNullPredicate&);
  TTupleIsNullPredicate() {
  }

  virtual ~TTupleIsNullPredicate() throw();
  std::vector< ::palo::TTupleId>  tuple_ids;

  void __set_tuple_ids(const std::vector< ::palo::TTupleId> & val);

  bool operator == (const TTupleIsNullPredicate & rhs) const
  {
    if (!(tuple_ids == rhs.tuple_ids))
      return false;
    return true;
  }
  bool operator != (const TTupleIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTupleIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b);

inline std::ostream& operator<<(std::ostream& out, const TTupleIsNullPredicate& obj)
{
  obj.printTo(out);
  return out;
}


class TSlotRef {
 public:

  TSlotRef(const TSlotRef&);
  TSlotRef& operator=(const TSlotRef&);
  TSlotRef() : slot_id(0), tuple_id(0) {
  }

  virtual ~TSlotRef() throw();
   ::palo::TSlotId slot_id;
   ::palo::TTupleId tuple_id;

  void __set_slot_id(const  ::palo::TSlotId val);

  void __set_tuple_id(const  ::palo::TTupleId val);

  bool operator == (const TSlotRef & rhs) const
  {
    if (!(slot_id == rhs.slot_id))
      return false;
    if (!(tuple_id == rhs.tuple_id))
      return false;
    return true;
  }
  bool operator != (const TSlotRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSlotRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSlotRef &a, TSlotRef &b);

inline std::ostream& operator<<(std::ostream& out, const TSlotRef& obj)
{
  obj.printTo(out);
  return out;
}


class TStringLiteral {
 public:

  TStringLiteral(const TStringLiteral&);
  TStringLiteral& operator=(const TStringLiteral&);
  TStringLiteral() : value() {
  }

  virtual ~TStringLiteral() throw();
  std::string value;

  void __set_value(const std::string& val);

  bool operator == (const TStringLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TStringLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStringLiteral &a, TStringLiteral &b);

inline std::ostream& operator<<(std::ostream& out, const TStringLiteral& obj)
{
  obj.printTo(out);
  return out;
}


class TInfoFunc {
 public:

  TInfoFunc(const TInfoFunc&);
  TInfoFunc& operator=(const TInfoFunc&);
  TInfoFunc() : int_value(0), str_value() {
  }

  virtual ~TInfoFunc() throw();
  int64_t int_value;
  std::string str_value;

  void __set_int_value(const int64_t val);

  void __set_str_value(const std::string& val);

  bool operator == (const TInfoFunc & rhs) const
  {
    if (!(int_value == rhs.int_value))
      return false;
    if (!(str_value == rhs.str_value))
      return false;
    return true;
  }
  bool operator != (const TInfoFunc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInfoFunc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TInfoFunc &a, TInfoFunc &b);

inline std::ostream& operator<<(std::ostream& out, const TInfoFunc& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TFunctionCallExpr__isset {
  _TFunctionCallExpr__isset() : vararg_start_idx(false) {}
  bool vararg_start_idx :1;
} _TFunctionCallExpr__isset;

class TFunctionCallExpr {
 public:

  TFunctionCallExpr(const TFunctionCallExpr&);
  TFunctionCallExpr& operator=(const TFunctionCallExpr&);
  TFunctionCallExpr() : vararg_start_idx(0) {
  }

  virtual ~TFunctionCallExpr() throw();
   ::palo::TFunction fn;
  int32_t vararg_start_idx;

  _TFunctionCallExpr__isset __isset;

  void __set_fn(const  ::palo::TFunction& val);

  void __set_vararg_start_idx(const int32_t val);

  bool operator == (const TFunctionCallExpr & rhs) const
  {
    if (!(fn == rhs.fn))
      return false;
    if (__isset.vararg_start_idx != rhs.__isset.vararg_start_idx)
      return false;
    else if (__isset.vararg_start_idx && !(vararg_start_idx == rhs.vararg_start_idx))
      return false;
    return true;
  }
  bool operator != (const TFunctionCallExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunctionCallExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFunctionCallExpr &a, TFunctionCallExpr &b);

inline std::ostream& operator<<(std::ostream& out, const TFunctionCallExpr& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TExprNode__isset {
  _TExprNode__isset() : opcode(false), agg_expr(false), bool_literal(false), case_expr(false), date_literal(false), float_literal(false), int_literal(false), in_predicate(false), is_null_pred(false), like_pred(false), literal_pred(false), slot_ref(false), string_literal(false), tuple_is_null_pred(false), info_func(false), decimal_literal(false), fn_call_expr(false), large_int_literal(false), output_column(false), output_type(false), vector_opcode(false), fn(false), vararg_start_idx(false), child_type(false) {}
  bool opcode :1;
  bool agg_expr :1;
  bool bool_literal :1;
  bool case_expr :1;
  bool date_literal :1;
  bool float_literal :1;
  bool int_literal :1;
  bool in_predicate :1;
  bool is_null_pred :1;
  bool like_pred :1;
  bool literal_pred :1;
  bool slot_ref :1;
  bool string_literal :1;
  bool tuple_is_null_pred :1;
  bool info_func :1;
  bool decimal_literal :1;
  bool fn_call_expr :1;
  bool large_int_literal :1;
  bool output_column :1;
  bool output_type :1;
  bool vector_opcode :1;
  bool fn :1;
  bool vararg_start_idx :1;
  bool child_type :1;
} _TExprNode__isset;

class TExprNode {
 public:

  TExprNode(const TExprNode&);
  TExprNode& operator=(const TExprNode&);
  TExprNode() : node_type((TExprNodeType::type)0), opcode(( ::TExprOpcode::type)0), num_children(0), output_scale(0), output_column(0), vector_opcode(( ::TExprOpcode::type)0), vararg_start_idx(0), child_type(( ::palo::TPrimitiveType::type)0) {
  }

  virtual ~TExprNode() throw();
  TExprNodeType::type node_type;
   ::palo::TTypeDesc type;
   ::TExprOpcode::type opcode;
  int32_t num_children;
  TAggregateExpr agg_expr;
  TBoolLiteral bool_literal;
  TCaseExpr case_expr;
  TDateLiteral date_literal;
  TFloatLiteral float_literal;
  TIntLiteral int_literal;
  TInPredicate in_predicate;
  TIsNullPredicate is_null_pred;
  TLikePredicate like_pred;
  TLiteralPredicate literal_pred;
  TSlotRef slot_ref;
  TStringLiteral string_literal;
  TTupleIsNullPredicate tuple_is_null_pred;
  TInfoFunc info_func;
  TDecimalLiteral decimal_literal;
  int32_t output_scale;
  TFunctionCallExpr fn_call_expr;
  TLargeIntLiteral large_int_literal;
  int32_t output_column;
   ::palo::TColumnType output_type;
   ::TExprOpcode::type vector_opcode;
   ::palo::TFunction fn;
  int32_t vararg_start_idx;
   ::palo::TPrimitiveType::type child_type;

  _TExprNode__isset __isset;

  void __set_node_type(const TExprNodeType::type val);

  void __set_type(const  ::palo::TTypeDesc& val);

  void __set_opcode(const  ::TExprOpcode::type val);

  void __set_num_children(const int32_t val);

  void __set_agg_expr(const TAggregateExpr& val);

  void __set_bool_literal(const TBoolLiteral& val);

  void __set_case_expr(const TCaseExpr& val);

  void __set_date_literal(const TDateLiteral& val);

  void __set_float_literal(const TFloatLiteral& val);

  void __set_int_literal(const TIntLiteral& val);

  void __set_in_predicate(const TInPredicate& val);

  void __set_is_null_pred(const TIsNullPredicate& val);

  void __set_like_pred(const TLikePredicate& val);

  void __set_literal_pred(const TLiteralPredicate& val);

  void __set_slot_ref(const TSlotRef& val);

  void __set_string_literal(const TStringLiteral& val);

  void __set_tuple_is_null_pred(const TTupleIsNullPredicate& val);

  void __set_info_func(const TInfoFunc& val);

  void __set_decimal_literal(const TDecimalLiteral& val);

  void __set_output_scale(const int32_t val);

  void __set_fn_call_expr(const TFunctionCallExpr& val);

  void __set_large_int_literal(const TLargeIntLiteral& val);

  void __set_output_column(const int32_t val);

  void __set_output_type(const  ::palo::TColumnType& val);

  void __set_vector_opcode(const  ::TExprOpcode::type val);

  void __set_fn(const  ::palo::TFunction& val);

  void __set_vararg_start_idx(const int32_t val);

  void __set_child_type(const  ::palo::TPrimitiveType::type val);

  bool operator == (const TExprNode & rhs) const
  {
    if (!(node_type == rhs.node_type))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.opcode != rhs.__isset.opcode)
      return false;
    else if (__isset.opcode && !(opcode == rhs.opcode))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (__isset.agg_expr != rhs.__isset.agg_expr)
      return false;
    else if (__isset.agg_expr && !(agg_expr == rhs.agg_expr))
      return false;
    if (__isset.bool_literal != rhs.__isset.bool_literal)
      return false;
    else if (__isset.bool_literal && !(bool_literal == rhs.bool_literal))
      return false;
    if (__isset.case_expr != rhs.__isset.case_expr)
      return false;
    else if (__isset.case_expr && !(case_expr == rhs.case_expr))
      return false;
    if (__isset.date_literal != rhs.__isset.date_literal)
      return false;
    else if (__isset.date_literal && !(date_literal == rhs.date_literal))
      return false;
    if (__isset.float_literal != rhs.__isset.float_literal)
      return false;
    else if (__isset.float_literal && !(float_literal == rhs.float_literal))
      return false;
    if (__isset.int_literal != rhs.__isset.int_literal)
      return false;
    else if (__isset.int_literal && !(int_literal == rhs.int_literal))
      return false;
    if (__isset.in_predicate != rhs.__isset.in_predicate)
      return false;
    else if (__isset.in_predicate && !(in_predicate == rhs.in_predicate))
      return false;
    if (__isset.is_null_pred != rhs.__isset.is_null_pred)
      return false;
    else if (__isset.is_null_pred && !(is_null_pred == rhs.is_null_pred))
      return false;
    if (__isset.like_pred != rhs.__isset.like_pred)
      return false;
    else if (__isset.like_pred && !(like_pred == rhs.like_pred))
      return false;
    if (__isset.literal_pred != rhs.__isset.literal_pred)
      return false;
    else if (__isset.literal_pred && !(literal_pred == rhs.literal_pred))
      return false;
    if (__isset.slot_ref != rhs.__isset.slot_ref)
      return false;
    else if (__isset.slot_ref && !(slot_ref == rhs.slot_ref))
      return false;
    if (__isset.string_literal != rhs.__isset.string_literal)
      return false;
    else if (__isset.string_literal && !(string_literal == rhs.string_literal))
      return false;
    if (__isset.tuple_is_null_pred != rhs.__isset.tuple_is_null_pred)
      return false;
    else if (__isset.tuple_is_null_pred && !(tuple_is_null_pred == rhs.tuple_is_null_pred))
      return false;
    if (__isset.info_func != rhs.__isset.info_func)
      return false;
    else if (__isset.info_func && !(info_func == rhs.info_func))
      return false;
    if (__isset.decimal_literal != rhs.__isset.decimal_literal)
      return false;
    else if (__isset.decimal_literal && !(decimal_literal == rhs.decimal_literal))
      return false;
    if (!(output_scale == rhs.output_scale))
      return false;
    if (__isset.fn_call_expr != rhs.__isset.fn_call_expr)
      return false;
    else if (__isset.fn_call_expr && !(fn_call_expr == rhs.fn_call_expr))
      return false;
    if (__isset.large_int_literal != rhs.__isset.large_int_literal)
      return false;
    else if (__isset.large_int_literal && !(large_int_literal == rhs.large_int_literal))
      return false;
    if (__isset.output_column != rhs.__isset.output_column)
      return false;
    else if (__isset.output_column && !(output_column == rhs.output_column))
      return false;
    if (__isset.output_type != rhs.__isset.output_type)
      return false;
    else if (__isset.output_type && !(output_type == rhs.output_type))
      return false;
    if (__isset.vector_opcode != rhs.__isset.vector_opcode)
      return false;
    else if (__isset.vector_opcode && !(vector_opcode == rhs.vector_opcode))
      return false;
    if (__isset.fn != rhs.__isset.fn)
      return false;
    else if (__isset.fn && !(fn == rhs.fn))
      return false;
    if (__isset.vararg_start_idx != rhs.__isset.vararg_start_idx)
      return false;
    else if (__isset.vararg_start_idx && !(vararg_start_idx == rhs.vararg_start_idx))
      return false;
    if (__isset.child_type != rhs.__isset.child_type)
      return false;
    else if (__isset.child_type && !(child_type == rhs.child_type))
      return false;
    return true;
  }
  bool operator != (const TExprNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExprNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExprNode &a, TExprNode &b);

inline std::ostream& operator<<(std::ostream& out, const TExprNode& obj)
{
  obj.printTo(out);
  return out;
}


class TExpr {
 public:

  TExpr(const TExpr&);
  TExpr& operator=(const TExpr&);
  TExpr() {
  }

  virtual ~TExpr() throw();
  std::vector<TExprNode>  nodes;

  void __set_nodes(const std::vector<TExprNode> & val);

  bool operator == (const TExpr & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExpr &a, TExpr &b);

inline std::ostream& operator<<(std::ostream& out, const TExpr& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
