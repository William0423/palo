/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "MasterService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTResourceTypeValues[] = {
  TResourceType::TRESOURCE_CPU_SHARE,
  TResourceType::TRESOURCE_IO_SHARE,
  TResourceType::TRESOURCE_SSD_READ_IOPS,
  TResourceType::TRESOURCE_SSD_WRITE_IOPS,
  TResourceType::TRESOURCE_SSD_READ_MBPS,
  TResourceType::TRESOURCE_SSD_WRITE_MBPS,
  TResourceType::TRESOURCE_HDD_READ_IOPS,
  TResourceType::TRESOURCE_HDD_WRITE_IOPS,
  TResourceType::TRESOURCE_HDD_READ_MBPS,
  TResourceType::TRESOURCE_HDD_WRITE_MBPS
};
const char* _kTResourceTypeNames[] = {
  "TRESOURCE_CPU_SHARE",
  "TRESOURCE_IO_SHARE",
  "TRESOURCE_SSD_READ_IOPS",
  "TRESOURCE_SSD_WRITE_IOPS",
  "TRESOURCE_SSD_READ_MBPS",
  "TRESOURCE_SSD_WRITE_MBPS",
  "TRESOURCE_HDD_READ_IOPS",
  "TRESOURCE_HDD_WRITE_IOPS",
  "TRESOURCE_HDD_READ_MBPS",
  "TRESOURCE_HDD_WRITE_MBPS"
};
const std::map<int, const char*> _TResourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kTResourceTypeValues, _kTResourceTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TTabletInfo::~TTabletInfo() throw() {
}


void TTabletInfo::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TTabletInfo::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TTabletInfo::__set_version(const  ::palo::TVersion val) {
  this->version = val;
}

void TTabletInfo::__set_version_hash(const  ::palo::TVersionHash val) {
  this->version_hash = val;
}

void TTabletInfo::__set_row_count(const  ::palo::TCount val) {
  this->row_count = val;
}

void TTabletInfo::__set_data_size(const  ::palo::TSize val) {
  this->data_size = val;
}

void TTabletInfo::__set_storage_medium(const  ::palo::TStorageMedium::type val) {
  this->storage_medium = val;
__isset.storage_medium = true;
}

uint32_t TTabletInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;
  bool isset_row_count = false;
  bool isset_data_size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_count);
          isset_row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->data_size);
          isset_data_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->storage_medium = ( ::palo::TStorageMedium::type)ecast0;
          this->__isset.storage_medium = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTabletInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTabletInfo");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_count", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->row_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_size", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->data_size);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.storage_medium) {
    xfer += oprot->writeFieldBegin("storage_medium", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->storage_medium);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTabletInfo &a, TTabletInfo &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.row_count, b.row_count);
  swap(a.data_size, b.data_size);
  swap(a.storage_medium, b.storage_medium);
  swap(a.__isset, b.__isset);
}

TTabletInfo::TTabletInfo(const TTabletInfo& other1) {
  tablet_id = other1.tablet_id;
  schema_hash = other1.schema_hash;
  version = other1.version;
  version_hash = other1.version_hash;
  row_count = other1.row_count;
  data_size = other1.data_size;
  storage_medium = other1.storage_medium;
  __isset = other1.__isset;
}
TTabletInfo& TTabletInfo::operator=(const TTabletInfo& other2) {
  tablet_id = other2.tablet_id;
  schema_hash = other2.schema_hash;
  version = other2.version;
  version_hash = other2.version_hash;
  row_count = other2.row_count;
  data_size = other2.data_size;
  storage_medium = other2.storage_medium;
  __isset = other2.__isset;
  return *this;
}
void TTabletInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTabletInfo(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "version=" << to_string(version);
  out << ", " << "version_hash=" << to_string(version_hash);
  out << ", " << "row_count=" << to_string(row_count);
  out << ", " << "data_size=" << to_string(data_size);
  out << ", " << "storage_medium="; (__isset.storage_medium ? (out << to_string(storage_medium)) : (out << "<null>"));
  out << ")";
}


TFinishTaskRequest::~TFinishTaskRequest() throw() {
}


void TFinishTaskRequest::__set_backend(const  ::palo::TBackend& val) {
  this->backend = val;
}

void TFinishTaskRequest::__set_task_type(const  ::palo::TTaskType::type val) {
  this->task_type = val;
}

void TFinishTaskRequest::__set_signature(const int64_t val) {
  this->signature = val;
}

void TFinishTaskRequest::__set_task_status(const  ::palo::TStatus& val) {
  this->task_status = val;
}

void TFinishTaskRequest::__set_report_version(const int64_t val) {
  this->report_version = val;
__isset.report_version = true;
}

void TFinishTaskRequest::__set_finish_tablet_infos(const std::vector<TTabletInfo> & val) {
  this->finish_tablet_infos = val;
__isset.finish_tablet_infos = true;
}

void TFinishTaskRequest::__set_tablet_checksum(const int64_t val) {
  this->tablet_checksum = val;
__isset.tablet_checksum = true;
}

void TFinishTaskRequest::__set_request_version(const int64_t val) {
  this->request_version = val;
__isset.request_version = true;
}

void TFinishTaskRequest::__set_request_version_hash(const int64_t val) {
  this->request_version_hash = val;
__isset.request_version_hash = true;
}

void TFinishTaskRequest::__set_snapshot_path(const std::string& val) {
  this->snapshot_path = val;
__isset.snapshot_path = true;
}

uint32_t TFinishTaskRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_backend = false;
  bool isset_task_type = false;
  bool isset_signature = false;
  bool isset_task_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->backend.read(iprot);
          isset_backend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->task_type = ( ::palo::TTaskType::type)ecast3;
          isset_task_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->signature);
          isset_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->task_status.read(iprot);
          isset_task_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->report_version);
          this->__isset.report_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->finish_tablet_infos.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->finish_tablet_infos.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->finish_tablet_infos[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.finish_tablet_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_checksum);
          this->__isset.tablet_checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->request_version);
          this->__isset.request_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->request_version_hash);
          this->__isset.request_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_path);
          this->__isset.snapshot_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_backend)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_task_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_signature)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_task_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFinishTaskRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFinishTaskRequest");

  xfer += oprot->writeFieldBegin("backend", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->backend.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->task_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_status", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->task_status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.report_version) {
    xfer += oprot->writeFieldBegin("report_version", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->report_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finish_tablet_infos) {
    xfer += oprot->writeFieldBegin("finish_tablet_infos", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->finish_tablet_infos.size()));
      std::vector<TTabletInfo> ::const_iterator _iter9;
      for (_iter9 = this->finish_tablet_infos.begin(); _iter9 != this->finish_tablet_infos.end(); ++_iter9)
      {
        xfer += (*_iter9).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablet_checksum) {
    xfer += oprot->writeFieldBegin("tablet_checksum", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->tablet_checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.request_version) {
    xfer += oprot->writeFieldBegin("request_version", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->request_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.request_version_hash) {
    xfer += oprot->writeFieldBegin("request_version_hash", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->request_version_hash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_path) {
    xfer += oprot->writeFieldBegin("snapshot_path", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->snapshot_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFinishTaskRequest &a, TFinishTaskRequest &b) {
  using ::std::swap;
  swap(a.backend, b.backend);
  swap(a.task_type, b.task_type);
  swap(a.signature, b.signature);
  swap(a.task_status, b.task_status);
  swap(a.report_version, b.report_version);
  swap(a.finish_tablet_infos, b.finish_tablet_infos);
  swap(a.tablet_checksum, b.tablet_checksum);
  swap(a.request_version, b.request_version);
  swap(a.request_version_hash, b.request_version_hash);
  swap(a.snapshot_path, b.snapshot_path);
  swap(a.__isset, b.__isset);
}

TFinishTaskRequest::TFinishTaskRequest(const TFinishTaskRequest& other10) {
  backend = other10.backend;
  task_type = other10.task_type;
  signature = other10.signature;
  task_status = other10.task_status;
  report_version = other10.report_version;
  finish_tablet_infos = other10.finish_tablet_infos;
  tablet_checksum = other10.tablet_checksum;
  request_version = other10.request_version;
  request_version_hash = other10.request_version_hash;
  snapshot_path = other10.snapshot_path;
  __isset = other10.__isset;
}
TFinishTaskRequest& TFinishTaskRequest::operator=(const TFinishTaskRequest& other11) {
  backend = other11.backend;
  task_type = other11.task_type;
  signature = other11.signature;
  task_status = other11.task_status;
  report_version = other11.report_version;
  finish_tablet_infos = other11.finish_tablet_infos;
  tablet_checksum = other11.tablet_checksum;
  request_version = other11.request_version;
  request_version_hash = other11.request_version_hash;
  snapshot_path = other11.snapshot_path;
  __isset = other11.__isset;
  return *this;
}
void TFinishTaskRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFinishTaskRequest(";
  out << "backend=" << to_string(backend);
  out << ", " << "task_type=" << to_string(task_type);
  out << ", " << "signature=" << to_string(signature);
  out << ", " << "task_status=" << to_string(task_status);
  out << ", " << "report_version="; (__isset.report_version ? (out << to_string(report_version)) : (out << "<null>"));
  out << ", " << "finish_tablet_infos="; (__isset.finish_tablet_infos ? (out << to_string(finish_tablet_infos)) : (out << "<null>"));
  out << ", " << "tablet_checksum="; (__isset.tablet_checksum ? (out << to_string(tablet_checksum)) : (out << "<null>"));
  out << ", " << "request_version="; (__isset.request_version ? (out << to_string(request_version)) : (out << "<null>"));
  out << ", " << "request_version_hash="; (__isset.request_version_hash ? (out << to_string(request_version_hash)) : (out << "<null>"));
  out << ", " << "snapshot_path="; (__isset.snapshot_path ? (out << to_string(snapshot_path)) : (out << "<null>"));
  out << ")";
}


TTablet::~TTablet() throw() {
}


void TTablet::__set_tablet_infos(const std::vector<TTabletInfo> & val) {
  this->tablet_infos = val;
}

uint32_t TTablet::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_infos = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tablet_infos.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->tablet_infos.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->tablet_infos[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tablet_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_infos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTablet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTablet");

  xfer += oprot->writeFieldBegin("tablet_infos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tablet_infos.size()));
    std::vector<TTabletInfo> ::const_iterator _iter17;
    for (_iter17 = this->tablet_infos.begin(); _iter17 != this->tablet_infos.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTablet &a, TTablet &b) {
  using ::std::swap;
  swap(a.tablet_infos, b.tablet_infos);
}

TTablet::TTablet(const TTablet& other18) {
  tablet_infos = other18.tablet_infos;
}
TTablet& TTablet::operator=(const TTablet& other19) {
  tablet_infos = other19.tablet_infos;
  return *this;
}
void TTablet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTablet(";
  out << "tablet_infos=" << to_string(tablet_infos);
  out << ")";
}


TDisk::~TDisk() throw() {
}


void TDisk::__set_root_path(const std::string& val) {
  this->root_path = val;
}

void TDisk::__set_disk_total_capacity(const  ::palo::TSize val) {
  this->disk_total_capacity = val;
}

void TDisk::__set_data_used_capacity(const  ::palo::TSize val) {
  this->data_used_capacity = val;
}

void TDisk::__set_used(const bool val) {
  this->used = val;
}

void TDisk::__set_disk_available_capacity(const  ::palo::TSize val) {
  this->disk_available_capacity = val;
__isset.disk_available_capacity = true;
}

uint32_t TDisk::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_root_path = false;
  bool isset_disk_total_capacity = false;
  bool isset_data_used_capacity = false;
  bool isset_used = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->root_path);
          isset_root_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->disk_total_capacity);
          isset_disk_total_capacity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->data_used_capacity);
          isset_data_used_capacity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->used);
          isset_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->disk_available_capacity);
          this->__isset.disk_available_capacity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_root_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_disk_total_capacity)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data_used_capacity)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_used)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDisk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDisk");

  xfer += oprot->writeFieldBegin("root_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->root_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disk_total_capacity", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->disk_total_capacity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_used_capacity", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->data_used_capacity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("used", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->used);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.disk_available_capacity) {
    xfer += oprot->writeFieldBegin("disk_available_capacity", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->disk_available_capacity);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDisk &a, TDisk &b) {
  using ::std::swap;
  swap(a.root_path, b.root_path);
  swap(a.disk_total_capacity, b.disk_total_capacity);
  swap(a.data_used_capacity, b.data_used_capacity);
  swap(a.used, b.used);
  swap(a.disk_available_capacity, b.disk_available_capacity);
  swap(a.__isset, b.__isset);
}

TDisk::TDisk(const TDisk& other20) {
  root_path = other20.root_path;
  disk_total_capacity = other20.disk_total_capacity;
  data_used_capacity = other20.data_used_capacity;
  used = other20.used;
  disk_available_capacity = other20.disk_available_capacity;
  __isset = other20.__isset;
}
TDisk& TDisk::operator=(const TDisk& other21) {
  root_path = other21.root_path;
  disk_total_capacity = other21.disk_total_capacity;
  data_used_capacity = other21.data_used_capacity;
  used = other21.used;
  disk_available_capacity = other21.disk_available_capacity;
  __isset = other21.__isset;
  return *this;
}
void TDisk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDisk(";
  out << "root_path=" << to_string(root_path);
  out << ", " << "disk_total_capacity=" << to_string(disk_total_capacity);
  out << ", " << "data_used_capacity=" << to_string(data_used_capacity);
  out << ", " << "used=" << to_string(used);
  out << ", " << "disk_available_capacity="; (__isset.disk_available_capacity ? (out << to_string(disk_available_capacity)) : (out << "<null>"));
  out << ")";
}


TReportRequest::~TReportRequest() throw() {
}


void TReportRequest::__set_backend(const  ::palo::TBackend& val) {
  this->backend = val;
}

void TReportRequest::__set_report_version(const int64_t val) {
  this->report_version = val;
__isset.report_version = true;
}

void TReportRequest::__set_tasks(const std::map< ::palo::TTaskType::type, std::set<int64_t> > & val) {
  this->tasks = val;
__isset.tasks = true;
}

void TReportRequest::__set_tablets(const std::map< ::palo::TTabletId, TTablet> & val) {
  this->tablets = val;
__isset.tablets = true;
}

void TReportRequest::__set_disks(const std::map<std::string, TDisk> & val) {
  this->disks = val;
__isset.disks = true;
}

uint32_t TReportRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_backend = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->backend.read(iprot);
          isset_backend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->report_version);
          this->__isset.report_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tasks.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
               ::palo::TTaskType::type _key27;
              int32_t ecast29;
              xfer += iprot->readI32(ecast29);
              _key27 = ( ::palo::TTaskType::type)ecast29;
              std::set<int64_t> & _val28 = this->tasks[_key27];
              {
                _val28.clear();
                uint32_t _size30;
                ::apache::thrift::protocol::TType _etype33;
                xfer += iprot->readSetBegin(_etype33, _size30);
                uint32_t _i34;
                for (_i34 = 0; _i34 < _size30; ++_i34)
                {
                  int64_t _elem35;
                  xfer += iprot->readI64(_elem35);
                  _val28.insert(_elem35);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tasks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tablets.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _ktype37;
            ::apache::thrift::protocol::TType _vtype38;
            xfer += iprot->readMapBegin(_ktype37, _vtype38, _size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
               ::palo::TTabletId _key41;
              xfer += iprot->readI64(_key41);
              TTablet& _val42 = this->tablets[_key41];
              xfer += _val42.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _ktype44;
            ::apache::thrift::protocol::TType _vtype45;
            xfer += iprot->readMapBegin(_ktype44, _vtype45, _size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              std::string _key48;
              xfer += iprot->readString(_key48);
              TDisk& _val49 = this->disks[_key48];
              xfer += _val49.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_backend)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TReportRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TReportRequest");

  xfer += oprot->writeFieldBegin("backend", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->backend.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.report_version) {
    xfer += oprot->writeFieldBegin("report_version", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->report_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tasks) {
    xfer += oprot->writeFieldBegin("tasks", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->tasks.size()));
      std::map< ::palo::TTaskType::type, std::set<int64_t> > ::const_iterator _iter50;
      for (_iter50 = this->tasks.begin(); _iter50 != this->tasks.end(); ++_iter50)
      {
        xfer += oprot->writeI32((int32_t)_iter50->first);
        {
          xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter50->second.size()));
          std::set<int64_t> ::const_iterator _iter51;
          for (_iter51 = _iter50->second.begin(); _iter51 != _iter50->second.end(); ++_iter51)
          {
            xfer += oprot->writeI64((*_iter51));
          }
          xfer += oprot->writeSetEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablets) {
    xfer += oprot->writeFieldBegin("tablets", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tablets.size()));
      std::map< ::palo::TTabletId, TTablet> ::const_iterator _iter52;
      for (_iter52 = this->tablets.begin(); _iter52 != this->tablets.end(); ++_iter52)
      {
        xfer += oprot->writeI64(_iter52->first);
        xfer += _iter52->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disks.size()));
      std::map<std::string, TDisk> ::const_iterator _iter53;
      for (_iter53 = this->disks.begin(); _iter53 != this->disks.end(); ++_iter53)
      {
        xfer += oprot->writeString(_iter53->first);
        xfer += _iter53->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TReportRequest &a, TReportRequest &b) {
  using ::std::swap;
  swap(a.backend, b.backend);
  swap(a.report_version, b.report_version);
  swap(a.tasks, b.tasks);
  swap(a.tablets, b.tablets);
  swap(a.disks, b.disks);
  swap(a.__isset, b.__isset);
}

TReportRequest::TReportRequest(const TReportRequest& other54) {
  backend = other54.backend;
  report_version = other54.report_version;
  tasks = other54.tasks;
  tablets = other54.tablets;
  disks = other54.disks;
  __isset = other54.__isset;
}
TReportRequest& TReportRequest::operator=(const TReportRequest& other55) {
  backend = other55.backend;
  report_version = other55.report_version;
  tasks = other55.tasks;
  tablets = other55.tablets;
  disks = other55.disks;
  __isset = other55.__isset;
  return *this;
}
void TReportRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TReportRequest(";
  out << "backend=" << to_string(backend);
  out << ", " << "report_version="; (__isset.report_version ? (out << to_string(report_version)) : (out << "<null>"));
  out << ", " << "tasks="; (__isset.tasks ? (out << to_string(tasks)) : (out << "<null>"));
  out << ", " << "tablets="; (__isset.tablets ? (out << to_string(tablets)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ")";
}


TMasterResult::~TMasterResult() throw() {
}


void TMasterResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
}

uint32_t TMasterResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMasterResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMasterResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMasterResult &a, TMasterResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TMasterResult::TMasterResult(const TMasterResult& other56) {
  status = other56.status;
}
TMasterResult& TMasterResult::operator=(const TMasterResult& other57) {
  status = other57.status;
  return *this;
}
void TMasterResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMasterResult(";
  out << "status=" << to_string(status);
  out << ")";
}


TResourceGroup::~TResourceGroup() throw() {
}


void TResourceGroup::__set_resourceByType(const std::map<TResourceType::type, int32_t> & val) {
  this->resourceByType = val;
}

uint32_t TResourceGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourceByType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->resourceByType.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _ktype59;
            ::apache::thrift::protocol::TType _vtype60;
            xfer += iprot->readMapBegin(_ktype59, _vtype60, _size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              TResourceType::type _key63;
              int32_t ecast65;
              xfer += iprot->readI32(ecast65);
              _key63 = (TResourceType::type)ecast65;
              int32_t& _val64 = this->resourceByType[_key63];
              xfer += iprot->readI32(_val64);
            }
            xfer += iprot->readMapEnd();
          }
          isset_resourceByType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourceByType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResourceGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResourceGroup");

  xfer += oprot->writeFieldBegin("resourceByType", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->resourceByType.size()));
    std::map<TResourceType::type, int32_t> ::const_iterator _iter66;
    for (_iter66 = this->resourceByType.begin(); _iter66 != this->resourceByType.end(); ++_iter66)
    {
      xfer += oprot->writeI32((int32_t)_iter66->first);
      xfer += oprot->writeI32(_iter66->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResourceGroup &a, TResourceGroup &b) {
  using ::std::swap;
  swap(a.resourceByType, b.resourceByType);
}

TResourceGroup::TResourceGroup(const TResourceGroup& other67) {
  resourceByType = other67.resourceByType;
}
TResourceGroup& TResourceGroup::operator=(const TResourceGroup& other68) {
  resourceByType = other68.resourceByType;
  return *this;
}
void TResourceGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResourceGroup(";
  out << "resourceByType=" << to_string(resourceByType);
  out << ")";
}


TUserResource::~TUserResource() throw() {
}


void TUserResource::__set_resource(const TResourceGroup& val) {
  this->resource = val;
}

void TUserResource::__set_shareByGroup(const std::map<std::string, int32_t> & val) {
  this->shareByGroup = val;
}

uint32_t TUserResource::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource = false;
  bool isset_shareByGroup = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource.read(iprot);
          isset_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->shareByGroup.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _ktype70;
            ::apache::thrift::protocol::TType _vtype71;
            xfer += iprot->readMapBegin(_ktype70, _vtype71, _size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              std::string _key74;
              xfer += iprot->readString(_key74);
              int32_t& _val75 = this->shareByGroup[_key74];
              xfer += iprot->readI32(_val75);
            }
            xfer += iprot->readMapEnd();
          }
          isset_shareByGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shareByGroup)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUserResource::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserResource");

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->resource.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shareByGroup", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->shareByGroup.size()));
    std::map<std::string, int32_t> ::const_iterator _iter76;
    for (_iter76 = this->shareByGroup.begin(); _iter76 != this->shareByGroup.end(); ++_iter76)
    {
      xfer += oprot->writeString(_iter76->first);
      xfer += oprot->writeI32(_iter76->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserResource &a, TUserResource &b) {
  using ::std::swap;
  swap(a.resource, b.resource);
  swap(a.shareByGroup, b.shareByGroup);
}

TUserResource::TUserResource(const TUserResource& other77) {
  resource = other77.resource;
  shareByGroup = other77.shareByGroup;
}
TUserResource& TUserResource::operator=(const TUserResource& other78) {
  resource = other78.resource;
  shareByGroup = other78.shareByGroup;
  return *this;
}
void TUserResource::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserResource(";
  out << "resource=" << to_string(resource);
  out << ", " << "shareByGroup=" << to_string(shareByGroup);
  out << ")";
}


TFetchResourceResult::~TFetchResourceResult() throw() {
}


void TFetchResourceResult::__set_protocolVersion(const  ::palo::TAgentServiceVersion::type val) {
  this->protocolVersion = val;
}

void TFetchResourceResult::__set_resourceVersion(const int64_t val) {
  this->resourceVersion = val;
}

void TFetchResourceResult::__set_resourceByUser(const std::map<std::string, TUserResource> & val) {
  this->resourceByUser = val;
}

uint32_t TFetchResourceResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocolVersion = false;
  bool isset_resourceVersion = false;
  bool isset_resourceByUser = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast79;
          xfer += iprot->readI32(ecast79);
          this->protocolVersion = ( ::palo::TAgentServiceVersion::type)ecast79;
          isset_protocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->resourceVersion);
          isset_resourceVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->resourceByUser.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _ktype81;
            ::apache::thrift::protocol::TType _vtype82;
            xfer += iprot->readMapBegin(_ktype81, _vtype82, _size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              std::string _key85;
              xfer += iprot->readString(_key85);
              TUserResource& _val86 = this->resourceByUser[_key85];
              xfer += _val86.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_resourceByUser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceByUser)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchResourceResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchResourceResult");

  xfer += oprot->writeFieldBegin("protocolVersion", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocolVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceVersion", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->resourceVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceByUser", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourceByUser.size()));
    std::map<std::string, TUserResource> ::const_iterator _iter87;
    for (_iter87 = this->resourceByUser.begin(); _iter87 != this->resourceByUser.end(); ++_iter87)
    {
      xfer += oprot->writeString(_iter87->first);
      xfer += _iter87->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchResourceResult &a, TFetchResourceResult &b) {
  using ::std::swap;
  swap(a.protocolVersion, b.protocolVersion);
  swap(a.resourceVersion, b.resourceVersion);
  swap(a.resourceByUser, b.resourceByUser);
}

TFetchResourceResult::TFetchResourceResult(const TFetchResourceResult& other88) {
  protocolVersion = other88.protocolVersion;
  resourceVersion = other88.resourceVersion;
  resourceByUser = other88.resourceByUser;
}
TFetchResourceResult& TFetchResourceResult::operator=(const TFetchResourceResult& other89) {
  protocolVersion = other89.protocolVersion;
  resourceVersion = other89.resourceVersion;
  resourceByUser = other89.resourceByUser;
  return *this;
}
void TFetchResourceResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchResourceResult(";
  out << "protocolVersion=" << to_string(protocolVersion);
  out << ", " << "resourceVersion=" << to_string(resourceVersion);
  out << ", " << "resourceByUser=" << to_string(resourceByUser);
  out << ")";
}

} // namespace
