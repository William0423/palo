/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Ddl_TYPES_H
#define Ddl_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Partitions_types.h"
#include "Types_types.h"
#include "Status_types.h"


namespace palo {

struct TCommonDdlType {
  enum type {
    CREATE_DATABASE = 0,
    DROP_DATABASE = 1,
    CREATE_TABLE = 2,
    DROP_TABLE = 3,
    LOAD = 4
  };
};

extern const std::map<int, const char*> _TCommonDdlType_VALUES_TO_NAMES;

struct TAggType {
  enum type {
    AGG_SUM = 0,
    AGG_MIN = 1,
    AGG_MAX = 2,
    AGG_REPLACE = 3
  };
};

extern const std::map<int, const char*> _TAggType_VALUES_TO_NAMES;

struct THashType {
  enum type {
    CRC32 = 0
  };
};

extern const std::map<int, const char*> _THashType_VALUES_TO_NAMES;

struct TPrivType {
  enum type {
    PRIVILEGE_READ_ONLY = 0,
    PRIVILEGE_READ_WRITE = 1
  };
};

extern const std::map<int, const char*> _TPrivType_VALUES_TO_NAMES;

struct TPaloInternalServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _TPaloInternalServiceVersion_VALUES_TO_NAMES;

class TDdlResult;

class TCreateDbParams;

class TDropDbParams;

class TTableName;

class TRandomPartitionDesc;

class THashPartitionDesc;

class TValue;

class TRangeValue;

class TRangePartitionDesc;

class TPartitionDesc;

class TCreateTableParams;

class TDropTableParams;

class TCreateRollupParams;

class TDropRollupParams;

class TCreateFunctionParams;

class TDropFunctionParams;

class TUserSpecification;

class TCreateUserParams;

class TDropUserParams;

class TSetPasswordParams;

class TGrantParams;

class TDataSpecification;

class TLabelName;

class TLoadParams;

class TCancelLoadParams;

class TMasterDdlRequest;

class TMasterDdlResponse;

typedef struct _TDdlResult__isset {
  _TDdlResult__isset() : status(false) {}
  bool status :1;
} _TDdlResult__isset;

class TDdlResult {
 public:

  TDdlResult(const TDdlResult&);
  TDdlResult& operator=(const TDdlResult&);
  TDdlResult() {
  }

  virtual ~TDdlResult() throw();
   ::palo::TStatus status;

  _TDdlResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val);

  bool operator == (const TDdlResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TDdlResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDdlResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDdlResult &a, TDdlResult &b);

inline std::ostream& operator<<(std::ostream& out, const TDdlResult& obj)
{
  obj.printTo(out);
  return out;
}


class TCreateDbParams {
 public:

  TCreateDbParams(const TCreateDbParams&);
  TCreateDbParams& operator=(const TCreateDbParams&);
  TCreateDbParams() : database_name() {
  }

  virtual ~TCreateDbParams() throw();
  std::string database_name;

  void __set_database_name(const std::string& val);

  bool operator == (const TCreateDbParams & rhs) const
  {
    if (!(database_name == rhs.database_name))
      return false;
    return true;
  }
  bool operator != (const TCreateDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateDbParams &a, TCreateDbParams &b);

inline std::ostream& operator<<(std::ostream& out, const TCreateDbParams& obj)
{
  obj.printTo(out);
  return out;
}


class TDropDbParams {
 public:

  TDropDbParams(const TDropDbParams&);
  TDropDbParams& operator=(const TDropDbParams&);
  TDropDbParams() : database_name() {
  }

  virtual ~TDropDbParams() throw();
  std::string database_name;

  void __set_database_name(const std::string& val);

  bool operator == (const TDropDbParams & rhs) const
  {
    if (!(database_name == rhs.database_name))
      return false;
    return true;
  }
  bool operator != (const TDropDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropDbParams &a, TDropDbParams &b);

inline std::ostream& operator<<(std::ostream& out, const TDropDbParams& obj)
{
  obj.printTo(out);
  return out;
}


class TTableName {
 public:

  TTableName(const TTableName&);
  TTableName& operator=(const TTableName&);
  TTableName() : db_name(), table_name() {
  }

  virtual ~TTableName() throw();
  std::string db_name;
  std::string table_name;

  void __set_db_name(const std::string& val);

  void __set_table_name(const std::string& val);

  bool operator == (const TTableName & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TTableName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableName &a, TTableName &b);

inline std::ostream& operator<<(std::ostream& out, const TTableName& obj)
{
  obj.printTo(out);
  return out;
}


class TRandomPartitionDesc {
 public:

  TRandomPartitionDesc(const TRandomPartitionDesc&);
  TRandomPartitionDesc& operator=(const TRandomPartitionDesc&);
  TRandomPartitionDesc() {
  }

  virtual ~TRandomPartitionDesc() throw();

  bool operator == (const TRandomPartitionDesc & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TRandomPartitionDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRandomPartitionDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRandomPartitionDesc &a, TRandomPartitionDesc &b);

inline std::ostream& operator<<(std::ostream& out, const TRandomPartitionDesc& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _THashPartitionDesc__isset {
  _THashPartitionDesc__isset() : hash_type(false) {}
  bool hash_type :1;
} _THashPartitionDesc__isset;

class THashPartitionDesc {
 public:

  THashPartitionDesc(const THashPartitionDesc&);
  THashPartitionDesc& operator=(const THashPartitionDesc&);
  THashPartitionDesc() : hash_buckets(0), hash_type((THashType::type)0) {
  }

  virtual ~THashPartitionDesc() throw();
  std::vector<std::string>  column_list;
  int32_t hash_buckets;
  THashType::type hash_type;

  _THashPartitionDesc__isset __isset;

  void __set_column_list(const std::vector<std::string> & val);

  void __set_hash_buckets(const int32_t val);

  void __set_hash_type(const THashType::type val);

  bool operator == (const THashPartitionDesc & rhs) const
  {
    if (!(column_list == rhs.column_list))
      return false;
    if (!(hash_buckets == rhs.hash_buckets))
      return false;
    if (__isset.hash_type != rhs.__isset.hash_type)
      return false;
    else if (__isset.hash_type && !(hash_type == rhs.hash_type))
      return false;
    return true;
  }
  bool operator != (const THashPartitionDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THashPartitionDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THashPartitionDesc &a, THashPartitionDesc &b);

inline std::ostream& operator<<(std::ostream& out, const THashPartitionDesc& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TValue__isset {
  _TValue__isset() : value(false), max_sign(false) {}
  bool value :1;
  bool max_sign :1;
} _TValue__isset;

class TValue {
 public:

  TValue(const TValue&);
  TValue& operator=(const TValue&);
  TValue() : value(), max_sign(0) {
  }

  virtual ~TValue() throw();
  std::string value;
  bool max_sign;

  _TValue__isset __isset;

  void __set_value(const std::string& val);

  void __set_max_sign(const bool val);

  bool operator == (const TValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.max_sign != rhs.__isset.max_sign)
      return false;
    else if (__isset.max_sign && !(max_sign == rhs.max_sign))
      return false;
    return true;
  }
  bool operator != (const TValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TValue &a, TValue &b);

inline std::ostream& operator<<(std::ostream& out, const TValue& obj)
{
  obj.printTo(out);
  return out;
}


class TRangeValue {
 public:

  TRangeValue(const TRangeValue&);
  TRangeValue& operator=(const TRangeValue&);
  TRangeValue() {
  }

  virtual ~TRangeValue() throw();
  std::vector<TValue>  value_list;

  void __set_value_list(const std::vector<TValue> & val);

  bool operator == (const TRangeValue & rhs) const
  {
    if (!(value_list == rhs.value_list))
      return false;
    return true;
  }
  bool operator != (const TRangeValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRangeValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRangeValue &a, TRangeValue &b);

inline std::ostream& operator<<(std::ostream& out, const TRangeValue& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TRangePartitionDesc__isset {
  _TRangePartitionDesc__isset() : range_value(false) {}
  bool range_value :1;
} _TRangePartitionDesc__isset;

class TRangePartitionDesc {
 public:

  TRangePartitionDesc(const TRangePartitionDesc&);
  TRangePartitionDesc& operator=(const TRangePartitionDesc&);
  TRangePartitionDesc() {
  }

  virtual ~TRangePartitionDesc() throw();
  std::vector<std::string>  column_list;
  std::vector<TRangeValue>  range_value;

  _TRangePartitionDesc__isset __isset;

  void __set_column_list(const std::vector<std::string> & val);

  void __set_range_value(const std::vector<TRangeValue> & val);

  bool operator == (const TRangePartitionDesc & rhs) const
  {
    if (!(column_list == rhs.column_list))
      return false;
    if (__isset.range_value != rhs.__isset.range_value)
      return false;
    else if (__isset.range_value && !(range_value == rhs.range_value))
      return false;
    return true;
  }
  bool operator != (const TRangePartitionDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRangePartitionDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRangePartitionDesc &a, TRangePartitionDesc &b);

inline std::ostream& operator<<(std::ostream& out, const TRangePartitionDesc& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPartitionDesc__isset {
  _TPartitionDesc__isset() : hash_partition(false), range_partition(false), random_partition(false) {}
  bool hash_partition :1;
  bool range_partition :1;
  bool random_partition :1;
} _TPartitionDesc__isset;

class TPartitionDesc {
 public:

  TPartitionDesc(const TPartitionDesc&);
  TPartitionDesc& operator=(const TPartitionDesc&);
  TPartitionDesc() : type(( ::palo::TPartitionType::type)0), partition_num(0) {
  }

  virtual ~TPartitionDesc() throw();
   ::palo::TPartitionType::type type;
  int32_t partition_num;
  THashPartitionDesc hash_partition;
  TRangePartitionDesc range_partition;
  TRandomPartitionDesc random_partition;

  _TPartitionDesc__isset __isset;

  void __set_type(const  ::palo::TPartitionType::type val);

  void __set_partition_num(const int32_t val);

  void __set_hash_partition(const THashPartitionDesc& val);

  void __set_range_partition(const TRangePartitionDesc& val);

  void __set_random_partition(const TRandomPartitionDesc& val);

  bool operator == (const TPartitionDesc & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(partition_num == rhs.partition_num))
      return false;
    if (__isset.hash_partition != rhs.__isset.hash_partition)
      return false;
    else if (__isset.hash_partition && !(hash_partition == rhs.hash_partition))
      return false;
    if (__isset.range_partition != rhs.__isset.range_partition)
      return false;
    else if (__isset.range_partition && !(range_partition == rhs.range_partition))
      return false;
    if (__isset.random_partition != rhs.__isset.random_partition)
      return false;
    else if (__isset.random_partition && !(random_partition == rhs.random_partition))
      return false;
    return true;
  }
  bool operator != (const TPartitionDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPartitionDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartitionDesc &a, TPartitionDesc &b);

inline std::ostream& operator<<(std::ostream& out, const TPartitionDesc& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCreateTableParams__isset {
  _TCreateTableParams__isset() : engine_name(false), if_not_exists(false), partition_desc(false), row_format_type(false), properties(false) {}
  bool engine_name :1;
  bool if_not_exists :1;
  bool partition_desc :1;
  bool row_format_type :1;
  bool properties :1;
} _TCreateTableParams__isset;

class TCreateTableParams {
 public:

  TCreateTableParams(const TCreateTableParams&);
  TCreateTableParams& operator=(const TCreateTableParams&);
  TCreateTableParams() : engine_name(), if_not_exists(0), row_format_type() {
  }

  virtual ~TCreateTableParams() throw();
  TTableName table_name;
  std::string engine_name;
  bool if_not_exists;
  TPartitionDesc partition_desc;
  std::string row_format_type;
  std::map<std::string, std::string>  properties;

  _TCreateTableParams__isset __isset;

  void __set_table_name(const TTableName& val);

  void __set_engine_name(const std::string& val);

  void __set_if_not_exists(const bool val);

  void __set_partition_desc(const TPartitionDesc& val);

  void __set_row_format_type(const std::string& val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const TCreateTableParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.engine_name != rhs.__isset.engine_name)
      return false;
    else if (__isset.engine_name && !(engine_name == rhs.engine_name))
      return false;
    if (__isset.if_not_exists != rhs.__isset.if_not_exists)
      return false;
    else if (__isset.if_not_exists && !(if_not_exists == rhs.if_not_exists))
      return false;
    if (__isset.partition_desc != rhs.__isset.partition_desc)
      return false;
    else if (__isset.partition_desc && !(partition_desc == rhs.partition_desc))
      return false;
    if (__isset.row_format_type != rhs.__isset.row_format_type)
      return false;
    else if (__isset.row_format_type && !(row_format_type == rhs.row_format_type))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const TCreateTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateTableParams &a, TCreateTableParams &b);

inline std::ostream& operator<<(std::ostream& out, const TCreateTableParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TDropTableParams__isset {
  _TDropTableParams__isset() : if_exists(false) {}
  bool if_exists :1;
} _TDropTableParams__isset;

class TDropTableParams {
 public:

  TDropTableParams(const TDropTableParams&);
  TDropTableParams& operator=(const TDropTableParams&);
  TDropTableParams() : if_exists(0) {
  }

  virtual ~TDropTableParams() throw();
  TTableName table_name;
  bool if_exists;

  _TDropTableParams__isset __isset;

  void __set_table_name(const TTableName& val);

  void __set_if_exists(const bool val);

  bool operator == (const TDropTableParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.if_exists != rhs.__isset.if_exists)
      return false;
    else if (__isset.if_exists && !(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TDropTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropTableParams &a, TDropTableParams &b);

inline std::ostream& operator<<(std::ostream& out, const TDropTableParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCreateRollupParams__isset {
  _TCreateRollupParams__isset() : rollup_name(false), partition_desc(false) {}
  bool rollup_name :1;
  bool partition_desc :1;
} _TCreateRollupParams__isset;

class TCreateRollupParams {
 public:

  TCreateRollupParams(const TCreateRollupParams&);
  TCreateRollupParams& operator=(const TCreateRollupParams&);
  TCreateRollupParams() : rollup_name() {
  }

  virtual ~TCreateRollupParams() throw();
  TTableName table_name;
  std::vector<std::string>  column_names;
  std::string rollup_name;
  TPartitionDesc partition_desc;

  _TCreateRollupParams__isset __isset;

  void __set_table_name(const TTableName& val);

  void __set_column_names(const std::vector<std::string> & val);

  void __set_rollup_name(const std::string& val);

  void __set_partition_desc(const TPartitionDesc& val);

  bool operator == (const TCreateRollupParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_names == rhs.column_names))
      return false;
    if (__isset.rollup_name != rhs.__isset.rollup_name)
      return false;
    else if (__isset.rollup_name && !(rollup_name == rhs.rollup_name))
      return false;
    if (__isset.partition_desc != rhs.__isset.partition_desc)
      return false;
    else if (__isset.partition_desc && !(partition_desc == rhs.partition_desc))
      return false;
    return true;
  }
  bool operator != (const TCreateRollupParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateRollupParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateRollupParams &a, TCreateRollupParams &b);

inline std::ostream& operator<<(std::ostream& out, const TCreateRollupParams& obj)
{
  obj.printTo(out);
  return out;
}


class TDropRollupParams {
 public:

  TDropRollupParams(const TDropRollupParams&);
  TDropRollupParams& operator=(const TDropRollupParams&);
  TDropRollupParams() : rollup_name() {
  }

  virtual ~TDropRollupParams() throw();
  TTableName table_name;
  std::string rollup_name;

  void __set_table_name(const TTableName& val);

  void __set_rollup_name(const std::string& val);

  bool operator == (const TDropRollupParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(rollup_name == rhs.rollup_name))
      return false;
    return true;
  }
  bool operator != (const TDropRollupParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropRollupParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropRollupParams &a, TDropRollupParams &b);

inline std::ostream& operator<<(std::ostream& out, const TDropRollupParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCreateFunctionParams__isset {
  _TCreateFunctionParams__isset() : properties(false) {}
  bool properties :1;
} _TCreateFunctionParams__isset;

class TCreateFunctionParams {
 public:

  TCreateFunctionParams(const TCreateFunctionParams&);
  TCreateFunctionParams& operator=(const TCreateFunctionParams&);
  TCreateFunctionParams() : db_name(), function_name(), so_file_path() {
  }

  virtual ~TCreateFunctionParams() throw();
  std::string db_name;
  std::string function_name;
  std::vector< ::palo::TColumnType>  argument_type;
   ::palo::TColumnType return_type;
  std::string so_file_path;
  std::map<std::string, std::string>  properties;

  _TCreateFunctionParams__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_function_name(const std::string& val);

  void __set_argument_type(const std::vector< ::palo::TColumnType> & val);

  void __set_return_type(const  ::palo::TColumnType& val);

  void __set_so_file_path(const std::string& val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const TCreateFunctionParams & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(function_name == rhs.function_name))
      return false;
    if (!(argument_type == rhs.argument_type))
      return false;
    if (!(return_type == rhs.return_type))
      return false;
    if (!(so_file_path == rhs.so_file_path))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const TCreateFunctionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateFunctionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateFunctionParams &a, TCreateFunctionParams &b);

inline std::ostream& operator<<(std::ostream& out, const TCreateFunctionParams& obj)
{
  obj.printTo(out);
  return out;
}


class TDropFunctionParams {
 public:

  TDropFunctionParams(const TDropFunctionParams&);
  TDropFunctionParams& operator=(const TDropFunctionParams&);
  TDropFunctionParams() : db_name(), function_name() {
  }

  virtual ~TDropFunctionParams() throw();
  std::string db_name;
  std::string function_name;

  void __set_db_name(const std::string& val);

  void __set_function_name(const std::string& val);

  bool operator == (const TDropFunctionParams & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(function_name == rhs.function_name))
      return false;
    return true;
  }
  bool operator != (const TDropFunctionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropFunctionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropFunctionParams &a, TDropFunctionParams &b);

inline std::ostream& operator<<(std::ostream& out, const TDropFunctionParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TUserSpecification__isset {
  _TUserSpecification__isset() : host_name(false) {}
  bool host_name :1;
} _TUserSpecification__isset;

class TUserSpecification {
 public:

  TUserSpecification(const TUserSpecification&);
  TUserSpecification& operator=(const TUserSpecification&);
  TUserSpecification() : user_name(), host_name() {
  }

  virtual ~TUserSpecification() throw();
  std::string user_name;
  std::string host_name;

  _TUserSpecification__isset __isset;

  void __set_user_name(const std::string& val);

  void __set_host_name(const std::string& val);

  bool operator == (const TUserSpecification & rhs) const
  {
    if (!(user_name == rhs.user_name))
      return false;
    if (__isset.host_name != rhs.__isset.host_name)
      return false;
    else if (__isset.host_name && !(host_name == rhs.host_name))
      return false;
    return true;
  }
  bool operator != (const TUserSpecification &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUserSpecification & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUserSpecification &a, TUserSpecification &b);

inline std::ostream& operator<<(std::ostream& out, const TUserSpecification& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCreateUserParams__isset {
  _TCreateUserParams__isset() : password(false) {}
  bool password :1;
} _TCreateUserParams__isset;

class TCreateUserParams {
 public:

  TCreateUserParams(const TCreateUserParams&);
  TCreateUserParams& operator=(const TCreateUserParams&);
  TCreateUserParams() : password() {
  }

  virtual ~TCreateUserParams() throw();
  TUserSpecification user_spec;
  std::string password;

  _TCreateUserParams__isset __isset;

  void __set_user_spec(const TUserSpecification& val);

  void __set_password(const std::string& val);

  bool operator == (const TCreateUserParams & rhs) const
  {
    if (!(user_spec == rhs.user_spec))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const TCreateUserParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateUserParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateUserParams &a, TCreateUserParams &b);

inline std::ostream& operator<<(std::ostream& out, const TCreateUserParams& obj)
{
  obj.printTo(out);
  return out;
}


class TDropUserParams {
 public:

  TDropUserParams(const TDropUserParams&);
  TDropUserParams& operator=(const TDropUserParams&);
  TDropUserParams() : user_spec() {
  }

  virtual ~TDropUserParams() throw();
  std::string user_spec;

  void __set_user_spec(const std::string& val);

  bool operator == (const TDropUserParams & rhs) const
  {
    if (!(user_spec == rhs.user_spec))
      return false;
    return true;
  }
  bool operator != (const TDropUserParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropUserParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropUserParams &a, TDropUserParams &b);

inline std::ostream& operator<<(std::ostream& out, const TDropUserParams& obj)
{
  obj.printTo(out);
  return out;
}


class TSetPasswordParams {
 public:

  TSetPasswordParams(const TSetPasswordParams&);
  TSetPasswordParams& operator=(const TSetPasswordParams&);
  TSetPasswordParams() : password() {
  }

  virtual ~TSetPasswordParams() throw();
  TUserSpecification user_spec;
  std::string password;

  void __set_user_spec(const TUserSpecification& val);

  void __set_password(const std::string& val);

  bool operator == (const TSetPasswordParams & rhs) const
  {
    if (!(user_spec == rhs.user_spec))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const TSetPasswordParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSetPasswordParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSetPasswordParams &a, TSetPasswordParams &b);

inline std::ostream& operator<<(std::ostream& out, const TSetPasswordParams& obj)
{
  obj.printTo(out);
  return out;
}


class TGrantParams {
 public:

  TGrantParams(const TGrantParams&);
  TGrantParams& operator=(const TGrantParams&);
  TGrantParams() : db_name() {
  }

  virtual ~TGrantParams() throw();
  TUserSpecification user_spec;
  std::string db_name;
  std::vector<TPrivType::type>  priv_types;

  void __set_user_spec(const TUserSpecification& val);

  void __set_db_name(const std::string& val);

  void __set_priv_types(const std::vector<TPrivType::type> & val);

  bool operator == (const TGrantParams & rhs) const
  {
    if (!(user_spec == rhs.user_spec))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(priv_types == rhs.priv_types))
      return false;
    return true;
  }
  bool operator != (const TGrantParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGrantParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGrantParams &a, TGrantParams &b);

inline std::ostream& operator<<(std::ostream& out, const TGrantParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TDataSpecification__isset {
  _TDataSpecification__isset() : columns(false), column_separator(false), line_separator(false), is_negative(false) {}
  bool columns :1;
  bool column_separator :1;
  bool line_separator :1;
  bool is_negative :1;
} _TDataSpecification__isset;

class TDataSpecification {
 public:

  TDataSpecification(const TDataSpecification&);
  TDataSpecification& operator=(const TDataSpecification&);
  TDataSpecification() : column_separator(), line_separator(), is_negative(0) {
  }

  virtual ~TDataSpecification() throw();
  TTableName table_name;
  std::vector<std::string>  file_path;
  std::vector<std::string>  columns;
  std::string column_separator;
  std::string line_separator;
  bool is_negative;

  _TDataSpecification__isset __isset;

  void __set_table_name(const TTableName& val);

  void __set_file_path(const std::vector<std::string> & val);

  void __set_columns(const std::vector<std::string> & val);

  void __set_column_separator(const std::string& val);

  void __set_line_separator(const std::string& val);

  void __set_is_negative(const bool val);

  bool operator == (const TDataSpecification & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(file_path == rhs.file_path))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.column_separator != rhs.__isset.column_separator)
      return false;
    else if (__isset.column_separator && !(column_separator == rhs.column_separator))
      return false;
    if (__isset.line_separator != rhs.__isset.line_separator)
      return false;
    else if (__isset.line_separator && !(line_separator == rhs.line_separator))
      return false;
    if (__isset.is_negative != rhs.__isset.is_negative)
      return false;
    else if (__isset.is_negative && !(is_negative == rhs.is_negative))
      return false;
    return true;
  }
  bool operator != (const TDataSpecification &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataSpecification & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataSpecification &a, TDataSpecification &b);

inline std::ostream& operator<<(std::ostream& out, const TDataSpecification& obj)
{
  obj.printTo(out);
  return out;
}


class TLabelName {
 public:

  TLabelName(const TLabelName&);
  TLabelName& operator=(const TLabelName&);
  TLabelName() : db_name(), load_label() {
  }

  virtual ~TLabelName() throw();
  std::string db_name;
  std::string load_label;

  void __set_db_name(const std::string& val);

  void __set_load_label(const std::string& val);

  bool operator == (const TLabelName & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(load_label == rhs.load_label))
      return false;
    return true;
  }
  bool operator != (const TLabelName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLabelName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLabelName &a, TLabelName &b);

inline std::ostream& operator<<(std::ostream& out, const TLabelName& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TLoadParams__isset {
  _TLoadParams__isset() : properties(false) {}
  bool properties :1;
} _TLoadParams__isset;

class TLoadParams {
 public:

  TLoadParams(const TLoadParams&);
  TLoadParams& operator=(const TLoadParams&);
  TLoadParams() {
  }

  virtual ~TLoadParams() throw();
  TLabelName load_label;
  std::vector<TDataSpecification>  data_profiles;
  std::map<std::string, std::string>  properties;

  _TLoadParams__isset __isset;

  void __set_load_label(const TLabelName& val);

  void __set_data_profiles(const std::vector<TDataSpecification> & val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const TLoadParams & rhs) const
  {
    if (!(load_label == rhs.load_label))
      return false;
    if (!(data_profiles == rhs.data_profiles))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const TLoadParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLoadParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLoadParams &a, TLoadParams &b);

inline std::ostream& operator<<(std::ostream& out, const TLoadParams& obj)
{
  obj.printTo(out);
  return out;
}


class TCancelLoadParams {
 public:

  TCancelLoadParams(const TCancelLoadParams&);
  TCancelLoadParams& operator=(const TCancelLoadParams&);
  TCancelLoadParams() {
  }

  virtual ~TCancelLoadParams() throw();
  TLabelName load_label;

  void __set_load_label(const TLabelName& val);

  bool operator == (const TCancelLoadParams & rhs) const
  {
    if (!(load_label == rhs.load_label))
      return false;
    return true;
  }
  bool operator != (const TCancelLoadParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelLoadParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelLoadParams &a, TCancelLoadParams &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelLoadParams& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TMasterDdlRequest__isset {
  _TMasterDdlRequest__isset() : create_db_params(false), drop_db_params(false), drop_table_params(false), load_params(false), cancel_load_params(false), create_user_params(false), drop_user_params(false), create_rollup_params(false), drop_rollup_params(false), create_function_params(false), drop_function_params(false) {}
  bool create_db_params :1;
  bool drop_db_params :1;
  bool drop_table_params :1;
  bool load_params :1;
  bool cancel_load_params :1;
  bool create_user_params :1;
  bool drop_user_params :1;
  bool create_rollup_params :1;
  bool drop_rollup_params :1;
  bool create_function_params :1;
  bool drop_function_params :1;
} _TMasterDdlRequest__isset;

class TMasterDdlRequest {
 public:

  TMasterDdlRequest(const TMasterDdlRequest&);
  TMasterDdlRequest& operator=(const TMasterDdlRequest&);
  TMasterDdlRequest() : protocol_version((TPaloInternalServiceVersion::type)0), ddl_type((TCommonDdlType::type)0) {
  }

  virtual ~TMasterDdlRequest() throw();
  TPaloInternalServiceVersion::type protocol_version;
  TCommonDdlType::type ddl_type;
  TCreateDbParams create_db_params;
  TDropDbParams drop_db_params;
  TDropTableParams drop_table_params;
  TLoadParams load_params;
  TCancelLoadParams cancel_load_params;
  TCreateUserParams create_user_params;
  TDropUserParams drop_user_params;
  TCreateRollupParams create_rollup_params;
  TDropRollupParams drop_rollup_params;
  TCreateFunctionParams create_function_params;
  TDropFunctionParams drop_function_params;

  _TMasterDdlRequest__isset __isset;

  void __set_protocol_version(const TPaloInternalServiceVersion::type val);

  void __set_ddl_type(const TCommonDdlType::type val);

  void __set_create_db_params(const TCreateDbParams& val);

  void __set_drop_db_params(const TDropDbParams& val);

  void __set_drop_table_params(const TDropTableParams& val);

  void __set_load_params(const TLoadParams& val);

  void __set_cancel_load_params(const TCancelLoadParams& val);

  void __set_create_user_params(const TCreateUserParams& val);

  void __set_drop_user_params(const TDropUserParams& val);

  void __set_create_rollup_params(const TCreateRollupParams& val);

  void __set_drop_rollup_params(const TDropRollupParams& val);

  void __set_create_function_params(const TCreateFunctionParams& val);

  void __set_drop_function_params(const TDropFunctionParams& val);

  bool operator == (const TMasterDdlRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(ddl_type == rhs.ddl_type))
      return false;
    if (__isset.create_db_params != rhs.__isset.create_db_params)
      return false;
    else if (__isset.create_db_params && !(create_db_params == rhs.create_db_params))
      return false;
    if (__isset.drop_db_params != rhs.__isset.drop_db_params)
      return false;
    else if (__isset.drop_db_params && !(drop_db_params == rhs.drop_db_params))
      return false;
    if (__isset.drop_table_params != rhs.__isset.drop_table_params)
      return false;
    else if (__isset.drop_table_params && !(drop_table_params == rhs.drop_table_params))
      return false;
    if (__isset.load_params != rhs.__isset.load_params)
      return false;
    else if (__isset.load_params && !(load_params == rhs.load_params))
      return false;
    if (__isset.cancel_load_params != rhs.__isset.cancel_load_params)
      return false;
    else if (__isset.cancel_load_params && !(cancel_load_params == rhs.cancel_load_params))
      return false;
    if (__isset.create_user_params != rhs.__isset.create_user_params)
      return false;
    else if (__isset.create_user_params && !(create_user_params == rhs.create_user_params))
      return false;
    if (__isset.drop_user_params != rhs.__isset.drop_user_params)
      return false;
    else if (__isset.drop_user_params && !(drop_user_params == rhs.drop_user_params))
      return false;
    if (__isset.create_rollup_params != rhs.__isset.create_rollup_params)
      return false;
    else if (__isset.create_rollup_params && !(create_rollup_params == rhs.create_rollup_params))
      return false;
    if (__isset.drop_rollup_params != rhs.__isset.drop_rollup_params)
      return false;
    else if (__isset.drop_rollup_params && !(drop_rollup_params == rhs.drop_rollup_params))
      return false;
    if (__isset.create_function_params != rhs.__isset.create_function_params)
      return false;
    else if (__isset.create_function_params && !(create_function_params == rhs.create_function_params))
      return false;
    if (__isset.drop_function_params != rhs.__isset.drop_function_params)
      return false;
    else if (__isset.drop_function_params && !(drop_function_params == rhs.drop_function_params))
      return false;
    return true;
  }
  bool operator != (const TMasterDdlRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMasterDdlRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMasterDdlRequest &a, TMasterDdlRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TMasterDdlRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TMasterDdlResponse__isset {
  _TMasterDdlResponse__isset() : status(false) {}
  bool status :1;
} _TMasterDdlResponse__isset;

class TMasterDdlResponse {
 public:

  TMasterDdlResponse(const TMasterDdlResponse&);
  TMasterDdlResponse& operator=(const TMasterDdlResponse&);
  TMasterDdlResponse() : protocol_version((TPaloInternalServiceVersion::type)0), ddl_type((TCommonDdlType::type)0) {
  }

  virtual ~TMasterDdlResponse() throw();
  TPaloInternalServiceVersion::type protocol_version;
  TCommonDdlType::type ddl_type;
   ::palo::TStatus status;

  _TMasterDdlResponse__isset __isset;

  void __set_protocol_version(const TPaloInternalServiceVersion::type val);

  void __set_ddl_type(const TCommonDdlType::type val);

  void __set_status(const  ::palo::TStatus& val);

  bool operator == (const TMasterDdlResponse & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(ddl_type == rhs.ddl_type))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TMasterDdlResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMasterDdlResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMasterDdlResponse &a, TMasterDdlResponse &b);

inline std::ostream& operator<<(std::ostream& out, const TMasterDdlResponse& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
