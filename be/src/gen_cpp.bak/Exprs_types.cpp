/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Exprs_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTExprNodeTypeValues[] = {
  TExprNodeType::AGG_EXPR,
  TExprNodeType::ARITHMETIC_EXPR,
  TExprNodeType::BINARY_PRED,
  TExprNodeType::BOOL_LITERAL,
  TExprNodeType::CASE_EXPR,
  TExprNodeType::CAST_EXPR,
  TExprNodeType::COMPOUND_PRED,
  TExprNodeType::DATE_LITERAL,
  TExprNodeType::FLOAT_LITERAL,
  TExprNodeType::INT_LITERAL,
  TExprNodeType::DECIMAL_LITERAL,
  TExprNodeType::IN_PRED,
  TExprNodeType::IS_NULL_PRED,
  TExprNodeType::LIKE_PRED,
  TExprNodeType::LITERAL_PRED,
  TExprNodeType::NULL_LITERAL,
  TExprNodeType::SLOT_REF,
  TExprNodeType::STRING_LITERAL,
  TExprNodeType::TUPLE_IS_NULL_PRED,
  TExprNodeType::INFO_FUNC,
  TExprNodeType::FUNCTION_CALL,
  TExprNodeType::COMPUTE_FUNCTION_CALL,
  TExprNodeType::LARGE_INT_LITERAL
};
const char* _kTExprNodeTypeNames[] = {
  "AGG_EXPR",
  "ARITHMETIC_EXPR",
  "BINARY_PRED",
  "BOOL_LITERAL",
  "CASE_EXPR",
  "CAST_EXPR",
  "COMPOUND_PRED",
  "DATE_LITERAL",
  "FLOAT_LITERAL",
  "INT_LITERAL",
  "DECIMAL_LITERAL",
  "IN_PRED",
  "IS_NULL_PRED",
  "LIKE_PRED",
  "LITERAL_PRED",
  "NULL_LITERAL",
  "SLOT_REF",
  "STRING_LITERAL",
  "TUPLE_IS_NULL_PRED",
  "INFO_FUNC",
  "FUNCTION_CALL",
  "COMPUTE_FUNCTION_CALL",
  "LARGE_INT_LITERAL"
};
const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(23, _kTExprNodeTypeValues, _kTExprNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TAggregateExpr::~TAggregateExpr() throw() {
}


void TAggregateExpr::__set_is_merge_agg(const bool val) {
  this->is_merge_agg = val;
}

uint32_t TAggregateExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_merge_agg = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_merge_agg);
          isset_is_merge_agg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_merge_agg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregateExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAggregateExpr");

  xfer += oprot->writeFieldBegin("is_merge_agg", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_merge_agg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregateExpr &a, TAggregateExpr &b) {
  using ::std::swap;
  swap(a.is_merge_agg, b.is_merge_agg);
}

TAggregateExpr::TAggregateExpr(const TAggregateExpr& other0) {
  is_merge_agg = other0.is_merge_agg;
}
TAggregateExpr& TAggregateExpr::operator=(const TAggregateExpr& other1) {
  is_merge_agg = other1.is_merge_agg;
  return *this;
}
void TAggregateExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregateExpr(";
  out << "is_merge_agg=" << to_string(is_merge_agg);
  out << ")";
}


TBoolLiteral::~TBoolLiteral() throw() {
}


void TBoolLiteral::__set_value(const bool val) {
  this->value = val;
}

uint32_t TBoolLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBoolLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBoolLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBoolLiteral &a, TBoolLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TBoolLiteral::TBoolLiteral(const TBoolLiteral& other2) {
  value = other2.value;
}
TBoolLiteral& TBoolLiteral::operator=(const TBoolLiteral& other3) {
  value = other3.value;
  return *this;
}
void TBoolLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBoolLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TCaseExpr::~TCaseExpr() throw() {
}


void TCaseExpr::__set_has_case_expr(const bool val) {
  this->has_case_expr = val;
}

void TCaseExpr::__set_has_else_expr(const bool val) {
  this->has_else_expr = val;
}

uint32_t TCaseExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_has_case_expr = false;
  bool isset_has_else_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_case_expr);
          isset_has_case_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_else_expr);
          isset_has_else_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_has_case_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_else_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCaseExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCaseExpr");

  xfer += oprot->writeFieldBegin("has_case_expr", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->has_case_expr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_else_expr", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->has_else_expr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCaseExpr &a, TCaseExpr &b) {
  using ::std::swap;
  swap(a.has_case_expr, b.has_case_expr);
  swap(a.has_else_expr, b.has_else_expr);
}

TCaseExpr::TCaseExpr(const TCaseExpr& other4) {
  has_case_expr = other4.has_case_expr;
  has_else_expr = other4.has_else_expr;
}
TCaseExpr& TCaseExpr::operator=(const TCaseExpr& other5) {
  has_case_expr = other5.has_case_expr;
  has_else_expr = other5.has_else_expr;
  return *this;
}
void TCaseExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCaseExpr(";
  out << "has_case_expr=" << to_string(has_case_expr);
  out << ", " << "has_else_expr=" << to_string(has_else_expr);
  out << ")";
}


TDateLiteral::~TDateLiteral() throw() {
}


void TDateLiteral::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t TDateLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDateLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDateLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDateLiteral &a, TDateLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TDateLiteral::TDateLiteral(const TDateLiteral& other6) {
  value = other6.value;
}
TDateLiteral& TDateLiteral::operator=(const TDateLiteral& other7) {
  value = other7.value;
  return *this;
}
void TDateLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDateLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TFloatLiteral::~TFloatLiteral() throw() {
}


void TFloatLiteral::__set_value(const double val) {
  this->value = val;
}

uint32_t TFloatLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFloatLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFloatLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFloatLiteral &a, TFloatLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TFloatLiteral::TFloatLiteral(const TFloatLiteral& other8) {
  value = other8.value;
}
TFloatLiteral& TFloatLiteral::operator=(const TFloatLiteral& other9) {
  value = other9.value;
  return *this;
}
void TFloatLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFloatLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TDecimalLiteral::~TDecimalLiteral() throw() {
}


void TDecimalLiteral::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t TDecimalLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDecimalLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDecimalLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDecimalLiteral &a, TDecimalLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TDecimalLiteral::TDecimalLiteral(const TDecimalLiteral& other10) {
  value = other10.value;
}
TDecimalLiteral& TDecimalLiteral::operator=(const TDecimalLiteral& other11) {
  value = other11.value;
  return *this;
}
void TDecimalLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDecimalLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TIntLiteral::~TIntLiteral() throw() {
}


void TIntLiteral::__set_value(const int64_t val) {
  this->value = val;
}

uint32_t TIntLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIntLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIntLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIntLiteral &a, TIntLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TIntLiteral::TIntLiteral(const TIntLiteral& other12) {
  value = other12.value;
}
TIntLiteral& TIntLiteral::operator=(const TIntLiteral& other13) {
  value = other13.value;
  return *this;
}
void TIntLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIntLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TLargeIntLiteral::~TLargeIntLiteral() throw() {
}


void TLargeIntLiteral::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t TLargeIntLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLargeIntLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLargeIntLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLargeIntLiteral &a, TLargeIntLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TLargeIntLiteral::TLargeIntLiteral(const TLargeIntLiteral& other14) {
  value = other14.value;
}
TLargeIntLiteral& TLargeIntLiteral::operator=(const TLargeIntLiteral& other15) {
  value = other15.value;
  return *this;
}
void TLargeIntLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLargeIntLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TInPredicate::~TInPredicate() throw() {
}


void TInPredicate::__set_is_not_in(const bool val) {
  this->is_not_in = val;
}

uint32_t TInPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_not_in = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_not_in);
          isset_is_not_in = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_not_in)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TInPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInPredicate");

  xfer += oprot->writeFieldBegin("is_not_in", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_not_in);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInPredicate &a, TInPredicate &b) {
  using ::std::swap;
  swap(a.is_not_in, b.is_not_in);
}

TInPredicate::TInPredicate(const TInPredicate& other16) {
  is_not_in = other16.is_not_in;
}
TInPredicate& TInPredicate::operator=(const TInPredicate& other17) {
  is_not_in = other17.is_not_in;
  return *this;
}
void TInPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInPredicate(";
  out << "is_not_in=" << to_string(is_not_in);
  out << ")";
}


TIsNullPredicate::~TIsNullPredicate() throw() {
}


void TIsNullPredicate::__set_is_not_null(const bool val) {
  this->is_not_null = val;
}

uint32_t TIsNullPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_not_null = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_not_null);
          isset_is_not_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_not_null)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIsNullPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIsNullPredicate");

  xfer += oprot->writeFieldBegin("is_not_null", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_not_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIsNullPredicate &a, TIsNullPredicate &b) {
  using ::std::swap;
  swap(a.is_not_null, b.is_not_null);
}

TIsNullPredicate::TIsNullPredicate(const TIsNullPredicate& other18) {
  is_not_null = other18.is_not_null;
}
TIsNullPredicate& TIsNullPredicate::operator=(const TIsNullPredicate& other19) {
  is_not_null = other19.is_not_null;
  return *this;
}
void TIsNullPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIsNullPredicate(";
  out << "is_not_null=" << to_string(is_not_null);
  out << ")";
}


TLikePredicate::~TLikePredicate() throw() {
}


void TLikePredicate::__set_escape_char(const std::string& val) {
  this->escape_char = val;
}

uint32_t TLikePredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_escape_char = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape_char);
          isset_escape_char = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_escape_char)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLikePredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLikePredicate");

  xfer += oprot->writeFieldBegin("escape_char", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->escape_char);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLikePredicate &a, TLikePredicate &b) {
  using ::std::swap;
  swap(a.escape_char, b.escape_char);
}

TLikePredicate::TLikePredicate(const TLikePredicate& other20) {
  escape_char = other20.escape_char;
}
TLikePredicate& TLikePredicate::operator=(const TLikePredicate& other21) {
  escape_char = other21.escape_char;
  return *this;
}
void TLikePredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLikePredicate(";
  out << "escape_char=" << to_string(escape_char);
  out << ")";
}


TLiteralPredicate::~TLiteralPredicate() throw() {
}


void TLiteralPredicate::__set_value(const bool val) {
  this->value = val;
}

void TLiteralPredicate::__set_is_null(const bool val) {
  this->is_null = val;
}

uint32_t TLiteralPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_is_null = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          isset_is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_null)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLiteralPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLiteralPredicate");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLiteralPredicate &a, TLiteralPredicate &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.is_null, b.is_null);
}

TLiteralPredicate::TLiteralPredicate(const TLiteralPredicate& other22) {
  value = other22.value;
  is_null = other22.is_null;
}
TLiteralPredicate& TLiteralPredicate::operator=(const TLiteralPredicate& other23) {
  value = other23.value;
  is_null = other23.is_null;
  return *this;
}
void TLiteralPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLiteralPredicate(";
  out << "value=" << to_string(value);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TTupleIsNullPredicate::~TTupleIsNullPredicate() throw() {
}


void TTupleIsNullPredicate::__set_tuple_ids(const std::vector< ::palo::TTupleId> & val) {
  this->tuple_ids = val;
}

uint32_t TTupleIsNullPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tuple_ids.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->tuple_ids.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += iprot->readI32(this->tuple_ids[_i28]);
            }
            xfer += iprot->readListEnd();
          }
          isset_tuple_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTupleIsNullPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTupleIsNullPredicate");

  xfer += oprot->writeFieldBegin("tuple_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->tuple_ids.size()));
    std::vector< ::palo::TTupleId> ::const_iterator _iter29;
    for (_iter29 = this->tuple_ids.begin(); _iter29 != this->tuple_ids.end(); ++_iter29)
    {
      xfer += oprot->writeI32((*_iter29));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b) {
  using ::std::swap;
  swap(a.tuple_ids, b.tuple_ids);
}

TTupleIsNullPredicate::TTupleIsNullPredicate(const TTupleIsNullPredicate& other30) {
  tuple_ids = other30.tuple_ids;
}
TTupleIsNullPredicate& TTupleIsNullPredicate::operator=(const TTupleIsNullPredicate& other31) {
  tuple_ids = other31.tuple_ids;
  return *this;
}
void TTupleIsNullPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTupleIsNullPredicate(";
  out << "tuple_ids=" << to_string(tuple_ids);
  out << ")";
}


TSlotRef::~TSlotRef() throw() {
}


void TSlotRef::__set_slot_id(const  ::palo::TSlotId val) {
  this->slot_id = val;
}

void TSlotRef::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

uint32_t TSlotRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_slot_id = false;
  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slot_id);
          isset_slot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_slot_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSlotRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSlotRef");

  xfer += oprot->writeFieldBegin("slot_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->slot_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSlotRef &a, TSlotRef &b) {
  using ::std::swap;
  swap(a.slot_id, b.slot_id);
  swap(a.tuple_id, b.tuple_id);
}

TSlotRef::TSlotRef(const TSlotRef& other32) {
  slot_id = other32.slot_id;
  tuple_id = other32.tuple_id;
}
TSlotRef& TSlotRef::operator=(const TSlotRef& other33) {
  slot_id = other33.slot_id;
  tuple_id = other33.tuple_id;
  return *this;
}
void TSlotRef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSlotRef(";
  out << "slot_id=" << to_string(slot_id);
  out << ", " << "tuple_id=" << to_string(tuple_id);
  out << ")";
}


TStringLiteral::~TStringLiteral() throw() {
}


void TStringLiteral::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t TStringLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStringLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringLiteral");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringLiteral &a, TStringLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TStringLiteral::TStringLiteral(const TStringLiteral& other34) {
  value = other34.value;
}
TStringLiteral& TStringLiteral::operator=(const TStringLiteral& other35) {
  value = other35.value;
  return *this;
}
void TStringLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TInfoFunc::~TInfoFunc() throw() {
}


void TInfoFunc::__set_int_value(const int64_t val) {
  this->int_value = val;
}

void TInfoFunc::__set_str_value(const std::string& val) {
  this->str_value = val;
}

uint32_t TInfoFunc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_int_value = false;
  bool isset_str_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_value);
          isset_int_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_value);
          isset_str_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_int_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_str_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TInfoFunc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInfoFunc");

  xfer += oprot->writeFieldBegin("int_value", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->int_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->str_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInfoFunc &a, TInfoFunc &b) {
  using ::std::swap;
  swap(a.int_value, b.int_value);
  swap(a.str_value, b.str_value);
}

TInfoFunc::TInfoFunc(const TInfoFunc& other36) {
  int_value = other36.int_value;
  str_value = other36.str_value;
}
TInfoFunc& TInfoFunc::operator=(const TInfoFunc& other37) {
  int_value = other37.int_value;
  str_value = other37.str_value;
  return *this;
}
void TInfoFunc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInfoFunc(";
  out << "int_value=" << to_string(int_value);
  out << ", " << "str_value=" << to_string(str_value);
  out << ")";
}


TFunctionCallExpr::~TFunctionCallExpr() throw() {
}


void TFunctionCallExpr::__set_fn(const  ::palo::TFunction& val) {
  this->fn = val;
}

void TFunctionCallExpr::__set_vararg_start_idx(const int32_t val) {
  this->vararg_start_idx = val;
__isset.vararg_start_idx = true;
}

uint32_t TFunctionCallExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fn = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          isset_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vararg_start_idx);
          this->__isset.vararg_start_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fn)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunctionCallExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFunctionCallExpr");

  xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fn.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.vararg_start_idx) {
    xfer += oprot->writeFieldBegin("vararg_start_idx", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->vararg_start_idx);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunctionCallExpr &a, TFunctionCallExpr &b) {
  using ::std::swap;
  swap(a.fn, b.fn);
  swap(a.vararg_start_idx, b.vararg_start_idx);
  swap(a.__isset, b.__isset);
}

TFunctionCallExpr::TFunctionCallExpr(const TFunctionCallExpr& other38) {
  fn = other38.fn;
  vararg_start_idx = other38.vararg_start_idx;
  __isset = other38.__isset;
}
TFunctionCallExpr& TFunctionCallExpr::operator=(const TFunctionCallExpr& other39) {
  fn = other39.fn;
  vararg_start_idx = other39.vararg_start_idx;
  __isset = other39.__isset;
  return *this;
}
void TFunctionCallExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFunctionCallExpr(";
  out << "fn=" << to_string(fn);
  out << ", " << "vararg_start_idx="; (__isset.vararg_start_idx ? (out << to_string(vararg_start_idx)) : (out << "<null>"));
  out << ")";
}


TExprNode::~TExprNode() throw() {
}


void TExprNode::__set_node_type(const TExprNodeType::type val) {
  this->node_type = val;
}

void TExprNode::__set_type(const  ::palo::TTypeDesc& val) {
  this->type = val;
}

void TExprNode::__set_opcode(const  ::TExprOpcode::type val) {
  this->opcode = val;
__isset.opcode = true;
}

void TExprNode::__set_num_children(const int32_t val) {
  this->num_children = val;
}

void TExprNode::__set_agg_expr(const TAggregateExpr& val) {
  this->agg_expr = val;
__isset.agg_expr = true;
}

void TExprNode::__set_bool_literal(const TBoolLiteral& val) {
  this->bool_literal = val;
__isset.bool_literal = true;
}

void TExprNode::__set_case_expr(const TCaseExpr& val) {
  this->case_expr = val;
__isset.case_expr = true;
}

void TExprNode::__set_date_literal(const TDateLiteral& val) {
  this->date_literal = val;
__isset.date_literal = true;
}

void TExprNode::__set_float_literal(const TFloatLiteral& val) {
  this->float_literal = val;
__isset.float_literal = true;
}

void TExprNode::__set_int_literal(const TIntLiteral& val) {
  this->int_literal = val;
__isset.int_literal = true;
}

void TExprNode::__set_in_predicate(const TInPredicate& val) {
  this->in_predicate = val;
__isset.in_predicate = true;
}

void TExprNode::__set_is_null_pred(const TIsNullPredicate& val) {
  this->is_null_pred = val;
__isset.is_null_pred = true;
}

void TExprNode::__set_like_pred(const TLikePredicate& val) {
  this->like_pred = val;
__isset.like_pred = true;
}

void TExprNode::__set_literal_pred(const TLiteralPredicate& val) {
  this->literal_pred = val;
__isset.literal_pred = true;
}

void TExprNode::__set_slot_ref(const TSlotRef& val) {
  this->slot_ref = val;
__isset.slot_ref = true;
}

void TExprNode::__set_string_literal(const TStringLiteral& val) {
  this->string_literal = val;
__isset.string_literal = true;
}

void TExprNode::__set_tuple_is_null_pred(const TTupleIsNullPredicate& val) {
  this->tuple_is_null_pred = val;
__isset.tuple_is_null_pred = true;
}

void TExprNode::__set_info_func(const TInfoFunc& val) {
  this->info_func = val;
__isset.info_func = true;
}

void TExprNode::__set_decimal_literal(const TDecimalLiteral& val) {
  this->decimal_literal = val;
__isset.decimal_literal = true;
}

void TExprNode::__set_output_scale(const int32_t val) {
  this->output_scale = val;
}

void TExprNode::__set_fn_call_expr(const TFunctionCallExpr& val) {
  this->fn_call_expr = val;
__isset.fn_call_expr = true;
}

void TExprNode::__set_large_int_literal(const TLargeIntLiteral& val) {
  this->large_int_literal = val;
__isset.large_int_literal = true;
}

void TExprNode::__set_output_column(const int32_t val) {
  this->output_column = val;
__isset.output_column = true;
}

void TExprNode::__set_output_type(const  ::palo::TColumnType& val) {
  this->output_type = val;
__isset.output_type = true;
}

void TExprNode::__set_vector_opcode(const  ::TExprOpcode::type val) {
  this->vector_opcode = val;
__isset.vector_opcode = true;
}

void TExprNode::__set_fn(const  ::palo::TFunction& val) {
  this->fn = val;
__isset.fn = true;
}

void TExprNode::__set_vararg_start_idx(const int32_t val) {
  this->vararg_start_idx = val;
__isset.vararg_start_idx = true;
}

void TExprNode::__set_child_type(const  ::palo::TPrimitiveType::type val) {
  this->child_type = val;
__isset.child_type = true;
}

uint32_t TExprNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_type = false;
  bool isset_type = false;
  bool isset_num_children = false;
  bool isset_output_scale = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast40;
          xfer += iprot->readI32(ecast40);
          this->node_type = (TExprNodeType::type)ecast40;
          isset_node_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast41;
          xfer += iprot->readI32(ecast41);
          this->opcode = ( ::TExprOpcode::type)ecast41;
          this->__isset.opcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agg_expr.read(iprot);
          this->__isset.agg_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bool_literal.read(iprot);
          this->__isset.bool_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->case_expr.read(iprot);
          this->__isset.case_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->date_literal.read(iprot);
          this->__isset.date_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->float_literal.read(iprot);
          this->__isset.float_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->int_literal.read(iprot);
          this->__isset.int_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->in_predicate.read(iprot);
          this->__isset.in_predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->is_null_pred.read(iprot);
          this->__isset.is_null_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->like_pred.read(iprot);
          this->__isset.like_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->literal_pred.read(iprot);
          this->__isset.literal_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slot_ref.read(iprot);
          this->__isset.slot_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->string_literal.read(iprot);
          this->__isset.string_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tuple_is_null_pred.read(iprot);
          this->__isset.tuple_is_null_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info_func.read(iprot);
          this->__isset.info_func = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->decimal_literal.read(iprot);
          this->__isset.decimal_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_scale);
          isset_output_scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn_call_expr.read(iprot);
          this->__isset.fn_call_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->large_int_literal.read(iprot);
          this->__isset.large_int_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_column);
          this->__isset.output_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->output_type.read(iprot);
          this->__isset.output_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->vector_opcode = ( ::TExprOpcode::type)ecast42;
          this->__isset.vector_opcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          this->__isset.fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vararg_start_idx);
          this->__isset.vararg_start_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast43;
          xfer += iprot->readI32(ecast43);
          this->child_type = ( ::palo::TPrimitiveType::type)ecast43;
          this->__isset.child_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_scale)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExprNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExprNode");

  xfer += oprot->writeFieldBegin("node_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->node_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.opcode) {
    xfer += oprot->writeFieldBegin("opcode", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->opcode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agg_expr) {
    xfer += oprot->writeFieldBegin("agg_expr", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->agg_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bool_literal) {
    xfer += oprot->writeFieldBegin("bool_literal", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->bool_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.case_expr) {
    xfer += oprot->writeFieldBegin("case_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->case_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.date_literal) {
    xfer += oprot->writeFieldBegin("date_literal", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->date_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.float_literal) {
    xfer += oprot->writeFieldBegin("float_literal", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->float_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.int_literal) {
    xfer += oprot->writeFieldBegin("int_literal", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->int_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_predicate) {
    xfer += oprot->writeFieldBegin("in_predicate", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->in_predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_null_pred) {
    xfer += oprot->writeFieldBegin("is_null_pred", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->is_null_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.like_pred) {
    xfer += oprot->writeFieldBegin("like_pred", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->like_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.literal_pred) {
    xfer += oprot->writeFieldBegin("literal_pred", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->literal_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slot_ref) {
    xfer += oprot->writeFieldBegin("slot_ref", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->slot_ref.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_literal) {
    xfer += oprot->writeFieldBegin("string_literal", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->string_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tuple_is_null_pred) {
    xfer += oprot->writeFieldBegin("tuple_is_null_pred", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->tuple_is_null_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.info_func) {
    xfer += oprot->writeFieldBegin("info_func", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->info_func.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.decimal_literal) {
    xfer += oprot->writeFieldBegin("decimal_literal", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->decimal_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("output_scale", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->output_scale);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fn_call_expr) {
    xfer += oprot->writeFieldBegin("fn_call_expr", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->fn_call_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.large_int_literal) {
    xfer += oprot->writeFieldBegin("large_int_literal", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->large_int_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_column) {
    xfer += oprot->writeFieldBegin("output_column", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->output_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_type) {
    xfer += oprot->writeFieldBegin("output_type", ::apache::thrift::protocol::T_STRUCT, 24);
    xfer += this->output_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vector_opcode) {
    xfer += oprot->writeFieldBegin("vector_opcode", ::apache::thrift::protocol::T_I32, 25);
    xfer += oprot->writeI32((int32_t)this->vector_opcode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fn) {
    xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 26);
    xfer += this->fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vararg_start_idx) {
    xfer += oprot->writeFieldBegin("vararg_start_idx", ::apache::thrift::protocol::T_I32, 27);
    xfer += oprot->writeI32(this->vararg_start_idx);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_type) {
    xfer += oprot->writeFieldBegin("child_type", ::apache::thrift::protocol::T_I32, 28);
    xfer += oprot->writeI32((int32_t)this->child_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExprNode &a, TExprNode &b) {
  using ::std::swap;
  swap(a.node_type, b.node_type);
  swap(a.type, b.type);
  swap(a.opcode, b.opcode);
  swap(a.num_children, b.num_children);
  swap(a.agg_expr, b.agg_expr);
  swap(a.bool_literal, b.bool_literal);
  swap(a.case_expr, b.case_expr);
  swap(a.date_literal, b.date_literal);
  swap(a.float_literal, b.float_literal);
  swap(a.int_literal, b.int_literal);
  swap(a.in_predicate, b.in_predicate);
  swap(a.is_null_pred, b.is_null_pred);
  swap(a.like_pred, b.like_pred);
  swap(a.literal_pred, b.literal_pred);
  swap(a.slot_ref, b.slot_ref);
  swap(a.string_literal, b.string_literal);
  swap(a.tuple_is_null_pred, b.tuple_is_null_pred);
  swap(a.info_func, b.info_func);
  swap(a.decimal_literal, b.decimal_literal);
  swap(a.output_scale, b.output_scale);
  swap(a.fn_call_expr, b.fn_call_expr);
  swap(a.large_int_literal, b.large_int_literal);
  swap(a.output_column, b.output_column);
  swap(a.output_type, b.output_type);
  swap(a.vector_opcode, b.vector_opcode);
  swap(a.fn, b.fn);
  swap(a.vararg_start_idx, b.vararg_start_idx);
  swap(a.child_type, b.child_type);
  swap(a.__isset, b.__isset);
}

TExprNode::TExprNode(const TExprNode& other44) {
  node_type = other44.node_type;
  type = other44.type;
  opcode = other44.opcode;
  num_children = other44.num_children;
  agg_expr = other44.agg_expr;
  bool_literal = other44.bool_literal;
  case_expr = other44.case_expr;
  date_literal = other44.date_literal;
  float_literal = other44.float_literal;
  int_literal = other44.int_literal;
  in_predicate = other44.in_predicate;
  is_null_pred = other44.is_null_pred;
  like_pred = other44.like_pred;
  literal_pred = other44.literal_pred;
  slot_ref = other44.slot_ref;
  string_literal = other44.string_literal;
  tuple_is_null_pred = other44.tuple_is_null_pred;
  info_func = other44.info_func;
  decimal_literal = other44.decimal_literal;
  output_scale = other44.output_scale;
  fn_call_expr = other44.fn_call_expr;
  large_int_literal = other44.large_int_literal;
  output_column = other44.output_column;
  output_type = other44.output_type;
  vector_opcode = other44.vector_opcode;
  fn = other44.fn;
  vararg_start_idx = other44.vararg_start_idx;
  child_type = other44.child_type;
  __isset = other44.__isset;
}
TExprNode& TExprNode::operator=(const TExprNode& other45) {
  node_type = other45.node_type;
  type = other45.type;
  opcode = other45.opcode;
  num_children = other45.num_children;
  agg_expr = other45.agg_expr;
  bool_literal = other45.bool_literal;
  case_expr = other45.case_expr;
  date_literal = other45.date_literal;
  float_literal = other45.float_literal;
  int_literal = other45.int_literal;
  in_predicate = other45.in_predicate;
  is_null_pred = other45.is_null_pred;
  like_pred = other45.like_pred;
  literal_pred = other45.literal_pred;
  slot_ref = other45.slot_ref;
  string_literal = other45.string_literal;
  tuple_is_null_pred = other45.tuple_is_null_pred;
  info_func = other45.info_func;
  decimal_literal = other45.decimal_literal;
  output_scale = other45.output_scale;
  fn_call_expr = other45.fn_call_expr;
  large_int_literal = other45.large_int_literal;
  output_column = other45.output_column;
  output_type = other45.output_type;
  vector_opcode = other45.vector_opcode;
  fn = other45.fn;
  vararg_start_idx = other45.vararg_start_idx;
  child_type = other45.child_type;
  __isset = other45.__isset;
  return *this;
}
void TExprNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExprNode(";
  out << "node_type=" << to_string(node_type);
  out << ", " << "type=" << to_string(type);
  out << ", " << "opcode="; (__isset.opcode ? (out << to_string(opcode)) : (out << "<null>"));
  out << ", " << "num_children=" << to_string(num_children);
  out << ", " << "agg_expr="; (__isset.agg_expr ? (out << to_string(agg_expr)) : (out << "<null>"));
  out << ", " << "bool_literal="; (__isset.bool_literal ? (out << to_string(bool_literal)) : (out << "<null>"));
  out << ", " << "case_expr="; (__isset.case_expr ? (out << to_string(case_expr)) : (out << "<null>"));
  out << ", " << "date_literal="; (__isset.date_literal ? (out << to_string(date_literal)) : (out << "<null>"));
  out << ", " << "float_literal="; (__isset.float_literal ? (out << to_string(float_literal)) : (out << "<null>"));
  out << ", " << "int_literal="; (__isset.int_literal ? (out << to_string(int_literal)) : (out << "<null>"));
  out << ", " << "in_predicate="; (__isset.in_predicate ? (out << to_string(in_predicate)) : (out << "<null>"));
  out << ", " << "is_null_pred="; (__isset.is_null_pred ? (out << to_string(is_null_pred)) : (out << "<null>"));
  out << ", " << "like_pred="; (__isset.like_pred ? (out << to_string(like_pred)) : (out << "<null>"));
  out << ", " << "literal_pred="; (__isset.literal_pred ? (out << to_string(literal_pred)) : (out << "<null>"));
  out << ", " << "slot_ref="; (__isset.slot_ref ? (out << to_string(slot_ref)) : (out << "<null>"));
  out << ", " << "string_literal="; (__isset.string_literal ? (out << to_string(string_literal)) : (out << "<null>"));
  out << ", " << "tuple_is_null_pred="; (__isset.tuple_is_null_pred ? (out << to_string(tuple_is_null_pred)) : (out << "<null>"));
  out << ", " << "info_func="; (__isset.info_func ? (out << to_string(info_func)) : (out << "<null>"));
  out << ", " << "decimal_literal="; (__isset.decimal_literal ? (out << to_string(decimal_literal)) : (out << "<null>"));
  out << ", " << "output_scale=" << to_string(output_scale);
  out << ", " << "fn_call_expr="; (__isset.fn_call_expr ? (out << to_string(fn_call_expr)) : (out << "<null>"));
  out << ", " << "large_int_literal="; (__isset.large_int_literal ? (out << to_string(large_int_literal)) : (out << "<null>"));
  out << ", " << "output_column="; (__isset.output_column ? (out << to_string(output_column)) : (out << "<null>"));
  out << ", " << "output_type="; (__isset.output_type ? (out << to_string(output_type)) : (out << "<null>"));
  out << ", " << "vector_opcode="; (__isset.vector_opcode ? (out << to_string(vector_opcode)) : (out << "<null>"));
  out << ", " << "fn="; (__isset.fn ? (out << to_string(fn)) : (out << "<null>"));
  out << ", " << "vararg_start_idx="; (__isset.vararg_start_idx ? (out << to_string(vararg_start_idx)) : (out << "<null>"));
  out << ", " << "child_type="; (__isset.child_type ? (out << to_string(child_type)) : (out << "<null>"));
  out << ")";
}


TExpr::~TExpr() throw() {
}


void TExpr::__set_nodes(const std::vector<TExprNode> & val) {
  this->nodes = val;
}

uint32_t TExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->nodes.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += this->nodes[_i50].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExpr");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TExprNode> ::const_iterator _iter51;
    for (_iter51 = this->nodes.begin(); _iter51 != this->nodes.end(); ++_iter51)
    {
      xfer += (*_iter51).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExpr &a, TExpr &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

TExpr::TExpr(const TExpr& other52) {
  nodes = other52.nodes;
}
TExpr& TExpr::operator=(const TExpr& other53) {
  nodes = other53.nodes;
  return *this;
}
void TExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExpr(";
  out << "nodes=" << to_string(nodes);
  out << ")";
}

} // namespace
