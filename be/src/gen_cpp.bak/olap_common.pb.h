// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: olap_common.proto

#ifndef PROTOBUF_olap_5fcommon_2eproto__INCLUDED
#define PROTOBUF_olap_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace palo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_olap_5fcommon_2eproto();
void protobuf_AssignDesc_olap_5fcommon_2eproto();
void protobuf_ShutdownFile_olap_5fcommon_2eproto();

class ColumnMessage;

enum CompressKind {
  COMPRESS_NONE = 0,
  COMPRESS_LZO = 1,
  COMPRESS_LZ4 = 2
};
bool CompressKind_IsValid(int value);
const CompressKind CompressKind_MIN = COMPRESS_NONE;
const CompressKind CompressKind_MAX = COMPRESS_LZ4;
const int CompressKind_ARRAYSIZE = CompressKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompressKind_descriptor();
inline const ::std::string& CompressKind_Name(CompressKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompressKind_descriptor(), value);
}
inline bool CompressKind_Parse(
    const ::std::string& name, CompressKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompressKind>(
    CompressKind_descriptor(), name, value);
}
// ===================================================================

class ColumnMessage : public ::google::protobuf::Message {
 public:
  ColumnMessage();
  virtual ~ColumnMessage();

  ColumnMessage(const ColumnMessage& from);

  inline ColumnMessage& operator=(const ColumnMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnMessage& default_instance();

  void Swap(ColumnMessage* other);

  // implements Message ----------------------------------------------

  ColumnMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnMessage& from);
  void MergeFrom(const ColumnMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string aggregation = 3;
  inline bool has_aggregation() const;
  inline void clear_aggregation();
  static const int kAggregationFieldNumber = 3;
  inline const ::std::string& aggregation() const;
  inline void set_aggregation(const ::std::string& value);
  inline void set_aggregation(const char* value);
  inline void set_aggregation(const char* value, size_t size);
  inline ::std::string* mutable_aggregation();
  inline ::std::string* release_aggregation();
  inline void set_allocated_aggregation(::std::string* aggregation);

  // required uint32 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // required bool is_key = 5;
  inline bool has_is_key() const;
  inline void clear_is_key();
  static const int kIsKeyFieldNumber = 5;
  inline bool is_key() const;
  inline void set_is_key(bool value);

  // optional string default_value = 6;
  inline bool has_default_value() const;
  inline void clear_default_value();
  static const int kDefaultValueFieldNumber = 6;
  inline const ::std::string& default_value() const;
  inline void set_default_value(const ::std::string& value);
  inline void set_default_value(const char* value);
  inline void set_default_value(const char* value, size_t size);
  inline ::std::string* mutable_default_value();
  inline ::std::string* release_default_value();
  inline void set_allocated_default_value(::std::string* default_value);

  // optional string referenced_column = 7;
  inline bool has_referenced_column() const;
  inline void clear_referenced_column();
  static const int kReferencedColumnFieldNumber = 7;
  inline const ::std::string& referenced_column() const;
  inline void set_referenced_column(const ::std::string& value);
  inline void set_referenced_column(const char* value);
  inline void set_referenced_column(const char* value, size_t size);
  inline ::std::string* mutable_referenced_column();
  inline ::std::string* release_referenced_column();
  inline void set_allocated_referenced_column(::std::string* referenced_column);

  // optional uint32 index_length = 8;
  inline bool has_index_length() const;
  inline void clear_index_length();
  static const int kIndexLengthFieldNumber = 8;
  inline ::google::protobuf::uint32 index_length() const;
  inline void set_index_length(::google::protobuf::uint32 value);

  // optional uint32 precision = 9 [default = 27];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 9;
  inline ::google::protobuf::uint32 precision() const;
  inline void set_precision(::google::protobuf::uint32 value);

  // optional uint32 frac = 10 [default = 9];
  inline bool has_frac() const;
  inline void clear_frac();
  static const int kFracFieldNumber = 10;
  inline ::google::protobuf::uint32 frac() const;
  inline void set_frac(::google::protobuf::uint32 value);

  // optional bool is_allow_null = 11 [default = false];
  inline bool has_is_allow_null() const;
  inline void clear_is_allow_null();
  static const int kIsAllowNullFieldNumber = 11;
  inline bool is_allow_null() const;
  inline void set_is_allow_null(bool value);

  // optional uint32 unique_id = 12;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 12;
  inline ::google::protobuf::uint32 unique_id() const;
  inline void set_unique_id(::google::protobuf::uint32 value);

  // repeated uint32 sub_column = 13;
  inline int sub_column_size() const;
  inline void clear_sub_column();
  static const int kSubColumnFieldNumber = 13;
  inline ::google::protobuf::uint32 sub_column(int index) const;
  inline void set_sub_column(int index, ::google::protobuf::uint32 value);
  inline void add_sub_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      sub_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_sub_column();

  // optional bool is_root_column = 14 [default = false];
  inline bool has_is_root_column() const;
  inline void clear_is_root_column();
  static const int kIsRootColumnFieldNumber = 14;
  inline bool is_root_column() const;
  inline void set_is_root_column(bool value);

  // optional bool is_bf_column = 15 [default = false];
  inline bool has_is_bf_column() const;
  inline void clear_is_bf_column();
  static const int kIsBfColumnFieldNumber = 15;
  inline bool is_bf_column() const;
  inline void set_is_bf_column(bool value);

  // @@protoc_insertion_point(class_scope:palo.ColumnMessage)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_aggregation();
  inline void clear_has_aggregation();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_is_key();
  inline void clear_has_is_key();
  inline void set_has_default_value();
  inline void clear_has_default_value();
  inline void set_has_referenced_column();
  inline void clear_has_referenced_column();
  inline void set_has_index_length();
  inline void clear_has_index_length();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_frac();
  inline void clear_has_frac();
  inline void set_has_is_allow_null();
  inline void clear_has_is_allow_null();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  inline void set_has_is_root_column();
  inline void clear_has_is_root_column();
  inline void set_has_is_bf_column();
  inline void clear_has_is_bf_column();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* type_;
  ::std::string* aggregation_;
  ::std::string* default_value_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::uint32 index_length_;
  ::std::string* referenced_column_;
  ::google::protobuf::uint32 precision_;
  ::google::protobuf::uint32 frac_;
  bool is_key_;
  bool is_allow_null_;
  bool is_root_column_;
  bool is_bf_column_;
  ::google::protobuf::uint32 unique_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > sub_column_;
  friend void  protobuf_AddDesc_olap_5fcommon_2eproto();
  friend void protobuf_AssignDesc_olap_5fcommon_2eproto();
  friend void protobuf_ShutdownFile_olap_5fcommon_2eproto();

  void InitAsDefaultInstance();
  static ColumnMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ColumnMessage

// required string name = 1;
inline bool ColumnMessage::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnMessage::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ColumnMessage::name() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.name)
  return *name_;
}
inline void ColumnMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.name)
}
inline void ColumnMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:palo.ColumnMessage.name)
}
inline void ColumnMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palo.ColumnMessage.name)
}
inline ::std::string* ColumnMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:palo.ColumnMessage.name)
  return name_;
}
inline ::std::string* ColumnMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnMessage::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:palo.ColumnMessage.name)
}

// required string type = 2;
inline bool ColumnMessage::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnMessage::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnMessage::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ColumnMessage::type() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.type)
  return *type_;
}
inline void ColumnMessage::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.type)
}
inline void ColumnMessage::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:palo.ColumnMessage.type)
}
inline void ColumnMessage::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palo.ColumnMessage.type)
}
inline ::std::string* ColumnMessage::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:palo.ColumnMessage.type)
  return type_;
}
inline ::std::string* ColumnMessage::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnMessage::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:palo.ColumnMessage.type)
}

// required string aggregation = 3;
inline bool ColumnMessage::has_aggregation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnMessage::set_has_aggregation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnMessage::clear_has_aggregation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnMessage::clear_aggregation() {
  if (aggregation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aggregation_->clear();
  }
  clear_has_aggregation();
}
inline const ::std::string& ColumnMessage::aggregation() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.aggregation)
  return *aggregation_;
}
inline void ColumnMessage::set_aggregation(const ::std::string& value) {
  set_has_aggregation();
  if (aggregation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aggregation_ = new ::std::string;
  }
  aggregation_->assign(value);
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.aggregation)
}
inline void ColumnMessage::set_aggregation(const char* value) {
  set_has_aggregation();
  if (aggregation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aggregation_ = new ::std::string;
  }
  aggregation_->assign(value);
  // @@protoc_insertion_point(field_set_char:palo.ColumnMessage.aggregation)
}
inline void ColumnMessage::set_aggregation(const char* value, size_t size) {
  set_has_aggregation();
  if (aggregation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aggregation_ = new ::std::string;
  }
  aggregation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palo.ColumnMessage.aggregation)
}
inline ::std::string* ColumnMessage::mutable_aggregation() {
  set_has_aggregation();
  if (aggregation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aggregation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:palo.ColumnMessage.aggregation)
  return aggregation_;
}
inline ::std::string* ColumnMessage::release_aggregation() {
  clear_has_aggregation();
  if (aggregation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = aggregation_;
    aggregation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnMessage::set_allocated_aggregation(::std::string* aggregation) {
  if (aggregation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aggregation_;
  }
  if (aggregation) {
    set_has_aggregation();
    aggregation_ = aggregation;
  } else {
    clear_has_aggregation();
    aggregation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:palo.ColumnMessage.aggregation)
}

// required uint32 length = 4;
inline bool ColumnMessage::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnMessage::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnMessage::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 ColumnMessage::length() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.length)
  return length_;
}
inline void ColumnMessage::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.length)
}

// required bool is_key = 5;
inline bool ColumnMessage::has_is_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ColumnMessage::set_has_is_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ColumnMessage::clear_has_is_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ColumnMessage::clear_is_key() {
  is_key_ = false;
  clear_has_is_key();
}
inline bool ColumnMessage::is_key() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.is_key)
  return is_key_;
}
inline void ColumnMessage::set_is_key(bool value) {
  set_has_is_key();
  is_key_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.is_key)
}

// optional string default_value = 6;
inline bool ColumnMessage::has_default_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ColumnMessage::set_has_default_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ColumnMessage::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ColumnMessage::clear_default_value() {
  if (default_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_value_->clear();
  }
  clear_has_default_value();
}
inline const ::std::string& ColumnMessage::default_value() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.default_value)
  return *default_value_;
}
inline void ColumnMessage::set_default_value(const ::std::string& value) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(value);
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.default_value)
}
inline void ColumnMessage::set_default_value(const char* value) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:palo.ColumnMessage.default_value)
}
inline void ColumnMessage::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palo.ColumnMessage.default_value)
}
inline ::std::string* ColumnMessage::mutable_default_value() {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:palo.ColumnMessage.default_value)
  return default_value_;
}
inline ::std::string* ColumnMessage::release_default_value() {
  clear_has_default_value();
  if (default_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = default_value_;
    default_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnMessage::set_allocated_default_value(::std::string* default_value) {
  if (default_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete default_value_;
  }
  if (default_value) {
    set_has_default_value();
    default_value_ = default_value;
  } else {
    clear_has_default_value();
    default_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:palo.ColumnMessage.default_value)
}

// optional string referenced_column = 7;
inline bool ColumnMessage::has_referenced_column() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ColumnMessage::set_has_referenced_column() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ColumnMessage::clear_has_referenced_column() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ColumnMessage::clear_referenced_column() {
  if (referenced_column_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referenced_column_->clear();
  }
  clear_has_referenced_column();
}
inline const ::std::string& ColumnMessage::referenced_column() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.referenced_column)
  return *referenced_column_;
}
inline void ColumnMessage::set_referenced_column(const ::std::string& value) {
  set_has_referenced_column();
  if (referenced_column_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referenced_column_ = new ::std::string;
  }
  referenced_column_->assign(value);
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.referenced_column)
}
inline void ColumnMessage::set_referenced_column(const char* value) {
  set_has_referenced_column();
  if (referenced_column_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referenced_column_ = new ::std::string;
  }
  referenced_column_->assign(value);
  // @@protoc_insertion_point(field_set_char:palo.ColumnMessage.referenced_column)
}
inline void ColumnMessage::set_referenced_column(const char* value, size_t size) {
  set_has_referenced_column();
  if (referenced_column_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referenced_column_ = new ::std::string;
  }
  referenced_column_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palo.ColumnMessage.referenced_column)
}
inline ::std::string* ColumnMessage::mutable_referenced_column() {
  set_has_referenced_column();
  if (referenced_column_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referenced_column_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:palo.ColumnMessage.referenced_column)
  return referenced_column_;
}
inline ::std::string* ColumnMessage::release_referenced_column() {
  clear_has_referenced_column();
  if (referenced_column_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = referenced_column_;
    referenced_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ColumnMessage::set_allocated_referenced_column(::std::string* referenced_column) {
  if (referenced_column_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete referenced_column_;
  }
  if (referenced_column) {
    set_has_referenced_column();
    referenced_column_ = referenced_column;
  } else {
    clear_has_referenced_column();
    referenced_column_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:palo.ColumnMessage.referenced_column)
}

// optional uint32 index_length = 8;
inline bool ColumnMessage::has_index_length() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ColumnMessage::set_has_index_length() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ColumnMessage::clear_has_index_length() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ColumnMessage::clear_index_length() {
  index_length_ = 0u;
  clear_has_index_length();
}
inline ::google::protobuf::uint32 ColumnMessage::index_length() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.index_length)
  return index_length_;
}
inline void ColumnMessage::set_index_length(::google::protobuf::uint32 value) {
  set_has_index_length();
  index_length_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.index_length)
}

// optional uint32 precision = 9 [default = 27];
inline bool ColumnMessage::has_precision() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ColumnMessage::set_has_precision() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ColumnMessage::clear_has_precision() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ColumnMessage::clear_precision() {
  precision_ = 27u;
  clear_has_precision();
}
inline ::google::protobuf::uint32 ColumnMessage::precision() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.precision)
  return precision_;
}
inline void ColumnMessage::set_precision(::google::protobuf::uint32 value) {
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.precision)
}

// optional uint32 frac = 10 [default = 9];
inline bool ColumnMessage::has_frac() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ColumnMessage::set_has_frac() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ColumnMessage::clear_has_frac() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ColumnMessage::clear_frac() {
  frac_ = 9u;
  clear_has_frac();
}
inline ::google::protobuf::uint32 ColumnMessage::frac() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.frac)
  return frac_;
}
inline void ColumnMessage::set_frac(::google::protobuf::uint32 value) {
  set_has_frac();
  frac_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.frac)
}

// optional bool is_allow_null = 11 [default = false];
inline bool ColumnMessage::has_is_allow_null() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ColumnMessage::set_has_is_allow_null() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ColumnMessage::clear_has_is_allow_null() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ColumnMessage::clear_is_allow_null() {
  is_allow_null_ = false;
  clear_has_is_allow_null();
}
inline bool ColumnMessage::is_allow_null() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.is_allow_null)
  return is_allow_null_;
}
inline void ColumnMessage::set_is_allow_null(bool value) {
  set_has_is_allow_null();
  is_allow_null_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.is_allow_null)
}

// optional uint32 unique_id = 12;
inline bool ColumnMessage::has_unique_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ColumnMessage::set_has_unique_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ColumnMessage::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ColumnMessage::clear_unique_id() {
  unique_id_ = 0u;
  clear_has_unique_id();
}
inline ::google::protobuf::uint32 ColumnMessage::unique_id() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.unique_id)
  return unique_id_;
}
inline void ColumnMessage::set_unique_id(::google::protobuf::uint32 value) {
  set_has_unique_id();
  unique_id_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.unique_id)
}

// repeated uint32 sub_column = 13;
inline int ColumnMessage::sub_column_size() const {
  return sub_column_.size();
}
inline void ColumnMessage::clear_sub_column() {
  sub_column_.Clear();
}
inline ::google::protobuf::uint32 ColumnMessage::sub_column(int index) const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.sub_column)
  return sub_column_.Get(index);
}
inline void ColumnMessage::set_sub_column(int index, ::google::protobuf::uint32 value) {
  sub_column_.Set(index, value);
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.sub_column)
}
inline void ColumnMessage::add_sub_column(::google::protobuf::uint32 value) {
  sub_column_.Add(value);
  // @@protoc_insertion_point(field_add:palo.ColumnMessage.sub_column)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ColumnMessage::sub_column() const {
  // @@protoc_insertion_point(field_list:palo.ColumnMessage.sub_column)
  return sub_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ColumnMessage::mutable_sub_column() {
  // @@protoc_insertion_point(field_mutable_list:palo.ColumnMessage.sub_column)
  return &sub_column_;
}

// optional bool is_root_column = 14 [default = false];
inline bool ColumnMessage::has_is_root_column() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ColumnMessage::set_has_is_root_column() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ColumnMessage::clear_has_is_root_column() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ColumnMessage::clear_is_root_column() {
  is_root_column_ = false;
  clear_has_is_root_column();
}
inline bool ColumnMessage::is_root_column() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.is_root_column)
  return is_root_column_;
}
inline void ColumnMessage::set_is_root_column(bool value) {
  set_has_is_root_column();
  is_root_column_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.is_root_column)
}

// optional bool is_bf_column = 15 [default = false];
inline bool ColumnMessage::has_is_bf_column() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ColumnMessage::set_has_is_bf_column() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ColumnMessage::clear_has_is_bf_column() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ColumnMessage::clear_is_bf_column() {
  is_bf_column_ = false;
  clear_has_is_bf_column();
}
inline bool ColumnMessage::is_bf_column() const {
  // @@protoc_insertion_point(field_get:palo.ColumnMessage.is_bf_column)
  return is_bf_column_;
}
inline void ColumnMessage::set_is_bf_column(bool value) {
  set_has_is_bf_column();
  is_bf_column_ = value;
  // @@protoc_insertion_point(field_set:palo.ColumnMessage.is_bf_column)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace palo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::palo::CompressKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::palo::CompressKind>() {
  return ::palo::CompressKind_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_olap_5fcommon_2eproto__INCLUDED
