/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef MasterService_TYPES_H
#define MasterService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "AgentService_types.h"
#include "PaloInternalService_types.h"
#include "Types_types.h"
#include "Status_types.h"


namespace palo {

struct TResourceType {
  enum type {
    TRESOURCE_CPU_SHARE = 0,
    TRESOURCE_IO_SHARE = 1,
    TRESOURCE_SSD_READ_IOPS = 2,
    TRESOURCE_SSD_WRITE_IOPS = 3,
    TRESOURCE_SSD_READ_MBPS = 4,
    TRESOURCE_SSD_WRITE_MBPS = 5,
    TRESOURCE_HDD_READ_IOPS = 6,
    TRESOURCE_HDD_WRITE_IOPS = 7,
    TRESOURCE_HDD_READ_MBPS = 8,
    TRESOURCE_HDD_WRITE_MBPS = 9
  };
};

extern const std::map<int, const char*> _TResourceType_VALUES_TO_NAMES;

class TTabletInfo;

class TFinishTaskRequest;

class TTablet;

class TDisk;

class TReportRequest;

class TMasterResult;

class TResourceGroup;

class TUserResource;

class TFetchResourceResult;

typedef struct _TTabletInfo__isset {
  _TTabletInfo__isset() : storage_medium(false) {}
  bool storage_medium :1;
} _TTabletInfo__isset;

class TTabletInfo {
 public:

  TTabletInfo(const TTabletInfo&);
  TTabletInfo& operator=(const TTabletInfo&);
  TTabletInfo() : tablet_id(0), schema_hash(0), version(0), version_hash(0), row_count(0), data_size(0), storage_medium(( ::palo::TStorageMedium::type)0) {
  }

  virtual ~TTabletInfo() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;
   ::palo::TCount row_count;
   ::palo::TSize data_size;
   ::palo::TStorageMedium::type storage_medium;

  _TTabletInfo__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_version(const  ::palo::TVersion val);

  void __set_version_hash(const  ::palo::TVersionHash val);

  void __set_row_count(const  ::palo::TCount val);

  void __set_data_size(const  ::palo::TSize val);

  void __set_storage_medium(const  ::palo::TStorageMedium::type val);

  bool operator == (const TTabletInfo & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    if (!(row_count == rhs.row_count))
      return false;
    if (!(data_size == rhs.data_size))
      return false;
    if (__isset.storage_medium != rhs.__isset.storage_medium)
      return false;
    else if (__isset.storage_medium && !(storage_medium == rhs.storage_medium))
      return false;
    return true;
  }
  bool operator != (const TTabletInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTabletInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTabletInfo &a, TTabletInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TTabletInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TFinishTaskRequest__isset {
  _TFinishTaskRequest__isset() : report_version(false), finish_tablet_infos(false), tablet_checksum(false), request_version(false), request_version_hash(false), snapshot_path(false) {}
  bool report_version :1;
  bool finish_tablet_infos :1;
  bool tablet_checksum :1;
  bool request_version :1;
  bool request_version_hash :1;
  bool snapshot_path :1;
} _TFinishTaskRequest__isset;

class TFinishTaskRequest {
 public:

  TFinishTaskRequest(const TFinishTaskRequest&);
  TFinishTaskRequest& operator=(const TFinishTaskRequest&);
  TFinishTaskRequest() : task_type(( ::palo::TTaskType::type)0), signature(0), report_version(0), tablet_checksum(0), request_version(0), request_version_hash(0), snapshot_path() {
  }

  virtual ~TFinishTaskRequest() throw();
   ::palo::TBackend backend;
   ::palo::TTaskType::type task_type;
  int64_t signature;
   ::palo::TStatus task_status;
  int64_t report_version;
  std::vector<TTabletInfo>  finish_tablet_infos;
  int64_t tablet_checksum;
  int64_t request_version;
  int64_t request_version_hash;
  std::string snapshot_path;

  _TFinishTaskRequest__isset __isset;

  void __set_backend(const  ::palo::TBackend& val);

  void __set_task_type(const  ::palo::TTaskType::type val);

  void __set_signature(const int64_t val);

  void __set_task_status(const  ::palo::TStatus& val);

  void __set_report_version(const int64_t val);

  void __set_finish_tablet_infos(const std::vector<TTabletInfo> & val);

  void __set_tablet_checksum(const int64_t val);

  void __set_request_version(const int64_t val);

  void __set_request_version_hash(const int64_t val);

  void __set_snapshot_path(const std::string& val);

  bool operator == (const TFinishTaskRequest & rhs) const
  {
    if (!(backend == rhs.backend))
      return false;
    if (!(task_type == rhs.task_type))
      return false;
    if (!(signature == rhs.signature))
      return false;
    if (!(task_status == rhs.task_status))
      return false;
    if (__isset.report_version != rhs.__isset.report_version)
      return false;
    else if (__isset.report_version && !(report_version == rhs.report_version))
      return false;
    if (__isset.finish_tablet_infos != rhs.__isset.finish_tablet_infos)
      return false;
    else if (__isset.finish_tablet_infos && !(finish_tablet_infos == rhs.finish_tablet_infos))
      return false;
    if (__isset.tablet_checksum != rhs.__isset.tablet_checksum)
      return false;
    else if (__isset.tablet_checksum && !(tablet_checksum == rhs.tablet_checksum))
      return false;
    if (__isset.request_version != rhs.__isset.request_version)
      return false;
    else if (__isset.request_version && !(request_version == rhs.request_version))
      return false;
    if (__isset.request_version_hash != rhs.__isset.request_version_hash)
      return false;
    else if (__isset.request_version_hash && !(request_version_hash == rhs.request_version_hash))
      return false;
    if (__isset.snapshot_path != rhs.__isset.snapshot_path)
      return false;
    else if (__isset.snapshot_path && !(snapshot_path == rhs.snapshot_path))
      return false;
    return true;
  }
  bool operator != (const TFinishTaskRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFinishTaskRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFinishTaskRequest &a, TFinishTaskRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TFinishTaskRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TTablet {
 public:

  TTablet(const TTablet&);
  TTablet& operator=(const TTablet&);
  TTablet() {
  }

  virtual ~TTablet() throw();
  std::vector<TTabletInfo>  tablet_infos;

  void __set_tablet_infos(const std::vector<TTabletInfo> & val);

  bool operator == (const TTablet & rhs) const
  {
    if (!(tablet_infos == rhs.tablet_infos))
      return false;
    return true;
  }
  bool operator != (const TTablet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTablet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTablet &a, TTablet &b);

inline std::ostream& operator<<(std::ostream& out, const TTablet& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TDisk__isset {
  _TDisk__isset() : disk_available_capacity(false) {}
  bool disk_available_capacity :1;
} _TDisk__isset;

class TDisk {
 public:

  TDisk(const TDisk&);
  TDisk& operator=(const TDisk&);
  TDisk() : root_path(), disk_total_capacity(0), data_used_capacity(0), used(0), disk_available_capacity(0) {
  }

  virtual ~TDisk() throw();
  std::string root_path;
   ::palo::TSize disk_total_capacity;
   ::palo::TSize data_used_capacity;
  bool used;
   ::palo::TSize disk_available_capacity;

  _TDisk__isset __isset;

  void __set_root_path(const std::string& val);

  void __set_disk_total_capacity(const  ::palo::TSize val);

  void __set_data_used_capacity(const  ::palo::TSize val);

  void __set_used(const bool val);

  void __set_disk_available_capacity(const  ::palo::TSize val);

  bool operator == (const TDisk & rhs) const
  {
    if (!(root_path == rhs.root_path))
      return false;
    if (!(disk_total_capacity == rhs.disk_total_capacity))
      return false;
    if (!(data_used_capacity == rhs.data_used_capacity))
      return false;
    if (!(used == rhs.used))
      return false;
    if (__isset.disk_available_capacity != rhs.__isset.disk_available_capacity)
      return false;
    else if (__isset.disk_available_capacity && !(disk_available_capacity == rhs.disk_available_capacity))
      return false;
    return true;
  }
  bool operator != (const TDisk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDisk & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDisk &a, TDisk &b);

inline std::ostream& operator<<(std::ostream& out, const TDisk& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TReportRequest__isset {
  _TReportRequest__isset() : report_version(false), tasks(false), tablets(false), disks(false) {}
  bool report_version :1;
  bool tasks :1;
  bool tablets :1;
  bool disks :1;
} _TReportRequest__isset;

class TReportRequest {
 public:

  TReportRequest(const TReportRequest&);
  TReportRequest& operator=(const TReportRequest&);
  TReportRequest() : report_version(0) {
  }

  virtual ~TReportRequest() throw();
   ::palo::TBackend backend;
  int64_t report_version;
  std::map< ::palo::TTaskType::type, std::set<int64_t> >  tasks;
  std::map< ::palo::TTabletId, TTablet>  tablets;
  std::map<std::string, TDisk>  disks;

  _TReportRequest__isset __isset;

  void __set_backend(const  ::palo::TBackend& val);

  void __set_report_version(const int64_t val);

  void __set_tasks(const std::map< ::palo::TTaskType::type, std::set<int64_t> > & val);

  void __set_tablets(const std::map< ::palo::TTabletId, TTablet> & val);

  void __set_disks(const std::map<std::string, TDisk> & val);

  bool operator == (const TReportRequest & rhs) const
  {
    if (!(backend == rhs.backend))
      return false;
    if (__isset.report_version != rhs.__isset.report_version)
      return false;
    else if (__isset.report_version && !(report_version == rhs.report_version))
      return false;
    if (__isset.tasks != rhs.__isset.tasks)
      return false;
    else if (__isset.tasks && !(tasks == rhs.tasks))
      return false;
    if (__isset.tablets != rhs.__isset.tablets)
      return false;
    else if (__isset.tablets && !(tablets == rhs.tablets))
      return false;
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    return true;
  }
  bool operator != (const TReportRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TReportRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TReportRequest &a, TReportRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TReportRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TMasterResult {
 public:

  TMasterResult(const TMasterResult&);
  TMasterResult& operator=(const TMasterResult&);
  TMasterResult() {
  }

  virtual ~TMasterResult() throw();
   ::palo::TStatus status;

  void __set_status(const  ::palo::TStatus& val);

  bool operator == (const TMasterResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TMasterResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMasterResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMasterResult &a, TMasterResult &b);

inline std::ostream& operator<<(std::ostream& out, const TMasterResult& obj)
{
  obj.printTo(out);
  return out;
}


class TResourceGroup {
 public:

  TResourceGroup(const TResourceGroup&);
  TResourceGroup& operator=(const TResourceGroup&);
  TResourceGroup() {
  }

  virtual ~TResourceGroup() throw();
  std::map<TResourceType::type, int32_t>  resourceByType;

  void __set_resourceByType(const std::map<TResourceType::type, int32_t> & val);

  bool operator == (const TResourceGroup & rhs) const
  {
    if (!(resourceByType == rhs.resourceByType))
      return false;
    return true;
  }
  bool operator != (const TResourceGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResourceGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TResourceGroup &a, TResourceGroup &b);

inline std::ostream& operator<<(std::ostream& out, const TResourceGroup& obj)
{
  obj.printTo(out);
  return out;
}


class TUserResource {
 public:

  TUserResource(const TUserResource&);
  TUserResource& operator=(const TUserResource&);
  TUserResource() {
  }

  virtual ~TUserResource() throw();
  TResourceGroup resource;
  std::map<std::string, int32_t>  shareByGroup;

  void __set_resource(const TResourceGroup& val);

  void __set_shareByGroup(const std::map<std::string, int32_t> & val);

  bool operator == (const TUserResource & rhs) const
  {
    if (!(resource == rhs.resource))
      return false;
    if (!(shareByGroup == rhs.shareByGroup))
      return false;
    return true;
  }
  bool operator != (const TUserResource &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUserResource & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUserResource &a, TUserResource &b);

inline std::ostream& operator<<(std::ostream& out, const TUserResource& obj)
{
  obj.printTo(out);
  return out;
}


class TFetchResourceResult {
 public:

  TFetchResourceResult(const TFetchResourceResult&);
  TFetchResourceResult& operator=(const TFetchResourceResult&);
  TFetchResourceResult() : protocolVersion(( ::palo::TAgentServiceVersion::type)0), resourceVersion(0) {
  }

  virtual ~TFetchResourceResult() throw();
   ::palo::TAgentServiceVersion::type protocolVersion;
  int64_t resourceVersion;
  std::map<std::string, TUserResource>  resourceByUser;

  void __set_protocolVersion(const  ::palo::TAgentServiceVersion::type val);

  void __set_resourceVersion(const int64_t val);

  void __set_resourceByUser(const std::map<std::string, TUserResource> & val);

  bool operator == (const TFetchResourceResult & rhs) const
  {
    if (!(protocolVersion == rhs.protocolVersion))
      return false;
    if (!(resourceVersion == rhs.resourceVersion))
      return false;
    if (!(resourceByUser == rhs.resourceByUser))
      return false;
    return true;
  }
  bool operator != (const TFetchResourceResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchResourceResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFetchResourceResult &a, TFetchResourceResult &b);

inline std::ostream& operator<<(std::ostream& out, const TFetchResourceResult& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
