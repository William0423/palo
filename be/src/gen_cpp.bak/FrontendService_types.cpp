/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "FrontendService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTFileFormatValues[] = {
  TFileFormat::PARQUETFILE,
  TFileFormat::RCFILE,
  TFileFormat::SEQUENCEFILE,
  TFileFormat::TEXTFILE
};
const char* _kTFileFormatNames[] = {
  "PARQUETFILE",
  "RCFILE",
  "SEQUENCEFILE",
  "TEXTFILE"
};
const std::map<int, const char*> _TFileFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTFileFormatValues, _kTFileFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTSetTypeValues[] = {
  TSetType::OPT_DEFAULT,
  TSetType::OPT_GLOBAL,
  TSetType::OPT_SESSION
};
const char* _kTSetTypeNames[] = {
  "OPT_DEFAULT",
  "OPT_GLOBAL",
  "OPT_SESSION"
};
const std::map<int, const char*> _TSetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTSetTypeValues, _kTSetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDdlTypeValues[] = {
  TDdlType::USE,
  TDdlType::DESCRIBE,
  TDdlType::SET,
  TDdlType::EXPLAIN,
  TDdlType::KILL,
  TDdlType::COMMON
};
const char* _kTDdlTypeNames[] = {
  "USE",
  "DESCRIBE",
  "SET",
  "EXPLAIN",
  "KILL",
  "COMMON"
};
const std::map<int, const char*> _TDdlType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTDdlTypeValues, _kTDdlTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFrontendServiceVersionValues[] = {
  FrontendServiceVersion::V1
};
const char* _kFrontendServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _FrontendServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFrontendServiceVersionValues, _kFrontendServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TSetSessionParams::~TSetSessionParams() throw() {
}


void TSetSessionParams::__set_user(const std::string& val) {
  this->user = val;
}

uint32_t TSetSessionParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetSessionParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetSessionParams");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetSessionParams &a, TSetSessionParams &b) {
  using ::std::swap;
  swap(a.user, b.user);
}

TSetSessionParams::TSetSessionParams(const TSetSessionParams& other0) {
  user = other0.user;
}
TSetSessionParams& TSetSessionParams::operator=(const TSetSessionParams& other1) {
  user = other1.user;
  return *this;
}
void TSetSessionParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetSessionParams(";
  out << "user=" << to_string(user);
  out << ")";
}


TAuthenticateParams::~TAuthenticateParams() throw() {
}


void TAuthenticateParams::__set_user(const std::string& val) {
  this->user = val;
}

void TAuthenticateParams::__set_passwd(const std::string& val) {
  this->passwd = val;
}

uint32_t TAuthenticateParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;
  bool isset_passwd = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          isset_passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_passwd)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAuthenticateParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAuthenticateParams");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAuthenticateParams &a, TAuthenticateParams &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
}

TAuthenticateParams::TAuthenticateParams(const TAuthenticateParams& other2) {
  user = other2.user;
  passwd = other2.passwd;
}
TAuthenticateParams& TAuthenticateParams::operator=(const TAuthenticateParams& other3) {
  user = other3.user;
  passwd = other3.passwd;
  return *this;
}
void TAuthenticateParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAuthenticateParams(";
  out << "user=" << to_string(user);
  out << ", " << "passwd=" << to_string(passwd);
  out << ")";
}


TColumnDesc::~TColumnDesc() throw() {
}


void TColumnDesc::__set_columnName(const std::string& val) {
  this->columnName = val;
}

void TColumnDesc::__set_columnType(const  ::palo::TPrimitiveType::type val) {
  this->columnType = val;
}

void TColumnDesc::__set_columnLength(const int32_t val) {
  this->columnLength = val;
__isset.columnLength = true;
}

void TColumnDesc::__set_columnPrecision(const int32_t val) {
  this->columnPrecision = val;
__isset.columnPrecision = true;
}

void TColumnDesc::__set_columnScale(const int32_t val) {
  this->columnScale = val;
__isset.columnScale = true;
}

uint32_t TColumnDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_columnType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->columnType = ( ::palo::TPrimitiveType::type)ecast4;
          isset_columnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnLength);
          this->__isset.columnLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnPrecision);
          this->__isset.columnPrecision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnScale);
          this->__isset.columnScale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnDesc");

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->columnType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columnLength) {
    xfer += oprot->writeFieldBegin("columnLength", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->columnLength);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnPrecision) {
    xfer += oprot->writeFieldBegin("columnPrecision", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->columnPrecision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnScale) {
    xfer += oprot->writeFieldBegin("columnScale", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->columnScale);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnDesc &a, TColumnDesc &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.columnType, b.columnType);
  swap(a.columnLength, b.columnLength);
  swap(a.columnPrecision, b.columnPrecision);
  swap(a.columnScale, b.columnScale);
  swap(a.__isset, b.__isset);
}

TColumnDesc::TColumnDesc(const TColumnDesc& other5) {
  columnName = other5.columnName;
  columnType = other5.columnType;
  columnLength = other5.columnLength;
  columnPrecision = other5.columnPrecision;
  columnScale = other5.columnScale;
  __isset = other5.__isset;
}
TColumnDesc& TColumnDesc::operator=(const TColumnDesc& other6) {
  columnName = other6.columnName;
  columnType = other6.columnType;
  columnLength = other6.columnLength;
  columnPrecision = other6.columnPrecision;
  columnScale = other6.columnScale;
  __isset = other6.__isset;
  return *this;
}
void TColumnDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnDesc(";
  out << "columnName=" << to_string(columnName);
  out << ", " << "columnType=" << to_string(columnType);
  out << ", " << "columnLength="; (__isset.columnLength ? (out << to_string(columnLength)) : (out << "<null>"));
  out << ", " << "columnPrecision="; (__isset.columnPrecision ? (out << to_string(columnPrecision)) : (out << "<null>"));
  out << ", " << "columnScale="; (__isset.columnScale ? (out << to_string(columnScale)) : (out << "<null>"));
  out << ")";
}


TColumnDef::~TColumnDef() throw() {
}


void TColumnDef::__set_columnDesc(const TColumnDesc& val) {
  this->columnDesc = val;
}

void TColumnDef::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

uint32_t TColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnDesc = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->columnDesc.read(iprot);
          isset_columnDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnDef");

  xfer += oprot->writeFieldBegin("columnDesc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->columnDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnDef &a, TColumnDef &b) {
  using ::std::swap;
  swap(a.columnDesc, b.columnDesc);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

TColumnDef::TColumnDef(const TColumnDef& other7) {
  columnDesc = other7.columnDesc;
  comment = other7.comment;
  __isset = other7.__isset;
}
TColumnDef& TColumnDef::operator=(const TColumnDef& other8) {
  columnDesc = other8.columnDesc;
  comment = other8.comment;
  __isset = other8.__isset;
  return *this;
}
void TColumnDef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnDef(";
  out << "columnDesc=" << to_string(columnDesc);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


TDescribeTableParams::~TDescribeTableParams() throw() {
}


void TDescribeTableParams::__set_db(const std::string& val) {
  this->db = val;
__isset.db = true;
}

void TDescribeTableParams::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TDescribeTableParams::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

uint32_t TDescribeTableParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDescribeTableParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescribeTableParams");

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDescribeTableParams &a, TDescribeTableParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
  swap(a.table_name, b.table_name);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

TDescribeTableParams::TDescribeTableParams(const TDescribeTableParams& other9) {
  db = other9.db;
  table_name = other9.table_name;
  user = other9.user;
  __isset = other9.__isset;
}
TDescribeTableParams& TDescribeTableParams::operator=(const TDescribeTableParams& other10) {
  db = other10.db;
  table_name = other10.table_name;
  user = other10.user;
  __isset = other10.__isset;
  return *this;
}
void TDescribeTableParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDescribeTableParams(";
  out << "db="; (__isset.db ? (out << to_string(db)) : (out << "<null>"));
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ")";
}


TDescribeTableResult::~TDescribeTableResult() throw() {
}


void TDescribeTableResult::__set_columns(const std::vector<TColumnDef> & val) {
  this->columns = val;
}

uint32_t TDescribeTableResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->columns.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->columns[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDescribeTableResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescribeTableResult");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDef> ::const_iterator _iter16;
    for (_iter16 = this->columns.begin(); _iter16 != this->columns.end(); ++_iter16)
    {
      xfer += (*_iter16).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDescribeTableResult &a, TDescribeTableResult &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
}

TDescribeTableResult::TDescribeTableResult(const TDescribeTableResult& other17) {
  columns = other17.columns;
}
TDescribeTableResult& TDescribeTableResult::operator=(const TDescribeTableResult& other18) {
  columns = other18.columns;
  return *this;
}
void TDescribeTableResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDescribeTableResult(";
  out << "columns=" << to_string(columns);
  out << ")";
}


TShowVariableRequest::~TShowVariableRequest() throw() {
}


void TShowVariableRequest::__set_threadId(const int64_t val) {
  this->threadId = val;
}

void TShowVariableRequest::__set_varType(const  ::palo::TVarType::type val) {
  this->varType = val;
}

uint32_t TShowVariableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_threadId = false;
  bool isset_varType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->threadId);
          isset_threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->varType = ( ::palo::TVarType::type)ecast19;
          isset_varType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_threadId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_varType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowVariableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowVariableRequest");

  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->threadId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("varType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->varType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowVariableRequest &a, TShowVariableRequest &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.varType, b.varType);
}

TShowVariableRequest::TShowVariableRequest(const TShowVariableRequest& other20) {
  threadId = other20.threadId;
  varType = other20.varType;
}
TShowVariableRequest& TShowVariableRequest::operator=(const TShowVariableRequest& other21) {
  threadId = other21.threadId;
  varType = other21.varType;
  return *this;
}
void TShowVariableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowVariableRequest(";
  out << "threadId=" << to_string(threadId);
  out << ", " << "varType=" << to_string(varType);
  out << ")";
}


TShowVariableResult::~TShowVariableResult() throw() {
}


void TShowVariableResult::__set_variables(const std::map<std::string, std::string> & val) {
  this->variables = val;
}

uint32_t TShowVariableResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_variables = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->variables.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              std::string _key27;
              xfer += iprot->readString(_key27);
              std::string& _val28 = this->variables[_key27];
              xfer += iprot->readString(_val28);
            }
            xfer += iprot->readMapEnd();
          }
          isset_variables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_variables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowVariableResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowVariableResult");

  xfer += oprot->writeFieldBegin("variables", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->variables.size()));
    std::map<std::string, std::string> ::const_iterator _iter29;
    for (_iter29 = this->variables.begin(); _iter29 != this->variables.end(); ++_iter29)
    {
      xfer += oprot->writeString(_iter29->first);
      xfer += oprot->writeString(_iter29->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowVariableResult &a, TShowVariableResult &b) {
  using ::std::swap;
  swap(a.variables, b.variables);
}

TShowVariableResult::TShowVariableResult(const TShowVariableResult& other30) {
  variables = other30.variables;
}
TShowVariableResult& TShowVariableResult::operator=(const TShowVariableResult& other31) {
  variables = other31.variables;
  return *this;
}
void TShowVariableResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowVariableResult(";
  out << "variables=" << to_string(variables);
  out << ")";
}


TTableRowFormat::~TTableRowFormat() throw() {
}


void TTableRowFormat::__set_field_terminator(const std::string& val) {
  this->field_terminator = val;
__isset.field_terminator = true;
}

void TTableRowFormat::__set_line_terminator(const std::string& val) {
  this->line_terminator = val;
__isset.line_terminator = true;
}

void TTableRowFormat::__set_escaped_by(const std::string& val) {
  this->escaped_by = val;
__isset.escaped_by = true;
}

uint32_t TTableRowFormat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field_terminator);
          this->__isset.field_terminator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_terminator);
          this->__isset.line_terminator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escaped_by);
          this->__isset.escaped_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableRowFormat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableRowFormat");

  if (this->__isset.field_terminator) {
    xfer += oprot->writeFieldBegin("field_terminator", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->field_terminator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.line_terminator) {
    xfer += oprot->writeFieldBegin("line_terminator", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->line_terminator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.escaped_by) {
    xfer += oprot->writeFieldBegin("escaped_by", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->escaped_by);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableRowFormat &a, TTableRowFormat &b) {
  using ::std::swap;
  swap(a.field_terminator, b.field_terminator);
  swap(a.line_terminator, b.line_terminator);
  swap(a.escaped_by, b.escaped_by);
  swap(a.__isset, b.__isset);
}

TTableRowFormat::TTableRowFormat(const TTableRowFormat& other32) {
  field_terminator = other32.field_terminator;
  line_terminator = other32.line_terminator;
  escaped_by = other32.escaped_by;
  __isset = other32.__isset;
}
TTableRowFormat& TTableRowFormat::operator=(const TTableRowFormat& other33) {
  field_terminator = other33.field_terminator;
  line_terminator = other33.line_terminator;
  escaped_by = other33.escaped_by;
  __isset = other33.__isset;
  return *this;
}
void TTableRowFormat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableRowFormat(";
  out << "field_terminator="; (__isset.field_terminator ? (out << to_string(field_terminator)) : (out << "<null>"));
  out << ", " << "line_terminator="; (__isset.line_terminator ? (out << to_string(line_terminator)) : (out << "<null>"));
  out << ", " << "escaped_by="; (__isset.escaped_by ? (out << to_string(escaped_by)) : (out << "<null>"));
  out << ")";
}


TPartitionKeyValue::~TPartitionKeyValue() throw() {
}


void TPartitionKeyValue::__set_name(const std::string& val) {
  this->name = val;
}

void TPartitionKeyValue::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t TPartitionKeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPartitionKeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartitionKeyValue");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPartitionKeyValue &a, TPartitionKeyValue &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
}

TPartitionKeyValue::TPartitionKeyValue(const TPartitionKeyValue& other34) {
  name = other34.name;
  value = other34.value;
}
TPartitionKeyValue& TPartitionKeyValue::operator=(const TPartitionKeyValue& other35) {
  name = other35.name;
  value = other35.value;
  return *this;
}
void TPartitionKeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPartitionKeyValue(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TSessionState::~TSessionState() throw() {
}


void TSessionState::__set_database(const std::string& val) {
  this->database = val;
}

void TSessionState::__set_user(const std::string& val) {
  this->user = val;
}

void TSessionState::__set_connection_id(const int64_t val) {
  this->connection_id = val;
}

uint32_t TSessionState::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_database = false;
  bool isset_user = false;
  bool isset_connection_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->connection_id);
          isset_connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_connection_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSessionState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSessionState");

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->connection_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionState &a, TSessionState &b) {
  using ::std::swap;
  swap(a.database, b.database);
  swap(a.user, b.user);
  swap(a.connection_id, b.connection_id);
}

TSessionState::TSessionState(const TSessionState& other36) {
  database = other36.database;
  user = other36.user;
  connection_id = other36.connection_id;
}
TSessionState& TSessionState::operator=(const TSessionState& other37) {
  database = other37.database;
  user = other37.user;
  connection_id = other37.connection_id;
  return *this;
}
void TSessionState::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSessionState(";
  out << "database=" << to_string(database);
  out << ", " << "user=" << to_string(user);
  out << ", " << "connection_id=" << to_string(connection_id);
  out << ")";
}


TClientRequest::~TClientRequest() throw() {
}


void TClientRequest::__set_stmt(const std::string& val) {
  this->stmt = val;
}

void TClientRequest::__set_queryOptions(const  ::palo::TQueryOptions& val) {
  this->queryOptions = val;
}

void TClientRequest::__set_sessionState(const TSessionState& val) {
  this->sessionState = val;
}

uint32_t TClientRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_stmt = false;
  bool isset_queryOptions = false;
  bool isset_sessionState = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stmt);
          isset_stmt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryOptions.read(iprot);
          isset_queryOptions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionState.read(iprot);
          isset_sessionState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_stmt)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryOptions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sessionState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TClientRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClientRequest");

  xfer += oprot->writeFieldBegin("stmt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->stmt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryOptions", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->queryOptions.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionState", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->sessionState.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClientRequest &a, TClientRequest &b) {
  using ::std::swap;
  swap(a.stmt, b.stmt);
  swap(a.queryOptions, b.queryOptions);
  swap(a.sessionState, b.sessionState);
}

TClientRequest::TClientRequest(const TClientRequest& other38) {
  stmt = other38.stmt;
  queryOptions = other38.queryOptions;
  sessionState = other38.sessionState;
}
TClientRequest& TClientRequest::operator=(const TClientRequest& other39) {
  stmt = other39.stmt;
  queryOptions = other39.queryOptions;
  sessionState = other39.sessionState;
  return *this;
}
void TClientRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClientRequest(";
  out << "stmt=" << to_string(stmt);
  out << ", " << "queryOptions=" << to_string(queryOptions);
  out << ", " << "sessionState=" << to_string(sessionState);
  out << ")";
}


TExplainParams::~TExplainParams() throw() {
}


void TExplainParams::__set_explain(const std::string& val) {
  this->explain = val;
}

uint32_t TExplainParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_explain = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->explain);
          isset_explain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_explain)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExplainParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExplainParams");

  xfer += oprot->writeFieldBegin("explain", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->explain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExplainParams &a, TExplainParams &b) {
  using ::std::swap;
  swap(a.explain, b.explain);
}

TExplainParams::TExplainParams(const TExplainParams& other40) {
  explain = other40.explain;
}
TExplainParams& TExplainParams::operator=(const TExplainParams& other41) {
  explain = other41.explain;
  return *this;
}
void TExplainParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExplainParams(";
  out << "explain=" << to_string(explain);
  out << ")";
}


TSetVar::~TSetVar() throw() {
}


void TSetVar::__set_type(const TSetType::type val) {
  this->type = val;
}

void TSetVar::__set_variable(const std::string& val) {
  this->variable = val;
}

void TSetVar::__set_value(const  ::palo::TExpr& val) {
  this->value = val;
}

uint32_t TSetVar::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_variable = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->type = (TSetType::type)ecast42;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->variable);
          isset_variable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_variable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetVar::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetVar");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("variable", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->variable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetVar &a, TSetVar &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.variable, b.variable);
  swap(a.value, b.value);
}

TSetVar::TSetVar(const TSetVar& other43) {
  type = other43.type;
  variable = other43.variable;
  value = other43.value;
}
TSetVar& TSetVar::operator=(const TSetVar& other44) {
  type = other44.type;
  variable = other44.variable;
  value = other44.value;
  return *this;
}
void TSetVar::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetVar(";
  out << "type=" << to_string(type);
  out << ", " << "variable=" << to_string(variable);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TSetParams::~TSetParams() throw() {
}


void TSetParams::__set_set_vars(const std::vector<TSetVar> & val) {
  this->set_vars = val;
}

uint32_t TSetParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_set_vars = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->set_vars.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->set_vars.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->set_vars[_i49].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_set_vars = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_set_vars)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetParams");

  xfer += oprot->writeFieldBegin("set_vars", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->set_vars.size()));
    std::vector<TSetVar> ::const_iterator _iter50;
    for (_iter50 = this->set_vars.begin(); _iter50 != this->set_vars.end(); ++_iter50)
    {
      xfer += (*_iter50).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetParams &a, TSetParams &b) {
  using ::std::swap;
  swap(a.set_vars, b.set_vars);
}

TSetParams::TSetParams(const TSetParams& other51) {
  set_vars = other51.set_vars;
}
TSetParams& TSetParams::operator=(const TSetParams& other52) {
  set_vars = other52.set_vars;
  return *this;
}
void TSetParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetParams(";
  out << "set_vars=" << to_string(set_vars);
  out << ")";
}


TKillParams::~TKillParams() throw() {
}


void TKillParams::__set_is_kill_connection(const bool val) {
  this->is_kill_connection = val;
}

void TKillParams::__set_connection_id(const int64_t val) {
  this->connection_id = val;
}

uint32_t TKillParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_kill_connection = false;
  bool isset_connection_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_kill_connection);
          isset_is_kill_connection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->connection_id);
          isset_connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_kill_connection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_connection_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKillParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKillParams");

  xfer += oprot->writeFieldBegin("is_kill_connection", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_kill_connection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->connection_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKillParams &a, TKillParams &b) {
  using ::std::swap;
  swap(a.is_kill_connection, b.is_kill_connection);
  swap(a.connection_id, b.connection_id);
}

TKillParams::TKillParams(const TKillParams& other53) {
  is_kill_connection = other53.is_kill_connection;
  connection_id = other53.connection_id;
}
TKillParams& TKillParams::operator=(const TKillParams& other54) {
  is_kill_connection = other54.is_kill_connection;
  connection_id = other54.connection_id;
  return *this;
}
void TKillParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKillParams(";
  out << "is_kill_connection=" << to_string(is_kill_connection);
  out << ", " << "connection_id=" << to_string(connection_id);
  out << ")";
}


TCommonDdlParams::~TCommonDdlParams() throw() {
}


uint32_t TCommonDdlParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCommonDdlParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCommonDdlParams");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCommonDdlParams &a, TCommonDdlParams &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TCommonDdlParams::TCommonDdlParams(const TCommonDdlParams& other55) {
  (void) other55;
}
TCommonDdlParams& TCommonDdlParams::operator=(const TCommonDdlParams& other56) {
  (void) other56;
  return *this;
}
void TCommonDdlParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCommonDdlParams(";
  out << ")";
}


TUseDbParams::~TUseDbParams() throw() {
}


void TUseDbParams::__set_db(const std::string& val) {
  this->db = val;
}

uint32_t TUseDbParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUseDbParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUseDbParams");

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUseDbParams &a, TUseDbParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
}

TUseDbParams::TUseDbParams(const TUseDbParams& other57) {
  db = other57.db;
}
TUseDbParams& TUseDbParams::operator=(const TUseDbParams& other58) {
  db = other58.db;
  return *this;
}
void TUseDbParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUseDbParams(";
  out << "db=" << to_string(db);
  out << ")";
}


TResultSetMetadata::~TResultSetMetadata() throw() {
}


void TResultSetMetadata::__set_columnDescs(const std::vector<TColumnDesc> & val) {
  this->columnDescs = val;
}

uint32_t TResultSetMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnDescs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnDescs.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->columnDescs.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += this->columnDescs[_i63].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnDescs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnDescs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResultSetMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResultSetMetadata");

  xfer += oprot->writeFieldBegin("columnDescs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnDescs.size()));
    std::vector<TColumnDesc> ::const_iterator _iter64;
    for (_iter64 = this->columnDescs.begin(); _iter64 != this->columnDescs.end(); ++_iter64)
    {
      xfer += (*_iter64).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResultSetMetadata &a, TResultSetMetadata &b) {
  using ::std::swap;
  swap(a.columnDescs, b.columnDescs);
}

TResultSetMetadata::TResultSetMetadata(const TResultSetMetadata& other65) {
  columnDescs = other65.columnDescs;
}
TResultSetMetadata& TResultSetMetadata::operator=(const TResultSetMetadata& other66) {
  columnDescs = other66.columnDescs;
  return *this;
}
void TResultSetMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResultSetMetadata(";
  out << "columnDescs=" << to_string(columnDescs);
  out << ")";
}


TQueryExecRequest::~TQueryExecRequest() throw() {
}


void TQueryExecRequest::__set_desc_tbl(const  ::palo::TDescriptorTable& val) {
  this->desc_tbl = val;
__isset.desc_tbl = true;
}

void TQueryExecRequest::__set_fragments(const std::vector< ::palo::TPlanFragment> & val) {
  this->fragments = val;
}

void TQueryExecRequest::__set_dest_fragment_idx(const std::vector<int32_t> & val) {
  this->dest_fragment_idx = val;
__isset.dest_fragment_idx = true;
}

void TQueryExecRequest::__set_per_node_scan_ranges(const std::map< ::palo::TPlanNodeId, std::vector< ::palo::TScanRangeLocations> > & val) {
  this->per_node_scan_ranges = val;
__isset.per_node_scan_ranges = true;
}

void TQueryExecRequest::__set_result_set_metadata(const TResultSetMetadata& val) {
  this->result_set_metadata = val;
__isset.result_set_metadata = true;
}

void TQueryExecRequest::__set_query_globals(const  ::palo::TQueryGlobals& val) {
  this->query_globals = val;
}

void TQueryExecRequest::__set_stmt_type(const  ::palo::TStmtType::type val) {
  this->stmt_type = val;
}

void TQueryExecRequest::__set_is_block_query(const bool val) {
  this->is_block_query = val;
__isset.is_block_query = true;
}

uint32_t TQueryExecRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fragments = false;
  bool isset_query_globals = false;
  bool isset_stmt_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->desc_tbl.read(iprot);
          this->__isset.desc_tbl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fragments.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->fragments.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->fragments[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_fragments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dest_fragment_idx.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->dest_fragment_idx.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readI32(this->dest_fragment_idx[_i76]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dest_fragment_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_node_scan_ranges.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _ktype78;
            ::apache::thrift::protocol::TType _vtype79;
            xfer += iprot->readMapBegin(_ktype78, _vtype79, _size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
               ::palo::TPlanNodeId _key82;
              xfer += iprot->readI32(_key82);
              std::vector< ::palo::TScanRangeLocations> & _val83 = this->per_node_scan_ranges[_key82];
              {
                _val83.clear();
                uint32_t _size84;
                ::apache::thrift::protocol::TType _etype87;
                xfer += iprot->readListBegin(_etype87, _size84);
                _val83.resize(_size84);
                uint32_t _i88;
                for (_i88 = 0; _i88 < _size84; ++_i88)
                {
                  xfer += _val83[_i88].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.per_node_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_set_metadata.read(iprot);
          this->__isset.result_set_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_globals.read(iprot);
          isset_query_globals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast89;
          xfer += iprot->readI32(ecast89);
          this->stmt_type = ( ::palo::TStmtType::type)ecast89;
          isset_stmt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_block_query);
          this->__isset.is_block_query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fragments)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_query_globals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_stmt_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TQueryExecRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryExecRequest");

  if (this->__isset.desc_tbl) {
    xfer += oprot->writeFieldBegin("desc_tbl", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->desc_tbl.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("fragments", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fragments.size()));
    std::vector< ::palo::TPlanFragment> ::const_iterator _iter90;
    for (_iter90 = this->fragments.begin(); _iter90 != this->fragments.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dest_fragment_idx) {
    xfer += oprot->writeFieldBegin("dest_fragment_idx", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dest_fragment_idx.size()));
      std::vector<int32_t> ::const_iterator _iter91;
      for (_iter91 = this->dest_fragment_idx.begin(); _iter91 != this->dest_fragment_idx.end(); ++_iter91)
      {
        xfer += oprot->writeI32((*_iter91));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.per_node_scan_ranges) {
    xfer += oprot->writeFieldBegin("per_node_scan_ranges", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->per_node_scan_ranges.size()));
      std::map< ::palo::TPlanNodeId, std::vector< ::palo::TScanRangeLocations> > ::const_iterator _iter92;
      for (_iter92 = this->per_node_scan_ranges.begin(); _iter92 != this->per_node_scan_ranges.end(); ++_iter92)
      {
        xfer += oprot->writeI32(_iter92->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter92->second.size()));
          std::vector< ::palo::TScanRangeLocations> ::const_iterator _iter93;
          for (_iter93 = _iter92->second.begin(); _iter93 != _iter92->second.end(); ++_iter93)
          {
            xfer += (*_iter93).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_set_metadata) {
    xfer += oprot->writeFieldBegin("result_set_metadata", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->result_set_metadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("query_globals", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->query_globals.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stmt_type", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->stmt_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.is_block_query) {
    xfer += oprot->writeFieldBegin("is_block_query", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_block_query);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryExecRequest &a, TQueryExecRequest &b) {
  using ::std::swap;
  swap(a.desc_tbl, b.desc_tbl);
  swap(a.fragments, b.fragments);
  swap(a.dest_fragment_idx, b.dest_fragment_idx);
  swap(a.per_node_scan_ranges, b.per_node_scan_ranges);
  swap(a.result_set_metadata, b.result_set_metadata);
  swap(a.query_globals, b.query_globals);
  swap(a.stmt_type, b.stmt_type);
  swap(a.is_block_query, b.is_block_query);
  swap(a.__isset, b.__isset);
}

TQueryExecRequest::TQueryExecRequest(const TQueryExecRequest& other94) {
  desc_tbl = other94.desc_tbl;
  fragments = other94.fragments;
  dest_fragment_idx = other94.dest_fragment_idx;
  per_node_scan_ranges = other94.per_node_scan_ranges;
  result_set_metadata = other94.result_set_metadata;
  query_globals = other94.query_globals;
  stmt_type = other94.stmt_type;
  is_block_query = other94.is_block_query;
  __isset = other94.__isset;
}
TQueryExecRequest& TQueryExecRequest::operator=(const TQueryExecRequest& other95) {
  desc_tbl = other95.desc_tbl;
  fragments = other95.fragments;
  dest_fragment_idx = other95.dest_fragment_idx;
  per_node_scan_ranges = other95.per_node_scan_ranges;
  result_set_metadata = other95.result_set_metadata;
  query_globals = other95.query_globals;
  stmt_type = other95.stmt_type;
  is_block_query = other95.is_block_query;
  __isset = other95.__isset;
  return *this;
}
void TQueryExecRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryExecRequest(";
  out << "desc_tbl="; (__isset.desc_tbl ? (out << to_string(desc_tbl)) : (out << "<null>"));
  out << ", " << "fragments=" << to_string(fragments);
  out << ", " << "dest_fragment_idx="; (__isset.dest_fragment_idx ? (out << to_string(dest_fragment_idx)) : (out << "<null>"));
  out << ", " << "per_node_scan_ranges="; (__isset.per_node_scan_ranges ? (out << to_string(per_node_scan_ranges)) : (out << "<null>"));
  out << ", " << "result_set_metadata="; (__isset.result_set_metadata ? (out << to_string(result_set_metadata)) : (out << "<null>"));
  out << ", " << "query_globals=" << to_string(query_globals);
  out << ", " << "stmt_type=" << to_string(stmt_type);
  out << ", " << "is_block_query="; (__isset.is_block_query ? (out << to_string(is_block_query)) : (out << "<null>"));
  out << ")";
}


TDdlExecRequest::~TDdlExecRequest() throw() {
}


void TDdlExecRequest::__set_ddl_type(const TDdlType::type val) {
  this->ddl_type = val;
}

void TDdlExecRequest::__set_use_db_params(const TUseDbParams& val) {
  this->use_db_params = val;
__isset.use_db_params = true;
}

void TDdlExecRequest::__set_describe_table_params(const TDescribeTableParams& val) {
  this->describe_table_params = val;
__isset.describe_table_params = true;
}

void TDdlExecRequest::__set_explain_params(const TExplainParams& val) {
  this->explain_params = val;
__isset.explain_params = true;
}

void TDdlExecRequest::__set_set_params(const TSetParams& val) {
  this->set_params = val;
__isset.set_params = true;
}

void TDdlExecRequest::__set_kill_params(const TKillParams& val) {
  this->kill_params = val;
__isset.kill_params = true;
}

uint32_t TDdlExecRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ddl_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast96;
          xfer += iprot->readI32(ecast96);
          this->ddl_type = (TDdlType::type)ecast96;
          isset_ddl_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->use_db_params.read(iprot);
          this->__isset.use_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->describe_table_params.read(iprot);
          this->__isset.describe_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->explain_params.read(iprot);
          this->__isset.explain_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_params.read(iprot);
          this->__isset.set_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kill_params.read(iprot);
          this->__isset.kill_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ddl_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDdlExecRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDdlExecRequest");

  xfer += oprot->writeFieldBegin("ddl_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->ddl_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.use_db_params) {
    xfer += oprot->writeFieldBegin("use_db_params", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->use_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.describe_table_params) {
    xfer += oprot->writeFieldBegin("describe_table_params", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->describe_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.explain_params) {
    xfer += oprot->writeFieldBegin("explain_params", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->explain_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_params) {
    xfer += oprot->writeFieldBegin("set_params", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->set_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kill_params) {
    xfer += oprot->writeFieldBegin("kill_params", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->kill_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDdlExecRequest &a, TDdlExecRequest &b) {
  using ::std::swap;
  swap(a.ddl_type, b.ddl_type);
  swap(a.use_db_params, b.use_db_params);
  swap(a.describe_table_params, b.describe_table_params);
  swap(a.explain_params, b.explain_params);
  swap(a.set_params, b.set_params);
  swap(a.kill_params, b.kill_params);
  swap(a.__isset, b.__isset);
}

TDdlExecRequest::TDdlExecRequest(const TDdlExecRequest& other97) {
  ddl_type = other97.ddl_type;
  use_db_params = other97.use_db_params;
  describe_table_params = other97.describe_table_params;
  explain_params = other97.explain_params;
  set_params = other97.set_params;
  kill_params = other97.kill_params;
  __isset = other97.__isset;
}
TDdlExecRequest& TDdlExecRequest::operator=(const TDdlExecRequest& other98) {
  ddl_type = other98.ddl_type;
  use_db_params = other98.use_db_params;
  describe_table_params = other98.describe_table_params;
  explain_params = other98.explain_params;
  set_params = other98.set_params;
  kill_params = other98.kill_params;
  __isset = other98.__isset;
  return *this;
}
void TDdlExecRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDdlExecRequest(";
  out << "ddl_type=" << to_string(ddl_type);
  out << ", " << "use_db_params="; (__isset.use_db_params ? (out << to_string(use_db_params)) : (out << "<null>"));
  out << ", " << "describe_table_params="; (__isset.describe_table_params ? (out << to_string(describe_table_params)) : (out << "<null>"));
  out << ", " << "explain_params="; (__isset.explain_params ? (out << to_string(explain_params)) : (out << "<null>"));
  out << ", " << "set_params="; (__isset.set_params ? (out << to_string(set_params)) : (out << "<null>"));
  out << ", " << "kill_params="; (__isset.kill_params ? (out << to_string(kill_params)) : (out << "<null>"));
  out << ")";
}


TExplainResult::~TExplainResult() throw() {
}


void TExplainResult::__set_results(const std::vector< ::palo::TResultRow> & val) {
  this->results = val;
}

uint32_t TExplainResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_results = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->results.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += this->results[_i103].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_results)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExplainResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExplainResult");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector< ::palo::TResultRow> ::const_iterator _iter104;
    for (_iter104 = this->results.begin(); _iter104 != this->results.end(); ++_iter104)
    {
      xfer += (*_iter104).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExplainResult &a, TExplainResult &b) {
  using ::std::swap;
  swap(a.results, b.results);
}

TExplainResult::TExplainResult(const TExplainResult& other105) {
  results = other105.results;
}
TExplainResult& TExplainResult::operator=(const TExplainResult& other106) {
  results = other106.results;
  return *this;
}
void TExplainResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExplainResult(";
  out << "results=" << to_string(results);
  out << ")";
}


TExecRequest::~TExecRequest() throw() {
}


void TExecRequest::__set_stmt_type(const  ::palo::TStmtType::type val) {
  this->stmt_type = val;
}

void TExecRequest::__set_sql_stmt(const std::string& val) {
  this->sql_stmt = val;
__isset.sql_stmt = true;
}

void TExecRequest::__set_request_id(const  ::palo::TUniqueId& val) {
  this->request_id = val;
}

void TExecRequest::__set_query_options(const  ::palo::TQueryOptions& val) {
  this->query_options = val;
}

void TExecRequest::__set_query_exec_request(const TQueryExecRequest& val) {
  this->query_exec_request = val;
__isset.query_exec_request = true;
}

void TExecRequest::__set_ddl_exec_request(const TDdlExecRequest& val) {
  this->ddl_exec_request = val;
__isset.ddl_exec_request = true;
}

void TExecRequest::__set_result_set_metadata(const TResultSetMetadata& val) {
  this->result_set_metadata = val;
__isset.result_set_metadata = true;
}

void TExecRequest::__set_explain_result(const TExplainResult& val) {
  this->explain_result = val;
__isset.explain_result = true;
}

uint32_t TExecRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_stmt_type = false;
  bool isset_request_id = false;
  bool isset_query_options = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          this->stmt_type = ( ::palo::TStmtType::type)ecast107;
          isset_stmt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql_stmt);
          this->__isset.sql_stmt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request_id.read(iprot);
          isset_request_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_options.read(iprot);
          isset_query_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_exec_request.read(iprot);
          this->__isset.query_exec_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ddl_exec_request.read(iprot);
          this->__isset.ddl_exec_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_set_metadata.read(iprot);
          this->__isset.result_set_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->explain_result.read(iprot);
          this->__isset.explain_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_stmt_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_request_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_query_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecRequest");

  xfer += oprot->writeFieldBegin("stmt_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->stmt_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sql_stmt) {
    xfer += oprot->writeFieldBegin("sql_stmt", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->sql_stmt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("request_id", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query_options", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->query_options.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.query_exec_request) {
    xfer += oprot->writeFieldBegin("query_exec_request", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->query_exec_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ddl_exec_request) {
    xfer += oprot->writeFieldBegin("ddl_exec_request", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->ddl_exec_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_set_metadata) {
    xfer += oprot->writeFieldBegin("result_set_metadata", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->result_set_metadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.explain_result) {
    xfer += oprot->writeFieldBegin("explain_result", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->explain_result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecRequest &a, TExecRequest &b) {
  using ::std::swap;
  swap(a.stmt_type, b.stmt_type);
  swap(a.sql_stmt, b.sql_stmt);
  swap(a.request_id, b.request_id);
  swap(a.query_options, b.query_options);
  swap(a.query_exec_request, b.query_exec_request);
  swap(a.ddl_exec_request, b.ddl_exec_request);
  swap(a.result_set_metadata, b.result_set_metadata);
  swap(a.explain_result, b.explain_result);
  swap(a.__isset, b.__isset);
}

TExecRequest::TExecRequest(const TExecRequest& other108) {
  stmt_type = other108.stmt_type;
  sql_stmt = other108.sql_stmt;
  request_id = other108.request_id;
  query_options = other108.query_options;
  query_exec_request = other108.query_exec_request;
  ddl_exec_request = other108.ddl_exec_request;
  result_set_metadata = other108.result_set_metadata;
  explain_result = other108.explain_result;
  __isset = other108.__isset;
}
TExecRequest& TExecRequest::operator=(const TExecRequest& other109) {
  stmt_type = other109.stmt_type;
  sql_stmt = other109.sql_stmt;
  request_id = other109.request_id;
  query_options = other109.query_options;
  query_exec_request = other109.query_exec_request;
  ddl_exec_request = other109.ddl_exec_request;
  result_set_metadata = other109.result_set_metadata;
  explain_result = other109.explain_result;
  __isset = other109.__isset;
  return *this;
}
void TExecRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecRequest(";
  out << "stmt_type=" << to_string(stmt_type);
  out << ", " << "sql_stmt="; (__isset.sql_stmt ? (out << to_string(sql_stmt)) : (out << "<null>"));
  out << ", " << "request_id=" << to_string(request_id);
  out << ", " << "query_options=" << to_string(query_options);
  out << ", " << "query_exec_request="; (__isset.query_exec_request ? (out << to_string(query_exec_request)) : (out << "<null>"));
  out << ", " << "ddl_exec_request="; (__isset.ddl_exec_request ? (out << to_string(ddl_exec_request)) : (out << "<null>"));
  out << ", " << "result_set_metadata="; (__isset.result_set_metadata ? (out << to_string(result_set_metadata)) : (out << "<null>"));
  out << ", " << "explain_result="; (__isset.explain_result ? (out << to_string(explain_result)) : (out << "<null>"));
  out << ")";
}


TGetDbsParams::~TGetDbsParams() throw() {
}


void TGetDbsParams::__set_pattern(const std::string& val) {
  this->pattern = val;
__isset.pattern = true;
}

void TGetDbsParams::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

uint32_t TGetDbsParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetDbsParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDbsParams");

  if (this->__isset.pattern) {
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetDbsParams &a, TGetDbsParams &b) {
  using ::std::swap;
  swap(a.pattern, b.pattern);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

TGetDbsParams::TGetDbsParams(const TGetDbsParams& other110) {
  pattern = other110.pattern;
  user = other110.user;
  __isset = other110.__isset;
}
TGetDbsParams& TGetDbsParams::operator=(const TGetDbsParams& other111) {
  pattern = other111.pattern;
  user = other111.user;
  __isset = other111.__isset;
  return *this;
}
void TGetDbsParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetDbsParams(";
  out << "pattern="; (__isset.pattern ? (out << to_string(pattern)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ")";
}


TGetDbsResult::~TGetDbsResult() throw() {
}


void TGetDbsResult::__set_dbs(const std::vector<std::string> & val) {
  this->dbs = val;
}

uint32_t TGetDbsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dbs.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->dbs.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += iprot->readString(this->dbs[_i116]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dbs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetDbsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDbsResult");

  xfer += oprot->writeFieldBegin("dbs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dbs.size()));
    std::vector<std::string> ::const_iterator _iter117;
    for (_iter117 = this->dbs.begin(); _iter117 != this->dbs.end(); ++_iter117)
    {
      xfer += oprot->writeString((*_iter117));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetDbsResult &a, TGetDbsResult &b) {
  using ::std::swap;
  swap(a.dbs, b.dbs);
  swap(a.__isset, b.__isset);
}

TGetDbsResult::TGetDbsResult(const TGetDbsResult& other118) {
  dbs = other118.dbs;
  __isset = other118.__isset;
}
TGetDbsResult& TGetDbsResult::operator=(const TGetDbsResult& other119) {
  dbs = other119.dbs;
  __isset = other119.__isset;
  return *this;
}
void TGetDbsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetDbsResult(";
  out << "dbs=" << to_string(dbs);
  out << ")";
}


TGetTablesParams::~TGetTablesParams() throw() {
}


void TGetTablesParams::__set_db(const std::string& val) {
  this->db = val;
__isset.db = true;
}

void TGetTablesParams::__set_pattern(const std::string& val) {
  this->pattern = val;
__isset.pattern = true;
}

void TGetTablesParams::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

uint32_t TGetTablesParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetTablesParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTablesParams");

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pattern) {
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesParams &a, TGetTablesParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
  swap(a.pattern, b.pattern);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

TGetTablesParams::TGetTablesParams(const TGetTablesParams& other120) {
  db = other120.db;
  pattern = other120.pattern;
  user = other120.user;
  __isset = other120.__isset;
}
TGetTablesParams& TGetTablesParams::operator=(const TGetTablesParams& other121) {
  db = other121.db;
  pattern = other121.pattern;
  user = other121.user;
  __isset = other121.__isset;
  return *this;
}
void TGetTablesParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTablesParams(";
  out << "db="; (__isset.db ? (out << to_string(db)) : (out << "<null>"));
  out << ", " << "pattern="; (__isset.pattern ? (out << to_string(pattern)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ")";
}


TTableStatus::~TTableStatus() throw() {
}


void TTableStatus::__set_name(const std::string& val) {
  this->name = val;
}

void TTableStatus::__set_type(const std::string& val) {
  this->type = val;
}

void TTableStatus::__set_comment(const std::string& val) {
  this->comment = val;
}

void TTableStatus::__set_engine(const std::string& val) {
  this->engine = val;
__isset.engine = true;
}

uint32_t TTableStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;
  bool isset_comment = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          isset_comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine);
          this->__isset.engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_comment)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableStatus");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.engine) {
    xfer += oprot->writeFieldBegin("engine", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->engine);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableStatus &a, TTableStatus &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.comment, b.comment);
  swap(a.engine, b.engine);
  swap(a.__isset, b.__isset);
}

TTableStatus::TTableStatus(const TTableStatus& other122) {
  name = other122.name;
  type = other122.type;
  comment = other122.comment;
  engine = other122.engine;
  __isset = other122.__isset;
}
TTableStatus& TTableStatus::operator=(const TTableStatus& other123) {
  name = other123.name;
  type = other123.type;
  comment = other123.comment;
  engine = other123.engine;
  __isset = other123.__isset;
  return *this;
}
void TTableStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableStatus(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "comment=" << to_string(comment);
  out << ", " << "engine="; (__isset.engine ? (out << to_string(engine)) : (out << "<null>"));
  out << ")";
}


TListTableStatusResult::~TListTableStatusResult() throw() {
}


void TListTableStatusResult::__set_tables(const std::vector<TTableStatus> & val) {
  this->tables = val;
}

uint32_t TListTableStatusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tables = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->tables.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              xfer += this->tables[_i128].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TListTableStatusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TListTableStatusResult");

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tables.size()));
    std::vector<TTableStatus> ::const_iterator _iter129;
    for (_iter129 = this->tables.begin(); _iter129 != this->tables.end(); ++_iter129)
    {
      xfer += (*_iter129).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TListTableStatusResult &a, TListTableStatusResult &b) {
  using ::std::swap;
  swap(a.tables, b.tables);
}

TListTableStatusResult::TListTableStatusResult(const TListTableStatusResult& other130) {
  tables = other130.tables;
}
TListTableStatusResult& TListTableStatusResult::operator=(const TListTableStatusResult& other131) {
  tables = other131.tables;
  return *this;
}
void TListTableStatusResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TListTableStatusResult(";
  out << "tables=" << to_string(tables);
  out << ")";
}


TGetTablesResult::~TGetTablesResult() throw() {
}


void TGetTablesResult::__set_tables(const std::vector<std::string> & val) {
  this->tables = val;
}

uint32_t TGetTablesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->tables.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += iprot->readString(this->tables[_i136]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetTablesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTablesResult");

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tables.size()));
    std::vector<std::string> ::const_iterator _iter137;
    for (_iter137 = this->tables.begin(); _iter137 != this->tables.end(); ++_iter137)
    {
      xfer += oprot->writeString((*_iter137));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesResult &a, TGetTablesResult &b) {
  using ::std::swap;
  swap(a.tables, b.tables);
  swap(a.__isset, b.__isset);
}

TGetTablesResult::TGetTablesResult(const TGetTablesResult& other138) {
  tables = other138.tables;
  __isset = other138.__isset;
}
TGetTablesResult& TGetTablesResult::operator=(const TGetTablesResult& other139) {
  tables = other139.tables;
  __isset = other139.__isset;
  return *this;
}
void TGetTablesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetTablesResult(";
  out << "tables=" << to_string(tables);
  out << ")";
}


TReportExecStatusResult::~TReportExecStatusResult() throw() {
}


void TReportExecStatusResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

uint32_t TReportExecStatusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TReportExecStatusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TReportExecStatusResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TReportExecStatusResult &a, TReportExecStatusResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TReportExecStatusResult::TReportExecStatusResult(const TReportExecStatusResult& other140) {
  status = other140.status;
  __isset = other140.__isset;
}
TReportExecStatusResult& TReportExecStatusResult::operator=(const TReportExecStatusResult& other141) {
  status = other141.status;
  __isset = other141.__isset;
  return *this;
}
void TReportExecStatusResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TReportExecStatusResult(";
  out << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


TReportExecStatusParams::~TReportExecStatusParams() throw() {
}


void TReportExecStatusParams::__set_protocol_version(const FrontendServiceVersion::type val) {
  this->protocol_version = val;
}

void TReportExecStatusParams::__set_query_id(const  ::palo::TUniqueId& val) {
  this->query_id = val;
__isset.query_id = true;
}

void TReportExecStatusParams::__set_backend_num(const int32_t val) {
  this->backend_num = val;
__isset.backend_num = true;
}

void TReportExecStatusParams::__set_fragment_instance_id(const  ::palo::TUniqueId& val) {
  this->fragment_instance_id = val;
__isset.fragment_instance_id = true;
}

void TReportExecStatusParams::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

void TReportExecStatusParams::__set_done(const bool val) {
  this->done = val;
__isset.done = true;
}

void TReportExecStatusParams::__set_profile(const  ::palo::TRuntimeProfileTree& val) {
  this->profile = val;
__isset.profile = true;
}

void TReportExecStatusParams::__set_error_log(const std::vector<std::string> & val) {
  this->error_log = val;
__isset.error_log = true;
}

void TReportExecStatusParams::__set_delta_urls(const std::vector<std::string> & val) {
  this->delta_urls = val;
__isset.delta_urls = true;
}

void TReportExecStatusParams::__set_load_counters(const std::map<std::string, std::string> & val) {
  this->load_counters = val;
__isset.load_counters = true;
}

void TReportExecStatusParams::__set_tracking_url(const std::string& val) {
  this->tracking_url = val;
__isset.tracking_url = true;
}

void TReportExecStatusParams::__set_export_files(const std::vector<std::string> & val) {
  this->export_files = val;
__isset.export_files = true;
}

uint32_t TReportExecStatusParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast142;
          xfer += iprot->readI32(ecast142);
          this->protocol_version = (FrontendServiceVersion::type)ecast142;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_id.read(iprot);
          this->__isset.query_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backend_num);
          this->__isset.backend_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          this->__isset.fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->done);
          this->__isset.done = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->profile.read(iprot);
          this->__isset.profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->error_log.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->error_log.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += iprot->readString(this->error_log[_i147]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.error_log = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->delta_urls.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readListBegin(_etype151, _size148);
            this->delta_urls.resize(_size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              xfer += iprot->readString(this->delta_urls[_i152]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.delta_urls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->load_counters.clear();
            uint32_t _size153;
            ::apache::thrift::protocol::TType _ktype154;
            ::apache::thrift::protocol::TType _vtype155;
            xfer += iprot->readMapBegin(_ktype154, _vtype155, _size153);
            uint32_t _i157;
            for (_i157 = 0; _i157 < _size153; ++_i157)
            {
              std::string _key158;
              xfer += iprot->readString(_key158);
              std::string& _val159 = this->load_counters[_key158];
              xfer += iprot->readString(_val159);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.load_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tracking_url);
          this->__isset.tracking_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->export_files.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->export_files.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += iprot->readString(this->export_files[_i164]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.export_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TReportExecStatusParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TReportExecStatusParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.query_id) {
    xfer += oprot->writeFieldBegin("query_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->query_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backend_num) {
    xfer += oprot->writeFieldBegin("backend_num", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->backend_num);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fragment_instance_id) {
    xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.done) {
    xfer += oprot->writeFieldBegin("done", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->done);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.profile) {
    xfer += oprot->writeFieldBegin("profile", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->profile.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_log) {
    xfer += oprot->writeFieldBegin("error_log", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->error_log.size()));
      std::vector<std::string> ::const_iterator _iter165;
      for (_iter165 = this->error_log.begin(); _iter165 != this->error_log.end(); ++_iter165)
      {
        xfer += oprot->writeString((*_iter165));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.delta_urls) {
    xfer += oprot->writeFieldBegin("delta_urls", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->delta_urls.size()));
      std::vector<std::string> ::const_iterator _iter166;
      for (_iter166 = this->delta_urls.begin(); _iter166 != this->delta_urls.end(); ++_iter166)
      {
        xfer += oprot->writeString((*_iter166));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.load_counters) {
    xfer += oprot->writeFieldBegin("load_counters", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->load_counters.size()));
      std::map<std::string, std::string> ::const_iterator _iter167;
      for (_iter167 = this->load_counters.begin(); _iter167 != this->load_counters.end(); ++_iter167)
      {
        xfer += oprot->writeString(_iter167->first);
        xfer += oprot->writeString(_iter167->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracking_url) {
    xfer += oprot->writeFieldBegin("tracking_url", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->tracking_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_files) {
    xfer += oprot->writeFieldBegin("export_files", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->export_files.size()));
      std::vector<std::string> ::const_iterator _iter168;
      for (_iter168 = this->export_files.begin(); _iter168 != this->export_files.end(); ++_iter168)
      {
        xfer += oprot->writeString((*_iter168));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TReportExecStatusParams &a, TReportExecStatusParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.query_id, b.query_id);
  swap(a.backend_num, b.backend_num);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.status, b.status);
  swap(a.done, b.done);
  swap(a.profile, b.profile);
  swap(a.error_log, b.error_log);
  swap(a.delta_urls, b.delta_urls);
  swap(a.load_counters, b.load_counters);
  swap(a.tracking_url, b.tracking_url);
  swap(a.export_files, b.export_files);
  swap(a.__isset, b.__isset);
}

TReportExecStatusParams::TReportExecStatusParams(const TReportExecStatusParams& other169) {
  protocol_version = other169.protocol_version;
  query_id = other169.query_id;
  backend_num = other169.backend_num;
  fragment_instance_id = other169.fragment_instance_id;
  status = other169.status;
  done = other169.done;
  profile = other169.profile;
  error_log = other169.error_log;
  delta_urls = other169.delta_urls;
  load_counters = other169.load_counters;
  tracking_url = other169.tracking_url;
  export_files = other169.export_files;
  __isset = other169.__isset;
}
TReportExecStatusParams& TReportExecStatusParams::operator=(const TReportExecStatusParams& other170) {
  protocol_version = other170.protocol_version;
  query_id = other170.query_id;
  backend_num = other170.backend_num;
  fragment_instance_id = other170.fragment_instance_id;
  status = other170.status;
  done = other170.done;
  profile = other170.profile;
  error_log = other170.error_log;
  delta_urls = other170.delta_urls;
  load_counters = other170.load_counters;
  tracking_url = other170.tracking_url;
  export_files = other170.export_files;
  __isset = other170.__isset;
  return *this;
}
void TReportExecStatusParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TReportExecStatusParams(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "query_id="; (__isset.query_id ? (out << to_string(query_id)) : (out << "<null>"));
  out << ", " << "backend_num="; (__isset.backend_num ? (out << to_string(backend_num)) : (out << "<null>"));
  out << ", " << "fragment_instance_id="; (__isset.fragment_instance_id ? (out << to_string(fragment_instance_id)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "done="; (__isset.done ? (out << to_string(done)) : (out << "<null>"));
  out << ", " << "profile="; (__isset.profile ? (out << to_string(profile)) : (out << "<null>"));
  out << ", " << "error_log="; (__isset.error_log ? (out << to_string(error_log)) : (out << "<null>"));
  out << ", " << "delta_urls="; (__isset.delta_urls ? (out << to_string(delta_urls)) : (out << "<null>"));
  out << ", " << "load_counters="; (__isset.load_counters ? (out << to_string(load_counters)) : (out << "<null>"));
  out << ", " << "tracking_url="; (__isset.tracking_url ? (out << to_string(tracking_url)) : (out << "<null>"));
  out << ", " << "export_files="; (__isset.export_files ? (out << to_string(export_files)) : (out << "<null>"));
  out << ")";
}


TFeResult::~TFeResult() throw() {
}


void TFeResult::__set_protocolVersion(const FrontendServiceVersion::type val) {
  this->protocolVersion = val;
}

void TFeResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
}

uint32_t TFeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocolVersion = false;
  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast171;
          xfer += iprot->readI32(ecast171);
          this->protocolVersion = (FrontendServiceVersion::type)ecast171;
          isset_protocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFeResult");

  xfer += oprot->writeFieldBegin("protocolVersion", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocolVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFeResult &a, TFeResult &b) {
  using ::std::swap;
  swap(a.protocolVersion, b.protocolVersion);
  swap(a.status, b.status);
}

TFeResult::TFeResult(const TFeResult& other172) {
  protocolVersion = other172.protocolVersion;
  status = other172.status;
}
TFeResult& TFeResult::operator=(const TFeResult& other173) {
  protocolVersion = other173.protocolVersion;
  status = other173.status;
  return *this;
}
void TFeResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFeResult(";
  out << "protocolVersion=" << to_string(protocolVersion);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


TMiniLoadRequest::~TMiniLoadRequest() throw() {
}


void TMiniLoadRequest::__set_protocolVersion(const FrontendServiceVersion::type val) {
  this->protocolVersion = val;
}

void TMiniLoadRequest::__set_db(const std::string& val) {
  this->db = val;
}

void TMiniLoadRequest::__set_tbl(const std::string& val) {
  this->tbl = val;
}

void TMiniLoadRequest::__set_label(const std::string& val) {
  this->label = val;
}

void TMiniLoadRequest::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

void TMiniLoadRequest::__set_backend(const  ::palo::TNetworkAddress& val) {
  this->backend = val;
}

void TMiniLoadRequest::__set_files(const std::vector<std::string> & val) {
  this->files = val;
}

void TMiniLoadRequest::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}

void TMiniLoadRequest::__set_subLabel(const std::string& val) {
  this->subLabel = val;
__isset.subLabel = true;
}

void TMiniLoadRequest::__set_cluster(const std::string& val) {
  this->cluster = val;
__isset.cluster = true;
}

void TMiniLoadRequest::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

uint32_t TMiniLoadRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocolVersion = false;
  bool isset_db = false;
  bool isset_tbl = false;
  bool isset_label = false;
  bool isset_backend = false;
  bool isset_files = false;
  bool isset_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast174;
          xfer += iprot->readI32(ecast174);
          this->protocolVersion = (FrontendServiceVersion::type)ecast174;
          isset_protocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl);
          isset_tbl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          isset_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->backend.read(iprot);
          isset_backend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size175;
            ::apache::thrift::protocol::TType _etype178;
            xfer += iprot->readListBegin(_etype178, _size175);
            this->files.resize(_size175);
            uint32_t _i179;
            for (_i179 = 0; _i179 < _size175; ++_i179)
            {
              xfer += iprot->readString(this->files[_i179]);
            }
            xfer += iprot->readListEnd();
          }
          isset_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _ktype181;
            ::apache::thrift::protocol::TType _vtype182;
            xfer += iprot->readMapBegin(_ktype181, _vtype182, _size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              std::string _key185;
              xfer += iprot->readString(_key185);
              std::string& _val186 = this->properties[_key185];
              xfer += iprot->readString(_val186);
            }
            xfer += iprot->readMapEnd();
          }
          isset_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subLabel);
          this->__isset.subLabel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_backend)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_files)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMiniLoadRequest");

  xfer += oprot->writeFieldBegin("protocolVersion", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocolVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tbl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->label);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("backend", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->backend.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files.size()));
    std::vector<std::string> ::const_iterator _iter187;
    for (_iter187 = this->files.begin(); _iter187 != this->files.end(); ++_iter187)
    {
      xfer += oprot->writeString((*_iter187));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 8);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter188;
    for (_iter188 = this->properties.begin(); _iter188 != this->properties.end(); ++_iter188)
    {
      xfer += oprot->writeString(_iter188->first);
      xfer += oprot->writeString(_iter188->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.subLabel) {
    xfer += oprot->writeFieldBegin("subLabel", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->subLabel);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster) {
    xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->cluster);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadRequest &a, TMiniLoadRequest &b) {
  using ::std::swap;
  swap(a.protocolVersion, b.protocolVersion);
  swap(a.db, b.db);
  swap(a.tbl, b.tbl);
  swap(a.label, b.label);
  swap(a.user, b.user);
  swap(a.backend, b.backend);
  swap(a.files, b.files);
  swap(a.properties, b.properties);
  swap(a.subLabel, b.subLabel);
  swap(a.cluster, b.cluster);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TMiniLoadRequest::TMiniLoadRequest(const TMiniLoadRequest& other189) {
  protocolVersion = other189.protocolVersion;
  db = other189.db;
  tbl = other189.tbl;
  label = other189.label;
  user = other189.user;
  backend = other189.backend;
  files = other189.files;
  properties = other189.properties;
  subLabel = other189.subLabel;
  cluster = other189.cluster;
  timestamp = other189.timestamp;
  __isset = other189.__isset;
}
TMiniLoadRequest& TMiniLoadRequest::operator=(const TMiniLoadRequest& other190) {
  protocolVersion = other190.protocolVersion;
  db = other190.db;
  tbl = other190.tbl;
  label = other190.label;
  user = other190.user;
  backend = other190.backend;
  files = other190.files;
  properties = other190.properties;
  subLabel = other190.subLabel;
  cluster = other190.cluster;
  timestamp = other190.timestamp;
  __isset = other190.__isset;
  return *this;
}
void TMiniLoadRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMiniLoadRequest(";
  out << "protocolVersion=" << to_string(protocolVersion);
  out << ", " << "db=" << to_string(db);
  out << ", " << "tbl=" << to_string(tbl);
  out << ", " << "label=" << to_string(label);
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ", " << "backend=" << to_string(backend);
  out << ", " << "files=" << to_string(files);
  out << ", " << "properties=" << to_string(properties);
  out << ", " << "subLabel="; (__isset.subLabel ? (out << to_string(subLabel)) : (out << "<null>"));
  out << ", " << "cluster="; (__isset.cluster ? (out << to_string(cluster)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ")";
}


TUpdateMiniEtlTaskStatusRequest::~TUpdateMiniEtlTaskStatusRequest() throw() {
}


void TUpdateMiniEtlTaskStatusRequest::__set_protocolVersion(const FrontendServiceVersion::type val) {
  this->protocolVersion = val;
}

void TUpdateMiniEtlTaskStatusRequest::__set_etlTaskId(const  ::palo::TUniqueId& val) {
  this->etlTaskId = val;
}

void TUpdateMiniEtlTaskStatusRequest::__set_etlTaskStatus(const  ::palo::TMiniLoadEtlStatusResult& val) {
  this->etlTaskStatus = val;
}

uint32_t TUpdateMiniEtlTaskStatusRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocolVersion = false;
  bool isset_etlTaskId = false;
  bool isset_etlTaskStatus = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast191;
          xfer += iprot->readI32(ecast191);
          this->protocolVersion = (FrontendServiceVersion::type)ecast191;
          isset_protocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->etlTaskId.read(iprot);
          isset_etlTaskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->etlTaskStatus.read(iprot);
          isset_etlTaskStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_etlTaskId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_etlTaskStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUpdateMiniEtlTaskStatusRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateMiniEtlTaskStatusRequest");

  xfer += oprot->writeFieldBegin("protocolVersion", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocolVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("etlTaskId", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->etlTaskId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("etlTaskStatus", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->etlTaskStatus.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUpdateMiniEtlTaskStatusRequest &a, TUpdateMiniEtlTaskStatusRequest &b) {
  using ::std::swap;
  swap(a.protocolVersion, b.protocolVersion);
  swap(a.etlTaskId, b.etlTaskId);
  swap(a.etlTaskStatus, b.etlTaskStatus);
}

TUpdateMiniEtlTaskStatusRequest::TUpdateMiniEtlTaskStatusRequest(const TUpdateMiniEtlTaskStatusRequest& other192) {
  protocolVersion = other192.protocolVersion;
  etlTaskId = other192.etlTaskId;
  etlTaskStatus = other192.etlTaskStatus;
}
TUpdateMiniEtlTaskStatusRequest& TUpdateMiniEtlTaskStatusRequest::operator=(const TUpdateMiniEtlTaskStatusRequest& other193) {
  protocolVersion = other193.protocolVersion;
  etlTaskId = other193.etlTaskId;
  etlTaskStatus = other193.etlTaskStatus;
  return *this;
}
void TUpdateMiniEtlTaskStatusRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUpdateMiniEtlTaskStatusRequest(";
  out << "protocolVersion=" << to_string(protocolVersion);
  out << ", " << "etlTaskId=" << to_string(etlTaskId);
  out << ", " << "etlTaskStatus=" << to_string(etlTaskStatus);
  out << ")";
}


TMasterOpRequest::~TMasterOpRequest() throw() {
}


void TMasterOpRequest::__set_user(const std::string& val) {
  this->user = val;
}

void TMasterOpRequest::__set_db(const std::string& val) {
  this->db = val;
}

void TMasterOpRequest::__set_sql(const std::string& val) {
  this->sql = val;
}

void TMasterOpRequest::__set_resourceInfo(const  ::palo::TResourceInfo& val) {
  this->resourceInfo = val;
__isset.resourceInfo = true;
}

void TMasterOpRequest::__set_cluster(const std::string& val) {
  this->cluster = val;
__isset.cluster = true;
}

void TMasterOpRequest::__set_execMemLimit(const int64_t val) {
  this->execMemLimit = val;
__isset.execMemLimit = true;
}

void TMasterOpRequest::__set_queryTimeout(const int32_t val) {
  this->queryTimeout = val;
__isset.queryTimeout = true;
}

uint32_t TMasterOpRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;
  bool isset_db = false;
  bool isset_sql = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          isset_sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourceInfo.read(iprot);
          this->__isset.resourceInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execMemLimit);
          this->__isset.execMemLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryTimeout);
          this->__isset.queryTimeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sql)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMasterOpRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMasterOpRequest");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.resourceInfo) {
    xfer += oprot->writeFieldBegin("resourceInfo", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->resourceInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster) {
    xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->cluster);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.execMemLimit) {
    xfer += oprot->writeFieldBegin("execMemLimit", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->execMemLimit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryTimeout) {
    xfer += oprot->writeFieldBegin("queryTimeout", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->queryTimeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMasterOpRequest &a, TMasterOpRequest &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.db, b.db);
  swap(a.sql, b.sql);
  swap(a.resourceInfo, b.resourceInfo);
  swap(a.cluster, b.cluster);
  swap(a.execMemLimit, b.execMemLimit);
  swap(a.queryTimeout, b.queryTimeout);
  swap(a.__isset, b.__isset);
}

TMasterOpRequest::TMasterOpRequest(const TMasterOpRequest& other194) {
  user = other194.user;
  db = other194.db;
  sql = other194.sql;
  resourceInfo = other194.resourceInfo;
  cluster = other194.cluster;
  execMemLimit = other194.execMemLimit;
  queryTimeout = other194.queryTimeout;
  __isset = other194.__isset;
}
TMasterOpRequest& TMasterOpRequest::operator=(const TMasterOpRequest& other195) {
  user = other195.user;
  db = other195.db;
  sql = other195.sql;
  resourceInfo = other195.resourceInfo;
  cluster = other195.cluster;
  execMemLimit = other195.execMemLimit;
  queryTimeout = other195.queryTimeout;
  __isset = other195.__isset;
  return *this;
}
void TMasterOpRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMasterOpRequest(";
  out << "user=" << to_string(user);
  out << ", " << "db=" << to_string(db);
  out << ", " << "sql=" << to_string(sql);
  out << ", " << "resourceInfo="; (__isset.resourceInfo ? (out << to_string(resourceInfo)) : (out << "<null>"));
  out << ", " << "cluster="; (__isset.cluster ? (out << to_string(cluster)) : (out << "<null>"));
  out << ", " << "execMemLimit="; (__isset.execMemLimit ? (out << to_string(execMemLimit)) : (out << "<null>"));
  out << ", " << "queryTimeout="; (__isset.queryTimeout ? (out << to_string(queryTimeout)) : (out << "<null>"));
  out << ")";
}


TColumnDefinition::~TColumnDefinition() throw() {
}


void TColumnDefinition::__set_columnName(const std::string& val) {
  this->columnName = val;
}

void TColumnDefinition::__set_columnType(const  ::palo::TColumnType& val) {
  this->columnType = val;
}

void TColumnDefinition::__set_aggType(const  ::palo::TAggregationType::type val) {
  this->aggType = val;
__isset.aggType = true;
}

void TColumnDefinition::__set_defaultValue(const std::string& val) {
  this->defaultValue = val;
__isset.defaultValue = true;
}

uint32_t TColumnDefinition::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_columnType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->columnType.read(iprot);
          isset_columnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast196;
          xfer += iprot->readI32(ecast196);
          this->aggType = ( ::palo::TAggregationType::type)ecast196;
          this->__isset.aggType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultValue);
          this->__isset.defaultValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDefinition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnDefinition");

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnType", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->columnType.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.aggType) {
    xfer += oprot->writeFieldBegin("aggType", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->aggType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultValue) {
    xfer += oprot->writeFieldBegin("defaultValue", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnDefinition &a, TColumnDefinition &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.columnType, b.columnType);
  swap(a.aggType, b.aggType);
  swap(a.defaultValue, b.defaultValue);
  swap(a.__isset, b.__isset);
}

TColumnDefinition::TColumnDefinition(const TColumnDefinition& other197) {
  columnName = other197.columnName;
  columnType = other197.columnType;
  aggType = other197.aggType;
  defaultValue = other197.defaultValue;
  __isset = other197.__isset;
}
TColumnDefinition& TColumnDefinition::operator=(const TColumnDefinition& other198) {
  columnName = other198.columnName;
  columnType = other198.columnType;
  aggType = other198.aggType;
  defaultValue = other198.defaultValue;
  __isset = other198.__isset;
  return *this;
}
void TColumnDefinition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnDefinition(";
  out << "columnName=" << to_string(columnName);
  out << ", " << "columnType=" << to_string(columnType);
  out << ", " << "aggType="; (__isset.aggType ? (out << to_string(aggType)) : (out << "<null>"));
  out << ", " << "defaultValue="; (__isset.defaultValue ? (out << to_string(defaultValue)) : (out << "<null>"));
  out << ")";
}


TShowResultSetMetaData::~TShowResultSetMetaData() throw() {
}


void TShowResultSetMetaData::__set_columns(const std::vector<TColumnDefinition> & val) {
  this->columns = val;
}

uint32_t TShowResultSetMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size199;
            ::apache::thrift::protocol::TType _etype202;
            xfer += iprot->readListBegin(_etype202, _size199);
            this->columns.resize(_size199);
            uint32_t _i203;
            for (_i203 = 0; _i203 < _size199; ++_i203)
            {
              xfer += this->columns[_i203].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowResultSetMetaData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowResultSetMetaData");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDefinition> ::const_iterator _iter204;
    for (_iter204 = this->columns.begin(); _iter204 != this->columns.end(); ++_iter204)
    {
      xfer += (*_iter204).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowResultSetMetaData &a, TShowResultSetMetaData &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
}

TShowResultSetMetaData::TShowResultSetMetaData(const TShowResultSetMetaData& other205) {
  columns = other205.columns;
}
TShowResultSetMetaData& TShowResultSetMetaData::operator=(const TShowResultSetMetaData& other206) {
  columns = other206.columns;
  return *this;
}
void TShowResultSetMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowResultSetMetaData(";
  out << "columns=" << to_string(columns);
  out << ")";
}


TShowResultSet::~TShowResultSet() throw() {
}


void TShowResultSet::__set_metaData(const TShowResultSetMetaData& val) {
  this->metaData = val;
}

void TShowResultSet::__set_resultRows(const std::vector<std::vector<std::string> > & val) {
  this->resultRows = val;
}

uint32_t TShowResultSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metaData = false;
  bool isset_resultRows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metaData.read(iprot);
          isset_metaData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resultRows.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            this->resultRows.resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              {
                this->resultRows[_i211].clear();
                uint32_t _size212;
                ::apache::thrift::protocol::TType _etype215;
                xfer += iprot->readListBegin(_etype215, _size212);
                this->resultRows[_i211].resize(_size212);
                uint32_t _i216;
                for (_i216 = 0; _i216 < _size212; ++_i216)
                {
                  xfer += iprot->readString(this->resultRows[_i211][_i216]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_resultRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metaData)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resultRows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowResultSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowResultSet");

  xfer += oprot->writeFieldBegin("metaData", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metaData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultRows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->resultRows.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter217;
    for (_iter217 = this->resultRows.begin(); _iter217 != this->resultRows.end(); ++_iter217)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter217).size()));
        std::vector<std::string> ::const_iterator _iter218;
        for (_iter218 = (*_iter217).begin(); _iter218 != (*_iter217).end(); ++_iter218)
        {
          xfer += oprot->writeString((*_iter218));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowResultSet &a, TShowResultSet &b) {
  using ::std::swap;
  swap(a.metaData, b.metaData);
  swap(a.resultRows, b.resultRows);
}

TShowResultSet::TShowResultSet(const TShowResultSet& other219) {
  metaData = other219.metaData;
  resultRows = other219.resultRows;
}
TShowResultSet& TShowResultSet::operator=(const TShowResultSet& other220) {
  metaData = other220.metaData;
  resultRows = other220.resultRows;
  return *this;
}
void TShowResultSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowResultSet(";
  out << "metaData=" << to_string(metaData);
  out << ", " << "resultRows=" << to_string(resultRows);
  out << ")";
}


TMasterOpResult::~TMasterOpResult() throw() {
}


void TMasterOpResult::__set_maxJournalId(const int64_t val) {
  this->maxJournalId = val;
}

void TMasterOpResult::__set_packet(const std::string& val) {
  this->packet = val;
}

void TMasterOpResult::__set_resultSet(const TShowResultSet& val) {
  this->resultSet = val;
__isset.resultSet = true;
}

uint32_t TMasterOpResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxJournalId = false;
  bool isset_packet = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxJournalId);
          isset_maxJournalId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->packet);
          isset_packet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resultSet.read(iprot);
          this->__isset.resultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxJournalId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_packet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMasterOpResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMasterOpResult");

  xfer += oprot->writeFieldBegin("maxJournalId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxJournalId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packet", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->packet);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.resultSet) {
    xfer += oprot->writeFieldBegin("resultSet", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->resultSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMasterOpResult &a, TMasterOpResult &b) {
  using ::std::swap;
  swap(a.maxJournalId, b.maxJournalId);
  swap(a.packet, b.packet);
  swap(a.resultSet, b.resultSet);
  swap(a.__isset, b.__isset);
}

TMasterOpResult::TMasterOpResult(const TMasterOpResult& other221) {
  maxJournalId = other221.maxJournalId;
  packet = other221.packet;
  resultSet = other221.resultSet;
  __isset = other221.__isset;
}
TMasterOpResult& TMasterOpResult::operator=(const TMasterOpResult& other222) {
  maxJournalId = other222.maxJournalId;
  packet = other222.packet;
  resultSet = other222.resultSet;
  __isset = other222.__isset;
  return *this;
}
void TMasterOpResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMasterOpResult(";
  out << "maxJournalId=" << to_string(maxJournalId);
  out << ", " << "packet=" << to_string(packet);
  out << ", " << "resultSet="; (__isset.resultSet ? (out << to_string(resultSet)) : (out << "<null>"));
  out << ")";
}


TLoadCheckRequest::~TLoadCheckRequest() throw() {
}


void TLoadCheckRequest::__set_protocolVersion(const FrontendServiceVersion::type val) {
  this->protocolVersion = val;
}

void TLoadCheckRequest::__set_user(const std::string& val) {
  this->user = val;
}

void TLoadCheckRequest::__set_passwd(const std::string& val) {
  this->passwd = val;
}

void TLoadCheckRequest::__set_db(const std::string& val) {
  this->db = val;
}

void TLoadCheckRequest::__set_label(const std::string& val) {
  this->label = val;
__isset.label = true;
}

void TLoadCheckRequest::__set_cluster(const std::string& val) {
  this->cluster = val;
__isset.cluster = true;
}

void TLoadCheckRequest::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

uint32_t TLoadCheckRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocolVersion = false;
  bool isset_user = false;
  bool isset_passwd = false;
  bool isset_db = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast223;
          xfer += iprot->readI32(ecast223);
          this->protocolVersion = (FrontendServiceVersion::type)ecast223;
          isset_protocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          isset_passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          this->__isset.label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_passwd)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLoadCheckRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLoadCheckRequest");

  xfer += oprot->writeFieldBegin("protocolVersion", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocolVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.label) {
    xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster) {
    xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->cluster);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLoadCheckRequest &a, TLoadCheckRequest &b) {
  using ::std::swap;
  swap(a.protocolVersion, b.protocolVersion);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.db, b.db);
  swap(a.label, b.label);
  swap(a.cluster, b.cluster);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TLoadCheckRequest::TLoadCheckRequest(const TLoadCheckRequest& other224) {
  protocolVersion = other224.protocolVersion;
  user = other224.user;
  passwd = other224.passwd;
  db = other224.db;
  label = other224.label;
  cluster = other224.cluster;
  timestamp = other224.timestamp;
  __isset = other224.__isset;
}
TLoadCheckRequest& TLoadCheckRequest::operator=(const TLoadCheckRequest& other225) {
  protocolVersion = other225.protocolVersion;
  user = other225.user;
  passwd = other225.passwd;
  db = other225.db;
  label = other225.label;
  cluster = other225.cluster;
  timestamp = other225.timestamp;
  __isset = other225.__isset;
  return *this;
}
void TLoadCheckRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLoadCheckRequest(";
  out << "protocolVersion=" << to_string(protocolVersion);
  out << ", " << "user=" << to_string(user);
  out << ", " << "passwd=" << to_string(passwd);
  out << ", " << "db=" << to_string(db);
  out << ", " << "label="; (__isset.label ? (out << to_string(label)) : (out << "<null>"));
  out << ", " << "cluster="; (__isset.cluster ? (out << to_string(cluster)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ")";
}


TUpdateExportTaskStatusRequest::~TUpdateExportTaskStatusRequest() throw() {
}


void TUpdateExportTaskStatusRequest::__set_protocolVersion(const FrontendServiceVersion::type val) {
  this->protocolVersion = val;
}

void TUpdateExportTaskStatusRequest::__set_taskId(const  ::palo::TUniqueId& val) {
  this->taskId = val;
}

void TUpdateExportTaskStatusRequest::__set_taskStatus(const  ::palo::TExportStatusResult& val) {
  this->taskStatus = val;
}

uint32_t TUpdateExportTaskStatusRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocolVersion = false;
  bool isset_taskId = false;
  bool isset_taskStatus = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast226;
          xfer += iprot->readI32(ecast226);
          this->protocolVersion = (FrontendServiceVersion::type)ecast226;
          isset_protocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->taskId.read(iprot);
          isset_taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->taskStatus.read(iprot);
          isset_taskStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_taskId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_taskStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUpdateExportTaskStatusRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateExportTaskStatusRequest");

  xfer += oprot->writeFieldBegin("protocolVersion", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocolVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->taskId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskStatus", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->taskStatus.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUpdateExportTaskStatusRequest &a, TUpdateExportTaskStatusRequest &b) {
  using ::std::swap;
  swap(a.protocolVersion, b.protocolVersion);
  swap(a.taskId, b.taskId);
  swap(a.taskStatus, b.taskStatus);
}

TUpdateExportTaskStatusRequest::TUpdateExportTaskStatusRequest(const TUpdateExportTaskStatusRequest& other227) {
  protocolVersion = other227.protocolVersion;
  taskId = other227.taskId;
  taskStatus = other227.taskStatus;
}
TUpdateExportTaskStatusRequest& TUpdateExportTaskStatusRequest::operator=(const TUpdateExportTaskStatusRequest& other228) {
  protocolVersion = other228.protocolVersion;
  taskId = other228.taskId;
  taskStatus = other228.taskStatus;
  return *this;
}
void TUpdateExportTaskStatusRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUpdateExportTaskStatusRequest(";
  out << "protocolVersion=" << to_string(protocolVersion);
  out << ", " << "taskId=" << to_string(taskId);
  out << ", " << "taskStatus=" << to_string(taskStatus);
  out << ")";
}

} // namespace
