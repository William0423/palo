/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PlanNodes_TYPES_H
#define PlanNodes_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Exprs_types.h"
#include "Types_types.h"
#include "Partitions_types.h"


namespace palo {

struct TPlanNodeType {
  enum type {
    OLAP_SCAN_NODE = 0,
    MYSQL_SCAN_NODE = 1,
    CSV_SCAN_NODE = 2,
    SCHEMA_SCAN_NODE = 3,
    HASH_JOIN_NODE = 4,
    MERGE_JOIN_NODE = 5,
    AGGREGATION_NODE = 6,
    PRE_AGGREGATION_NODE = 7,
    SORT_NODE = 8,
    EXCHANGE_NODE = 9,
    MERGE_NODE = 10,
    SELECT_NODE = 11,
    CROSS_JOIN_NODE = 12,
    META_SCAN_NODE = 13,
    ANALYTIC_EVAL_NODE = 14,
    OLAP_REWRITE_NODE = 15,
    KUDU_SCAN_NODE = 16,
    BROKER_SCAN_NODE = 17,
    EMPTY_SET_NODE = 18,
    UNION_NODE = 19
  };
};

extern const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES;

struct TExecNodePhase {
  enum type {
    PREPARE = 0,
    OPEN = 1,
    GETNEXT = 2,
    CLOSE = 3,
    INVALID = 4
  };
};

extern const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES;

struct TDebugAction {
  enum type {
    WAIT = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES;

struct TFileFormatType {
  enum type {
    FORMAT_CSV_PLAIN = 0,
    FORMAT_CSV_GZ = 1,
    FORMAT_CSV_LZO = 2,
    FORMAT_CSV_BZ2 = 3,
    FORMAT_CSV_LZ4FRAME = 4,
    FORMAT_CSV_LZOP = 5
  };
};

extern const std::map<int, const char*> _TFileFormatType_VALUES_TO_NAMES;

struct TJoinOp {
  enum type {
    INNER_JOIN = 0,
    LEFT_OUTER_JOIN = 1,
    LEFT_SEMI_JOIN = 2,
    RIGHT_OUTER_JOIN = 3,
    FULL_OUTER_JOIN = 4,
    CROSS_JOIN = 5,
    MERGE_JOIN = 6,
    RIGHT_SEMI_JOIN = 7,
    LEFT_ANTI_JOIN = 8,
    RIGHT_ANTI_JOIN = 9,
    NULL_AWARE_LEFT_ANTI_JOIN = 10
  };
};

extern const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES;

struct TAggregationOp {
  enum type {
    INVALID = 0,
    COUNT = 1,
    MAX = 2,
    DISTINCT_PC = 3,
    DISTINCT_PCSA = 4,
    MIN = 5,
    SUM = 6,
    GROUP_CONCAT = 7,
    HLL = 8,
    COUNT_DISTINCT = 9,
    SUM_DISTINCT = 10,
    LEAD = 11,
    FIRST_VALUE = 12,
    LAST_VALUE = 13,
    RANK = 14,
    DENSE_RANK = 15,
    ROW_NUMBER = 16,
    LAG = 17,
    HLL_C = 18
  };
};

extern const std::map<int, const char*> _TAggregationOp_VALUES_TO_NAMES;

struct TAnalyticWindowType {
  enum type {
    RANGE = 0,
    ROWS = 1
  };
};

extern const std::map<int, const char*> _TAnalyticWindowType_VALUES_TO_NAMES;

struct TAnalyticWindowBoundaryType {
  enum type {
    CURRENT_ROW = 0,
    PRECEDING = 1,
    FOLLOWING = 2
  };
};

extern const std::map<int, const char*> _TAnalyticWindowBoundaryType_VALUES_TO_NAMES;

class TKeyRange;

class TPaloScanRange;

class TBrokerRangeDesc;

class TBrokerScanRangeParams;

class TBrokerScanRange;

class TScanRange;

class TMySQLScanNode;

class TBrokerScanNode;

class TMiniLoadEtlFunction;

class TCsvScanNode;

class TSchemaScanNode;

class TMetaScanNode;

class TOlapScanNode;

class TEqJoinCondition;

class THashJoinNode;

class TMergeJoinNode;

class TAggregationNode;

class TPreAggregationNode;

class TSortInfo;

class TSortNode;

class TAnalyticWindowBoundary;

class TAnalyticWindow;

class TAnalyticNode;

class TMergeNode;

class TUnionNode;

class TExchangeNode;

class TOlapRewriteNode;

class TKuduScanNode;

class TPlanNode;

class TPlan;


class TKeyRange {
 public:

  TKeyRange(const TKeyRange&);
  TKeyRange& operator=(const TKeyRange&);
  TKeyRange() : begin_key(0), end_key(0), column_type(( ::palo::TPrimitiveType::type)0), column_name() {
  }

  virtual ~TKeyRange() throw();
  int64_t begin_key;
  int64_t end_key;
   ::palo::TPrimitiveType::type column_type;
  std::string column_name;

  void __set_begin_key(const int64_t val);

  void __set_end_key(const int64_t val);

  void __set_column_type(const  ::palo::TPrimitiveType::type val);

  void __set_column_name(const std::string& val);

  bool operator == (const TKeyRange & rhs) const
  {
    if (!(begin_key == rhs.begin_key))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    if (!(column_type == rhs.column_type))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    return true;
  }
  bool operator != (const TKeyRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKeyRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKeyRange &a, TKeyRange &b);

inline std::ostream& operator<<(std::ostream& out, const TKeyRange& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPaloScanRange__isset {
  _TPaloScanRange__isset() : partition_column_ranges(false), index_name(false), table_name(false) {}
  bool partition_column_ranges :1;
  bool index_name :1;
  bool table_name :1;
} _TPaloScanRange__isset;

class TPaloScanRange {
 public:

  TPaloScanRange(const TPaloScanRange&);
  TPaloScanRange& operator=(const TPaloScanRange&);
  TPaloScanRange() : schema_hash(), version(), version_hash(), tablet_id(0), db_name(), index_name(), table_name() {
  }

  virtual ~TPaloScanRange() throw();
  std::vector< ::palo::TNetworkAddress>  hosts;
  std::string schema_hash;
  std::string version;
  std::string version_hash;
   ::palo::TTabletId tablet_id;
  std::string db_name;
  std::vector<TKeyRange>  partition_column_ranges;
  std::string index_name;
  std::string table_name;

  _TPaloScanRange__isset __isset;

  void __set_hosts(const std::vector< ::palo::TNetworkAddress> & val);

  void __set_schema_hash(const std::string& val);

  void __set_version(const std::string& val);

  void __set_version_hash(const std::string& val);

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_db_name(const std::string& val);

  void __set_partition_column_ranges(const std::vector<TKeyRange> & val);

  void __set_index_name(const std::string& val);

  void __set_table_name(const std::string& val);

  bool operator == (const TPaloScanRange & rhs) const
  {
    if (!(hosts == rhs.hosts))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (__isset.partition_column_ranges != rhs.__isset.partition_column_ranges)
      return false;
    else if (__isset.partition_column_ranges && !(partition_column_ranges == rhs.partition_column_ranges))
      return false;
    if (__isset.index_name != rhs.__isset.index_name)
      return false;
    else if (__isset.index_name && !(index_name == rhs.index_name))
      return false;
    if (__isset.table_name != rhs.__isset.table_name)
      return false;
    else if (__isset.table_name && !(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TPaloScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPaloScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPaloScanRange &a, TPaloScanRange &b);

inline std::ostream& operator<<(std::ostream& out, const TPaloScanRange& obj)
{
  obj.printTo(out);
  return out;
}


class TBrokerRangeDesc {
 public:

  TBrokerRangeDesc(const TBrokerRangeDesc&);
  TBrokerRangeDesc& operator=(const TBrokerRangeDesc&);
  TBrokerRangeDesc() : file_type(( ::palo::TFileType::type)0), format_type((TFileFormatType::type)0), splittable(0), path(), start_offset(0), size(0) {
  }

  virtual ~TBrokerRangeDesc() throw();
   ::palo::TFileType::type file_type;
  TFileFormatType::type format_type;
  bool splittable;
  std::string path;
  int64_t start_offset;
  int64_t size;

  void __set_file_type(const  ::palo::TFileType::type val);

  void __set_format_type(const TFileFormatType::type val);

  void __set_splittable(const bool val);

  void __set_path(const std::string& val);

  void __set_start_offset(const int64_t val);

  void __set_size(const int64_t val);

  bool operator == (const TBrokerRangeDesc & rhs) const
  {
    if (!(file_type == rhs.file_type))
      return false;
    if (!(format_type == rhs.format_type))
      return false;
    if (!(splittable == rhs.splittable))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(start_offset == rhs.start_offset))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const TBrokerRangeDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerRangeDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBrokerRangeDesc &a, TBrokerRangeDesc &b);

inline std::ostream& operator<<(std::ostream& out, const TBrokerRangeDesc& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TBrokerScanRangeParams__isset {
  _TBrokerScanRangeParams__isset() : expr_of_dest_slot(false), properties(false), partition_ids(false) {}
  bool expr_of_dest_slot :1;
  bool properties :1;
  bool partition_ids :1;
} _TBrokerScanRangeParams__isset;

class TBrokerScanRangeParams {
 public:

  TBrokerScanRangeParams(const TBrokerScanRangeParams&);
  TBrokerScanRangeParams& operator=(const TBrokerScanRangeParams&);
  TBrokerScanRangeParams() : column_separator(0), line_delimiter(0), src_tuple_id(0), dest_tuple_id(0) {
  }

  virtual ~TBrokerScanRangeParams() throw();
  int8_t column_separator;
  int8_t line_delimiter;
   ::palo::TTupleId src_tuple_id;
  std::vector< ::palo::TSlotId>  src_slot_ids;
   ::palo::TTupleId dest_tuple_id;
  std::map< ::palo::TSlotId,  ::palo::TExpr>  expr_of_dest_slot;
  std::map<std::string, std::string>  properties;
  std::vector<int64_t>  partition_ids;

  _TBrokerScanRangeParams__isset __isset;

  void __set_column_separator(const int8_t val);

  void __set_line_delimiter(const int8_t val);

  void __set_src_tuple_id(const  ::palo::TTupleId val);

  void __set_src_slot_ids(const std::vector< ::palo::TSlotId> & val);

  void __set_dest_tuple_id(const  ::palo::TTupleId val);

  void __set_expr_of_dest_slot(const std::map< ::palo::TSlotId,  ::palo::TExpr> & val);

  void __set_properties(const std::map<std::string, std::string> & val);

  void __set_partition_ids(const std::vector<int64_t> & val);

  bool operator == (const TBrokerScanRangeParams & rhs) const
  {
    if (!(column_separator == rhs.column_separator))
      return false;
    if (!(line_delimiter == rhs.line_delimiter))
      return false;
    if (!(src_tuple_id == rhs.src_tuple_id))
      return false;
    if (!(src_slot_ids == rhs.src_slot_ids))
      return false;
    if (!(dest_tuple_id == rhs.dest_tuple_id))
      return false;
    if (__isset.expr_of_dest_slot != rhs.__isset.expr_of_dest_slot)
      return false;
    else if (__isset.expr_of_dest_slot && !(expr_of_dest_slot == rhs.expr_of_dest_slot))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    if (__isset.partition_ids != rhs.__isset.partition_ids)
      return false;
    else if (__isset.partition_ids && !(partition_ids == rhs.partition_ids))
      return false;
    return true;
  }
  bool operator != (const TBrokerScanRangeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerScanRangeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBrokerScanRangeParams &a, TBrokerScanRangeParams &b);

inline std::ostream& operator<<(std::ostream& out, const TBrokerScanRangeParams& obj)
{
  obj.printTo(out);
  return out;
}


class TBrokerScanRange {
 public:

  TBrokerScanRange(const TBrokerScanRange&);
  TBrokerScanRange& operator=(const TBrokerScanRange&);
  TBrokerScanRange() {
  }

  virtual ~TBrokerScanRange() throw();
  std::vector<TBrokerRangeDesc>  ranges;
  TBrokerScanRangeParams params;
  std::vector< ::palo::TNetworkAddress>  broker_addresses;

  void __set_ranges(const std::vector<TBrokerRangeDesc> & val);

  void __set_params(const TBrokerScanRangeParams& val);

  void __set_broker_addresses(const std::vector< ::palo::TNetworkAddress> & val);

  bool operator == (const TBrokerScanRange & rhs) const
  {
    if (!(ranges == rhs.ranges))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(broker_addresses == rhs.broker_addresses))
      return false;
    return true;
  }
  bool operator != (const TBrokerScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBrokerScanRange &a, TBrokerScanRange &b);

inline std::ostream& operator<<(std::ostream& out, const TBrokerScanRange& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TScanRange__isset {
  _TScanRange__isset() : palo_scan_range(false), kudu_scan_token(false), broker_scan_range(false) {}
  bool palo_scan_range :1;
  bool kudu_scan_token :1;
  bool broker_scan_range :1;
} _TScanRange__isset;

class TScanRange {
 public:

  TScanRange(const TScanRange&);
  TScanRange& operator=(const TScanRange&);
  TScanRange() : kudu_scan_token() {
  }

  virtual ~TScanRange() throw();
  TPaloScanRange palo_scan_range;
  std::string kudu_scan_token;
  TBrokerScanRange broker_scan_range;

  _TScanRange__isset __isset;

  void __set_palo_scan_range(const TPaloScanRange& val);

  void __set_kudu_scan_token(const std::string& val);

  void __set_broker_scan_range(const TBrokerScanRange& val);

  bool operator == (const TScanRange & rhs) const
  {
    if (__isset.palo_scan_range != rhs.__isset.palo_scan_range)
      return false;
    else if (__isset.palo_scan_range && !(palo_scan_range == rhs.palo_scan_range))
      return false;
    if (__isset.kudu_scan_token != rhs.__isset.kudu_scan_token)
      return false;
    else if (__isset.kudu_scan_token && !(kudu_scan_token == rhs.kudu_scan_token))
      return false;
    if (__isset.broker_scan_range != rhs.__isset.broker_scan_range)
      return false;
    else if (__isset.broker_scan_range && !(broker_scan_range == rhs.broker_scan_range))
      return false;
    return true;
  }
  bool operator != (const TScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScanRange &a, TScanRange &b);

inline std::ostream& operator<<(std::ostream& out, const TScanRange& obj)
{
  obj.printTo(out);
  return out;
}


class TMySQLScanNode {
 public:

  TMySQLScanNode(const TMySQLScanNode&);
  TMySQLScanNode& operator=(const TMySQLScanNode&);
  TMySQLScanNode() : tuple_id(0), table_name() {
  }

  virtual ~TMySQLScanNode() throw();
   ::palo::TTupleId tuple_id;
  std::string table_name;
  std::vector<std::string>  columns;
  std::vector<std::string>  filters;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_table_name(const std::string& val);

  void __set_columns(const std::vector<std::string> & val);

  void __set_filters(const std::vector<std::string> & val);

  bool operator == (const TMySQLScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(filters == rhs.filters))
      return false;
    return true;
  }
  bool operator != (const TMySQLScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMySQLScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMySQLScanNode &a, TMySQLScanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TMySQLScanNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TBrokerScanNode__isset {
  _TBrokerScanNode__isset() : partition_exprs(false), partition_infos(false) {}
  bool partition_exprs :1;
  bool partition_infos :1;
} _TBrokerScanNode__isset;

class TBrokerScanNode {
 public:

  TBrokerScanNode(const TBrokerScanNode&);
  TBrokerScanNode& operator=(const TBrokerScanNode&);
  TBrokerScanNode() : tuple_id(0) {
  }

  virtual ~TBrokerScanNode() throw();
   ::palo::TTupleId tuple_id;
  std::vector< ::palo::TExpr>  partition_exprs;
  std::vector< ::palo::TRangePartition>  partition_infos;

  _TBrokerScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_partition_exprs(const std::vector< ::palo::TExpr> & val);

  void __set_partition_infos(const std::vector< ::palo::TRangePartition> & val);

  bool operator == (const TBrokerScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (__isset.partition_exprs != rhs.__isset.partition_exprs)
      return false;
    else if (__isset.partition_exprs && !(partition_exprs == rhs.partition_exprs))
      return false;
    if (__isset.partition_infos != rhs.__isset.partition_infos)
      return false;
    else if (__isset.partition_infos && !(partition_infos == rhs.partition_infos))
      return false;
    return true;
  }
  bool operator != (const TBrokerScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBrokerScanNode &a, TBrokerScanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TBrokerScanNode& obj)
{
  obj.printTo(out);
  return out;
}


class TMiniLoadEtlFunction {
 public:

  TMiniLoadEtlFunction(const TMiniLoadEtlFunction&);
  TMiniLoadEtlFunction& operator=(const TMiniLoadEtlFunction&);
  TMiniLoadEtlFunction() : function_name(), param_column_index(0) {
  }

  virtual ~TMiniLoadEtlFunction() throw();
  std::string function_name;
  int32_t param_column_index;

  void __set_function_name(const std::string& val);

  void __set_param_column_index(const int32_t val);

  bool operator == (const TMiniLoadEtlFunction & rhs) const
  {
    if (!(function_name == rhs.function_name))
      return false;
    if (!(param_column_index == rhs.param_column_index))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMiniLoadEtlFunction &a, TMiniLoadEtlFunction &b);

inline std::ostream& operator<<(std::ostream& out, const TMiniLoadEtlFunction& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCsvScanNode__isset {
  _TCsvScanNode__isset() : column_separator(false), line_delimiter(false), column_type_mapping(false), columns(false), unspecified_columns(false), default_values(false), max_filter_ratio(false), column_function_mapping(false) {}
  bool column_separator :1;
  bool line_delimiter :1;
  bool column_type_mapping :1;
  bool columns :1;
  bool unspecified_columns :1;
  bool default_values :1;
  bool max_filter_ratio :1;
  bool column_function_mapping :1;
} _TCsvScanNode__isset;

class TCsvScanNode {
 public:

  TCsvScanNode(const TCsvScanNode&);
  TCsvScanNode& operator=(const TCsvScanNode&);
  TCsvScanNode() : tuple_id(0), column_separator(), line_delimiter(), max_filter_ratio(0) {
  }

  virtual ~TCsvScanNode() throw();
   ::palo::TTupleId tuple_id;
  std::vector<std::string>  file_paths;
  std::string column_separator;
  std::string line_delimiter;
  std::map<std::string,  ::palo::TColumnType>  column_type_mapping;
  std::vector<std::string>  columns;
  std::vector<std::string>  unspecified_columns;
  std::vector<std::string>  default_values;
  double max_filter_ratio;
  std::map<std::string, TMiniLoadEtlFunction>  column_function_mapping;

  _TCsvScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_file_paths(const std::vector<std::string> & val);

  void __set_column_separator(const std::string& val);

  void __set_line_delimiter(const std::string& val);

  void __set_column_type_mapping(const std::map<std::string,  ::palo::TColumnType> & val);

  void __set_columns(const std::vector<std::string> & val);

  void __set_unspecified_columns(const std::vector<std::string> & val);

  void __set_default_values(const std::vector<std::string> & val);

  void __set_max_filter_ratio(const double val);

  void __set_column_function_mapping(const std::map<std::string, TMiniLoadEtlFunction> & val);

  bool operator == (const TCsvScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(file_paths == rhs.file_paths))
      return false;
    if (__isset.column_separator != rhs.__isset.column_separator)
      return false;
    else if (__isset.column_separator && !(column_separator == rhs.column_separator))
      return false;
    if (__isset.line_delimiter != rhs.__isset.line_delimiter)
      return false;
    else if (__isset.line_delimiter && !(line_delimiter == rhs.line_delimiter))
      return false;
    if (__isset.column_type_mapping != rhs.__isset.column_type_mapping)
      return false;
    else if (__isset.column_type_mapping && !(column_type_mapping == rhs.column_type_mapping))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.unspecified_columns != rhs.__isset.unspecified_columns)
      return false;
    else if (__isset.unspecified_columns && !(unspecified_columns == rhs.unspecified_columns))
      return false;
    if (__isset.default_values != rhs.__isset.default_values)
      return false;
    else if (__isset.default_values && !(default_values == rhs.default_values))
      return false;
    if (__isset.max_filter_ratio != rhs.__isset.max_filter_ratio)
      return false;
    else if (__isset.max_filter_ratio && !(max_filter_ratio == rhs.max_filter_ratio))
      return false;
    if (__isset.column_function_mapping != rhs.__isset.column_function_mapping)
      return false;
    else if (__isset.column_function_mapping && !(column_function_mapping == rhs.column_function_mapping))
      return false;
    return true;
  }
  bool operator != (const TCsvScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCsvScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCsvScanNode &a, TCsvScanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TCsvScanNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TSchemaScanNode__isset {
  _TSchemaScanNode__isset() : db(false), table(false), wild(false), user(false), ip(false), port(false), thread_id(false) {}
  bool db :1;
  bool table :1;
  bool wild :1;
  bool user :1;
  bool ip :1;
  bool port :1;
  bool thread_id :1;
} _TSchemaScanNode__isset;

class TSchemaScanNode {
 public:

  TSchemaScanNode(const TSchemaScanNode&);
  TSchemaScanNode& operator=(const TSchemaScanNode&);
  TSchemaScanNode() : tuple_id(0), table_name(), db(), table(), wild(), user(), ip(), port(0), thread_id(0) {
  }

  virtual ~TSchemaScanNode() throw();
   ::palo::TTupleId tuple_id;
  std::string table_name;
  std::string db;
  std::string table;
  std::string wild;
  std::string user;
  std::string ip;
  int32_t port;
  int64_t thread_id;

  _TSchemaScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_table_name(const std::string& val);

  void __set_db(const std::string& val);

  void __set_table(const std::string& val);

  void __set_wild(const std::string& val);

  void __set_user(const std::string& val);

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  void __set_thread_id(const int64_t val);

  bool operator == (const TSchemaScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.table != rhs.__isset.table)
      return false;
    else if (__isset.table && !(table == rhs.table))
      return false;
    if (__isset.wild != rhs.__isset.wild)
      return false;
    else if (__isset.wild && !(wild == rhs.wild))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.ip != rhs.__isset.ip)
      return false;
    else if (__isset.ip && !(ip == rhs.ip))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (__isset.thread_id != rhs.__isset.thread_id)
      return false;
    else if (__isset.thread_id && !(thread_id == rhs.thread_id))
      return false;
    return true;
  }
  bool operator != (const TSchemaScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSchemaScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSchemaScanNode &a, TSchemaScanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TSchemaScanNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TMetaScanNode__isset {
  _TMetaScanNode__isset() : db(false), table(false), user(false) {}
  bool db :1;
  bool table :1;
  bool user :1;
} _TMetaScanNode__isset;

class TMetaScanNode {
 public:

  TMetaScanNode(const TMetaScanNode&);
  TMetaScanNode& operator=(const TMetaScanNode&);
  TMetaScanNode() : tuple_id(0), table_name(), db(), table(), user() {
  }

  virtual ~TMetaScanNode() throw();
   ::palo::TTupleId tuple_id;
  std::string table_name;
  std::string db;
  std::string table;
  std::string user;

  _TMetaScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_table_name(const std::string& val);

  void __set_db(const std::string& val);

  void __set_table(const std::string& val);

  void __set_user(const std::string& val);

  bool operator == (const TMetaScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.table != rhs.__isset.table)
      return false;
    else if (__isset.table && !(table == rhs.table))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const TMetaScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMetaScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMetaScanNode &a, TMetaScanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TMetaScanNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TOlapScanNode__isset {
  _TOlapScanNode__isset() : sort_column(false) {}
  bool sort_column :1;
} _TOlapScanNode__isset;

class TOlapScanNode {
 public:

  TOlapScanNode(const TOlapScanNode&);
  TOlapScanNode& operator=(const TOlapScanNode&);
  TOlapScanNode() : tuple_id(0), is_preaggregation(0), sort_column() {
  }

  virtual ~TOlapScanNode() throw();
   ::palo::TTupleId tuple_id;
  std::vector<std::string>  key_column_name;
  std::vector< ::palo::TPrimitiveType::type>  key_column_type;
  bool is_preaggregation;
  std::string sort_column;

  _TOlapScanNode__isset __isset;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_key_column_name(const std::vector<std::string> & val);

  void __set_key_column_type(const std::vector< ::palo::TPrimitiveType::type> & val);

  void __set_is_preaggregation(const bool val);

  void __set_sort_column(const std::string& val);

  bool operator == (const TOlapScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(key_column_name == rhs.key_column_name))
      return false;
    if (!(key_column_type == rhs.key_column_type))
      return false;
    if (!(is_preaggregation == rhs.is_preaggregation))
      return false;
    if (__isset.sort_column != rhs.__isset.sort_column)
      return false;
    else if (__isset.sort_column && !(sort_column == rhs.sort_column))
      return false;
    return true;
  }
  bool operator != (const TOlapScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOlapScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOlapScanNode &a, TOlapScanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TOlapScanNode& obj)
{
  obj.printTo(out);
  return out;
}


class TEqJoinCondition {
 public:

  TEqJoinCondition(const TEqJoinCondition&);
  TEqJoinCondition& operator=(const TEqJoinCondition&);
  TEqJoinCondition() {
  }

  virtual ~TEqJoinCondition() throw();
   ::palo::TExpr left;
   ::palo::TExpr right;

  void __set_left(const  ::palo::TExpr& val);

  void __set_right(const  ::palo::TExpr& val);

  bool operator == (const TEqJoinCondition & rhs) const
  {
    if (!(left == rhs.left))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const TEqJoinCondition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEqJoinCondition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEqJoinCondition &a, TEqJoinCondition &b);

inline std::ostream& operator<<(std::ostream& out, const TEqJoinCondition& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _THashJoinNode__isset {
  _THashJoinNode__isset() : other_join_conjuncts(false), is_push_down(false), add_probe_filters(false) {}
  bool other_join_conjuncts :1;
  bool is_push_down :1;
  bool add_probe_filters :1;
} _THashJoinNode__isset;

class THashJoinNode {
 public:

  THashJoinNode(const THashJoinNode&);
  THashJoinNode& operator=(const THashJoinNode&);
  THashJoinNode() : join_op((TJoinOp::type)0), is_push_down(0), add_probe_filters(0) {
  }

  virtual ~THashJoinNode() throw();
  TJoinOp::type join_op;
  std::vector<TEqJoinCondition>  eq_join_conjuncts;
  std::vector< ::palo::TExpr>  other_join_conjuncts;
  bool is_push_down;
  bool add_probe_filters;

  _THashJoinNode__isset __isset;

  void __set_join_op(const TJoinOp::type val);

  void __set_eq_join_conjuncts(const std::vector<TEqJoinCondition> & val);

  void __set_other_join_conjuncts(const std::vector< ::palo::TExpr> & val);

  void __set_is_push_down(const bool val);

  void __set_add_probe_filters(const bool val);

  bool operator == (const THashJoinNode & rhs) const
  {
    if (!(join_op == rhs.join_op))
      return false;
    if (!(eq_join_conjuncts == rhs.eq_join_conjuncts))
      return false;
    if (__isset.other_join_conjuncts != rhs.__isset.other_join_conjuncts)
      return false;
    else if (__isset.other_join_conjuncts && !(other_join_conjuncts == rhs.other_join_conjuncts))
      return false;
    if (__isset.is_push_down != rhs.__isset.is_push_down)
      return false;
    else if (__isset.is_push_down && !(is_push_down == rhs.is_push_down))
      return false;
    if (__isset.add_probe_filters != rhs.__isset.add_probe_filters)
      return false;
    else if (__isset.add_probe_filters && !(add_probe_filters == rhs.add_probe_filters))
      return false;
    return true;
  }
  bool operator != (const THashJoinNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THashJoinNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THashJoinNode &a, THashJoinNode &b);

inline std::ostream& operator<<(std::ostream& out, const THashJoinNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TMergeJoinNode__isset {
  _TMergeJoinNode__isset() : other_join_conjuncts(false) {}
  bool other_join_conjuncts :1;
} _TMergeJoinNode__isset;

class TMergeJoinNode {
 public:

  TMergeJoinNode(const TMergeJoinNode&);
  TMergeJoinNode& operator=(const TMergeJoinNode&);
  TMergeJoinNode() {
  }

  virtual ~TMergeJoinNode() throw();
  std::vector<TEqJoinCondition>  cmp_conjuncts;
  std::vector< ::palo::TExpr>  other_join_conjuncts;

  _TMergeJoinNode__isset __isset;

  void __set_cmp_conjuncts(const std::vector<TEqJoinCondition> & val);

  void __set_other_join_conjuncts(const std::vector< ::palo::TExpr> & val);

  bool operator == (const TMergeJoinNode & rhs) const
  {
    if (!(cmp_conjuncts == rhs.cmp_conjuncts))
      return false;
    if (__isset.other_join_conjuncts != rhs.__isset.other_join_conjuncts)
      return false;
    else if (__isset.other_join_conjuncts && !(other_join_conjuncts == rhs.other_join_conjuncts))
      return false;
    return true;
  }
  bool operator != (const TMergeJoinNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMergeJoinNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMergeJoinNode &a, TMergeJoinNode &b);

inline std::ostream& operator<<(std::ostream& out, const TMergeJoinNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TAggregationNode__isset {
  _TAggregationNode__isset() : grouping_exprs(false) {}
  bool grouping_exprs :1;
} _TAggregationNode__isset;

class TAggregationNode {
 public:

  TAggregationNode(const TAggregationNode&);
  TAggregationNode& operator=(const TAggregationNode&);
  TAggregationNode() : intermediate_tuple_id(0), output_tuple_id(0), need_finalize(0) {
  }

  virtual ~TAggregationNode() throw();
  std::vector< ::palo::TExpr>  grouping_exprs;
  std::vector< ::palo::TExpr>  aggregate_functions;
   ::palo::TTupleId intermediate_tuple_id;
   ::palo::TTupleId output_tuple_id;
  bool need_finalize;

  _TAggregationNode__isset __isset;

  void __set_grouping_exprs(const std::vector< ::palo::TExpr> & val);

  void __set_aggregate_functions(const std::vector< ::palo::TExpr> & val);

  void __set_intermediate_tuple_id(const  ::palo::TTupleId val);

  void __set_output_tuple_id(const  ::palo::TTupleId val);

  void __set_need_finalize(const bool val);

  bool operator == (const TAggregationNode & rhs) const
  {
    if (__isset.grouping_exprs != rhs.__isset.grouping_exprs)
      return false;
    else if (__isset.grouping_exprs && !(grouping_exprs == rhs.grouping_exprs))
      return false;
    if (!(aggregate_functions == rhs.aggregate_functions))
      return false;
    if (!(intermediate_tuple_id == rhs.intermediate_tuple_id))
      return false;
    if (!(output_tuple_id == rhs.output_tuple_id))
      return false;
    if (!(need_finalize == rhs.need_finalize))
      return false;
    return true;
  }
  bool operator != (const TAggregationNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregationNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggregationNode &a, TAggregationNode &b);

inline std::ostream& operator<<(std::ostream& out, const TAggregationNode& obj)
{
  obj.printTo(out);
  return out;
}


class TPreAggregationNode {
 public:

  TPreAggregationNode(const TPreAggregationNode&);
  TPreAggregationNode& operator=(const TPreAggregationNode&);
  TPreAggregationNode() {
  }

  virtual ~TPreAggregationNode() throw();
  std::vector< ::palo::TExpr>  group_exprs;
  std::vector< ::palo::TExpr>  aggregate_exprs;

  void __set_group_exprs(const std::vector< ::palo::TExpr> & val);

  void __set_aggregate_exprs(const std::vector< ::palo::TExpr> & val);

  bool operator == (const TPreAggregationNode & rhs) const
  {
    if (!(group_exprs == rhs.group_exprs))
      return false;
    if (!(aggregate_exprs == rhs.aggregate_exprs))
      return false;
    return true;
  }
  bool operator != (const TPreAggregationNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPreAggregationNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPreAggregationNode &a, TPreAggregationNode &b);

inline std::ostream& operator<<(std::ostream& out, const TPreAggregationNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TSortInfo__isset {
  _TSortInfo__isset() : sort_tuple_slot_exprs(false) {}
  bool sort_tuple_slot_exprs :1;
} _TSortInfo__isset;

class TSortInfo {
 public:

  TSortInfo(const TSortInfo&);
  TSortInfo& operator=(const TSortInfo&);
  TSortInfo() {
  }

  virtual ~TSortInfo() throw();
  std::vector< ::palo::TExpr>  ordering_exprs;
  std::vector<bool>  is_asc_order;
  std::vector<bool>  nulls_first;
  std::vector< ::palo::TExpr>  sort_tuple_slot_exprs;

  _TSortInfo__isset __isset;

  void __set_ordering_exprs(const std::vector< ::palo::TExpr> & val);

  void __set_is_asc_order(const std::vector<bool> & val);

  void __set_nulls_first(const std::vector<bool> & val);

  void __set_sort_tuple_slot_exprs(const std::vector< ::palo::TExpr> & val);

  bool operator == (const TSortInfo & rhs) const
  {
    if (!(ordering_exprs == rhs.ordering_exprs))
      return false;
    if (!(is_asc_order == rhs.is_asc_order))
      return false;
    if (!(nulls_first == rhs.nulls_first))
      return false;
    if (__isset.sort_tuple_slot_exprs != rhs.__isset.sort_tuple_slot_exprs)
      return false;
    else if (__isset.sort_tuple_slot_exprs && !(sort_tuple_slot_exprs == rhs.sort_tuple_slot_exprs))
      return false;
    return true;
  }
  bool operator != (const TSortInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSortInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSortInfo &a, TSortInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TSortInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TSortNode__isset {
  _TSortNode__isset() : offset(false), ordering_exprs(false), is_asc_order(false), is_default_limit(false), nulls_first(false), sort_tuple_slot_exprs(false) {}
  bool offset :1;
  bool ordering_exprs :1;
  bool is_asc_order :1;
  bool is_default_limit :1;
  bool nulls_first :1;
  bool sort_tuple_slot_exprs :1;
} _TSortNode__isset;

class TSortNode {
 public:

  TSortNode(const TSortNode&);
  TSortNode& operator=(const TSortNode&);
  TSortNode() : use_top_n(0), offset(0), is_default_limit(0) {
  }

  virtual ~TSortNode() throw();
  TSortInfo sort_info;
  bool use_top_n;
  int64_t offset;
  std::vector< ::palo::TExpr>  ordering_exprs;
  std::vector<bool>  is_asc_order;
  bool is_default_limit;
  std::vector<bool>  nulls_first;
  std::vector< ::palo::TExpr>  sort_tuple_slot_exprs;

  _TSortNode__isset __isset;

  void __set_sort_info(const TSortInfo& val);

  void __set_use_top_n(const bool val);

  void __set_offset(const int64_t val);

  void __set_ordering_exprs(const std::vector< ::palo::TExpr> & val);

  void __set_is_asc_order(const std::vector<bool> & val);

  void __set_is_default_limit(const bool val);

  void __set_nulls_first(const std::vector<bool> & val);

  void __set_sort_tuple_slot_exprs(const std::vector< ::palo::TExpr> & val);

  bool operator == (const TSortNode & rhs) const
  {
    if (!(sort_info == rhs.sort_info))
      return false;
    if (!(use_top_n == rhs.use_top_n))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.ordering_exprs != rhs.__isset.ordering_exprs)
      return false;
    else if (__isset.ordering_exprs && !(ordering_exprs == rhs.ordering_exprs))
      return false;
    if (__isset.is_asc_order != rhs.__isset.is_asc_order)
      return false;
    else if (__isset.is_asc_order && !(is_asc_order == rhs.is_asc_order))
      return false;
    if (__isset.is_default_limit != rhs.__isset.is_default_limit)
      return false;
    else if (__isset.is_default_limit && !(is_default_limit == rhs.is_default_limit))
      return false;
    if (__isset.nulls_first != rhs.__isset.nulls_first)
      return false;
    else if (__isset.nulls_first && !(nulls_first == rhs.nulls_first))
      return false;
    if (__isset.sort_tuple_slot_exprs != rhs.__isset.sort_tuple_slot_exprs)
      return false;
    else if (__isset.sort_tuple_slot_exprs && !(sort_tuple_slot_exprs == rhs.sort_tuple_slot_exprs))
      return false;
    return true;
  }
  bool operator != (const TSortNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSortNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSortNode &a, TSortNode &b);

inline std::ostream& operator<<(std::ostream& out, const TSortNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TAnalyticWindowBoundary__isset {
  _TAnalyticWindowBoundary__isset() : range_offset_predicate(false), rows_offset_value(false) {}
  bool range_offset_predicate :1;
  bool rows_offset_value :1;
} _TAnalyticWindowBoundary__isset;

class TAnalyticWindowBoundary {
 public:

  TAnalyticWindowBoundary(const TAnalyticWindowBoundary&);
  TAnalyticWindowBoundary& operator=(const TAnalyticWindowBoundary&);
  TAnalyticWindowBoundary() : type((TAnalyticWindowBoundaryType::type)0), rows_offset_value(0) {
  }

  virtual ~TAnalyticWindowBoundary() throw();
  TAnalyticWindowBoundaryType::type type;
   ::palo::TExpr range_offset_predicate;
  int64_t rows_offset_value;

  _TAnalyticWindowBoundary__isset __isset;

  void __set_type(const TAnalyticWindowBoundaryType::type val);

  void __set_range_offset_predicate(const  ::palo::TExpr& val);

  void __set_rows_offset_value(const int64_t val);

  bool operator == (const TAnalyticWindowBoundary & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.range_offset_predicate != rhs.__isset.range_offset_predicate)
      return false;
    else if (__isset.range_offset_predicate && !(range_offset_predicate == rhs.range_offset_predicate))
      return false;
    if (__isset.rows_offset_value != rhs.__isset.rows_offset_value)
      return false;
    else if (__isset.rows_offset_value && !(rows_offset_value == rhs.rows_offset_value))
      return false;
    return true;
  }
  bool operator != (const TAnalyticWindowBoundary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAnalyticWindowBoundary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAnalyticWindowBoundary &a, TAnalyticWindowBoundary &b);

inline std::ostream& operator<<(std::ostream& out, const TAnalyticWindowBoundary& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TAnalyticWindow__isset {
  _TAnalyticWindow__isset() : window_start(false), window_end(false) {}
  bool window_start :1;
  bool window_end :1;
} _TAnalyticWindow__isset;

class TAnalyticWindow {
 public:

  TAnalyticWindow(const TAnalyticWindow&);
  TAnalyticWindow& operator=(const TAnalyticWindow&);
  TAnalyticWindow() : type((TAnalyticWindowType::type)0) {
  }

  virtual ~TAnalyticWindow() throw();
  TAnalyticWindowType::type type;
  TAnalyticWindowBoundary window_start;
  TAnalyticWindowBoundary window_end;

  _TAnalyticWindow__isset __isset;

  void __set_type(const TAnalyticWindowType::type val);

  void __set_window_start(const TAnalyticWindowBoundary& val);

  void __set_window_end(const TAnalyticWindowBoundary& val);

  bool operator == (const TAnalyticWindow & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.window_start != rhs.__isset.window_start)
      return false;
    else if (__isset.window_start && !(window_start == rhs.window_start))
      return false;
    if (__isset.window_end != rhs.__isset.window_end)
      return false;
    else if (__isset.window_end && !(window_end == rhs.window_end))
      return false;
    return true;
  }
  bool operator != (const TAnalyticWindow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAnalyticWindow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAnalyticWindow &a, TAnalyticWindow &b);

inline std::ostream& operator<<(std::ostream& out, const TAnalyticWindow& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TAnalyticNode__isset {
  _TAnalyticNode__isset() : window(false), buffered_tuple_id(false), partition_by_eq(false), order_by_eq(false) {}
  bool window :1;
  bool buffered_tuple_id :1;
  bool partition_by_eq :1;
  bool order_by_eq :1;
} _TAnalyticNode__isset;

class TAnalyticNode {
 public:

  TAnalyticNode(const TAnalyticNode&);
  TAnalyticNode& operator=(const TAnalyticNode&);
  TAnalyticNode() : intermediate_tuple_id(0), output_tuple_id(0), buffered_tuple_id(0) {
  }

  virtual ~TAnalyticNode() throw();
  std::vector< ::palo::TExpr>  partition_exprs;
  std::vector< ::palo::TExpr>  order_by_exprs;
  std::vector< ::palo::TExpr>  analytic_functions;
  TAnalyticWindow window;
   ::palo::TTupleId intermediate_tuple_id;
   ::palo::TTupleId output_tuple_id;
   ::palo::TTupleId buffered_tuple_id;
   ::palo::TExpr partition_by_eq;
   ::palo::TExpr order_by_eq;

  _TAnalyticNode__isset __isset;

  void __set_partition_exprs(const std::vector< ::palo::TExpr> & val);

  void __set_order_by_exprs(const std::vector< ::palo::TExpr> & val);

  void __set_analytic_functions(const std::vector< ::palo::TExpr> & val);

  void __set_window(const TAnalyticWindow& val);

  void __set_intermediate_tuple_id(const  ::palo::TTupleId val);

  void __set_output_tuple_id(const  ::palo::TTupleId val);

  void __set_buffered_tuple_id(const  ::palo::TTupleId val);

  void __set_partition_by_eq(const  ::palo::TExpr& val);

  void __set_order_by_eq(const  ::palo::TExpr& val);

  bool operator == (const TAnalyticNode & rhs) const
  {
    if (!(partition_exprs == rhs.partition_exprs))
      return false;
    if (!(order_by_exprs == rhs.order_by_exprs))
      return false;
    if (!(analytic_functions == rhs.analytic_functions))
      return false;
    if (__isset.window != rhs.__isset.window)
      return false;
    else if (__isset.window && !(window == rhs.window))
      return false;
    if (!(intermediate_tuple_id == rhs.intermediate_tuple_id))
      return false;
    if (!(output_tuple_id == rhs.output_tuple_id))
      return false;
    if (__isset.buffered_tuple_id != rhs.__isset.buffered_tuple_id)
      return false;
    else if (__isset.buffered_tuple_id && !(buffered_tuple_id == rhs.buffered_tuple_id))
      return false;
    if (__isset.partition_by_eq != rhs.__isset.partition_by_eq)
      return false;
    else if (__isset.partition_by_eq && !(partition_by_eq == rhs.partition_by_eq))
      return false;
    if (__isset.order_by_eq != rhs.__isset.order_by_eq)
      return false;
    else if (__isset.order_by_eq && !(order_by_eq == rhs.order_by_eq))
      return false;
    return true;
  }
  bool operator != (const TAnalyticNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAnalyticNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAnalyticNode &a, TAnalyticNode &b);

inline std::ostream& operator<<(std::ostream& out, const TAnalyticNode& obj)
{
  obj.printTo(out);
  return out;
}


class TMergeNode {
 public:

  TMergeNode(const TMergeNode&);
  TMergeNode& operator=(const TMergeNode&);
  TMergeNode() : tuple_id(0) {
  }

  virtual ~TMergeNode() throw();
   ::palo::TTupleId tuple_id;
  std::vector<std::vector< ::palo::TExpr> >  result_expr_lists;
  std::vector<std::vector< ::palo::TExpr> >  const_expr_lists;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_result_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val);

  void __set_const_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val);

  bool operator == (const TMergeNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(result_expr_lists == rhs.result_expr_lists))
      return false;
    if (!(const_expr_lists == rhs.const_expr_lists))
      return false;
    return true;
  }
  bool operator != (const TMergeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMergeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMergeNode &a, TMergeNode &b);

inline std::ostream& operator<<(std::ostream& out, const TMergeNode& obj)
{
  obj.printTo(out);
  return out;
}


class TUnionNode {
 public:

  TUnionNode(const TUnionNode&);
  TUnionNode& operator=(const TUnionNode&);
  TUnionNode() : tuple_id(0), first_materialized_child_idx(0) {
  }

  virtual ~TUnionNode() throw();
   ::palo::TTupleId tuple_id;
  std::vector<std::vector< ::palo::TExpr> >  result_expr_lists;
  std::vector<std::vector< ::palo::TExpr> >  const_expr_lists;
  int64_t first_materialized_child_idx;

  void __set_tuple_id(const  ::palo::TTupleId val);

  void __set_result_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val);

  void __set_const_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val);

  void __set_first_materialized_child_idx(const int64_t val);

  bool operator == (const TUnionNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(result_expr_lists == rhs.result_expr_lists))
      return false;
    if (!(const_expr_lists == rhs.const_expr_lists))
      return false;
    if (!(first_materialized_child_idx == rhs.first_materialized_child_idx))
      return false;
    return true;
  }
  bool operator != (const TUnionNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUnionNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUnionNode &a, TUnionNode &b);

inline std::ostream& operator<<(std::ostream& out, const TUnionNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TExchangeNode__isset {
  _TExchangeNode__isset() : sort_info(false), offset(false) {}
  bool sort_info :1;
  bool offset :1;
} _TExchangeNode__isset;

class TExchangeNode {
 public:

  TExchangeNode(const TExchangeNode&);
  TExchangeNode& operator=(const TExchangeNode&);
  TExchangeNode() : offset(0) {
  }

  virtual ~TExchangeNode() throw();
  std::vector< ::palo::TTupleId>  input_row_tuples;
  TSortInfo sort_info;
  int64_t offset;

  _TExchangeNode__isset __isset;

  void __set_input_row_tuples(const std::vector< ::palo::TTupleId> & val);

  void __set_sort_info(const TSortInfo& val);

  void __set_offset(const int64_t val);

  bool operator == (const TExchangeNode & rhs) const
  {
    if (!(input_row_tuples == rhs.input_row_tuples))
      return false;
    if (__isset.sort_info != rhs.__isset.sort_info)
      return false;
    else if (__isset.sort_info && !(sort_info == rhs.sort_info))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const TExchangeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExchangeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExchangeNode &a, TExchangeNode &b);

inline std::ostream& operator<<(std::ostream& out, const TExchangeNode& obj)
{
  obj.printTo(out);
  return out;
}


class TOlapRewriteNode {
 public:

  TOlapRewriteNode(const TOlapRewriteNode&);
  TOlapRewriteNode& operator=(const TOlapRewriteNode&);
  TOlapRewriteNode() : output_tuple_id(0) {
  }

  virtual ~TOlapRewriteNode() throw();
  std::vector< ::palo::TExpr>  columns;
  std::vector< ::palo::TColumnType>  column_types;
   ::palo::TTupleId output_tuple_id;

  void __set_columns(const std::vector< ::palo::TExpr> & val);

  void __set_column_types(const std::vector< ::palo::TColumnType> & val);

  void __set_output_tuple_id(const  ::palo::TTupleId val);

  bool operator == (const TOlapRewriteNode & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (!(column_types == rhs.column_types))
      return false;
    if (!(output_tuple_id == rhs.output_tuple_id))
      return false;
    return true;
  }
  bool operator != (const TOlapRewriteNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOlapRewriteNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOlapRewriteNode &a, TOlapRewriteNode &b);

inline std::ostream& operator<<(std::ostream& out, const TOlapRewriteNode& obj)
{
  obj.printTo(out);
  return out;
}


class TKuduScanNode {
 public:

  TKuduScanNode(const TKuduScanNode&);
  TKuduScanNode& operator=(const TKuduScanNode&);
  TKuduScanNode() : tuple_id(0) {
  }

  virtual ~TKuduScanNode() throw();
   ::palo::TTupleId tuple_id;

  void __set_tuple_id(const  ::palo::TTupleId val);

  bool operator == (const TKuduScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    return true;
  }
  bool operator != (const TKuduScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduScanNode &a, TKuduScanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TKuduScanNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPlanNode__isset {
  _TPlanNode__isset() : conjuncts(false), hash_join_node(false), agg_node(false), sort_node(false), merge_node(false), exchange_node(false), mysql_scan_node(false), olap_scan_node(false), csv_scan_node(false), broker_scan_node(false), pre_agg_node(false), schema_scan_node(false), merge_join_node(false), meta_scan_node(false), analytic_node(false), olap_rewrite_node(false), kudu_scan_node(false), union_node(false) {}
  bool conjuncts :1;
  bool hash_join_node :1;
  bool agg_node :1;
  bool sort_node :1;
  bool merge_node :1;
  bool exchange_node :1;
  bool mysql_scan_node :1;
  bool olap_scan_node :1;
  bool csv_scan_node :1;
  bool broker_scan_node :1;
  bool pre_agg_node :1;
  bool schema_scan_node :1;
  bool merge_join_node :1;
  bool meta_scan_node :1;
  bool analytic_node :1;
  bool olap_rewrite_node :1;
  bool kudu_scan_node :1;
  bool union_node :1;
} _TPlanNode__isset;

class TPlanNode {
 public:

  TPlanNode(const TPlanNode&);
  TPlanNode& operator=(const TPlanNode&);
  TPlanNode() : node_id(0), node_type((TPlanNodeType::type)0), num_children(0), limit(0), compact_data(0) {
  }

  virtual ~TPlanNode() throw();
   ::palo::TPlanNodeId node_id;
  TPlanNodeType::type node_type;
  int32_t num_children;
  int64_t limit;
  std::vector< ::palo::TTupleId>  row_tuples;
  std::vector<bool>  nullable_tuples;
  std::vector< ::palo::TExpr>  conjuncts;
  bool compact_data;
  THashJoinNode hash_join_node;
  TAggregationNode agg_node;
  TSortNode sort_node;
  TMergeNode merge_node;
  TExchangeNode exchange_node;
  TMySQLScanNode mysql_scan_node;
  TOlapScanNode olap_scan_node;
  TCsvScanNode csv_scan_node;
  TBrokerScanNode broker_scan_node;
  TPreAggregationNode pre_agg_node;
  TSchemaScanNode schema_scan_node;
  TMergeJoinNode merge_join_node;
  TMetaScanNode meta_scan_node;
  TAnalyticNode analytic_node;
  TOlapRewriteNode olap_rewrite_node;
  TKuduScanNode kudu_scan_node;
  TUnionNode union_node;

  _TPlanNode__isset __isset;

  void __set_node_id(const  ::palo::TPlanNodeId val);

  void __set_node_type(const TPlanNodeType::type val);

  void __set_num_children(const int32_t val);

  void __set_limit(const int64_t val);

  void __set_row_tuples(const std::vector< ::palo::TTupleId> & val);

  void __set_nullable_tuples(const std::vector<bool> & val);

  void __set_conjuncts(const std::vector< ::palo::TExpr> & val);

  void __set_compact_data(const bool val);

  void __set_hash_join_node(const THashJoinNode& val);

  void __set_agg_node(const TAggregationNode& val);

  void __set_sort_node(const TSortNode& val);

  void __set_merge_node(const TMergeNode& val);

  void __set_exchange_node(const TExchangeNode& val);

  void __set_mysql_scan_node(const TMySQLScanNode& val);

  void __set_olap_scan_node(const TOlapScanNode& val);

  void __set_csv_scan_node(const TCsvScanNode& val);

  void __set_broker_scan_node(const TBrokerScanNode& val);

  void __set_pre_agg_node(const TPreAggregationNode& val);

  void __set_schema_scan_node(const TSchemaScanNode& val);

  void __set_merge_join_node(const TMergeJoinNode& val);

  void __set_meta_scan_node(const TMetaScanNode& val);

  void __set_analytic_node(const TAnalyticNode& val);

  void __set_olap_rewrite_node(const TOlapRewriteNode& val);

  void __set_kudu_scan_node(const TKuduScanNode& val);

  void __set_union_node(const TUnionNode& val);

  bool operator == (const TPlanNode & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    if (!(node_type == rhs.node_type))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(row_tuples == rhs.row_tuples))
      return false;
    if (!(nullable_tuples == rhs.nullable_tuples))
      return false;
    if (__isset.conjuncts != rhs.__isset.conjuncts)
      return false;
    else if (__isset.conjuncts && !(conjuncts == rhs.conjuncts))
      return false;
    if (!(compact_data == rhs.compact_data))
      return false;
    if (__isset.hash_join_node != rhs.__isset.hash_join_node)
      return false;
    else if (__isset.hash_join_node && !(hash_join_node == rhs.hash_join_node))
      return false;
    if (__isset.agg_node != rhs.__isset.agg_node)
      return false;
    else if (__isset.agg_node && !(agg_node == rhs.agg_node))
      return false;
    if (__isset.sort_node != rhs.__isset.sort_node)
      return false;
    else if (__isset.sort_node && !(sort_node == rhs.sort_node))
      return false;
    if (__isset.merge_node != rhs.__isset.merge_node)
      return false;
    else if (__isset.merge_node && !(merge_node == rhs.merge_node))
      return false;
    if (__isset.exchange_node != rhs.__isset.exchange_node)
      return false;
    else if (__isset.exchange_node && !(exchange_node == rhs.exchange_node))
      return false;
    if (__isset.mysql_scan_node != rhs.__isset.mysql_scan_node)
      return false;
    else if (__isset.mysql_scan_node && !(mysql_scan_node == rhs.mysql_scan_node))
      return false;
    if (__isset.olap_scan_node != rhs.__isset.olap_scan_node)
      return false;
    else if (__isset.olap_scan_node && !(olap_scan_node == rhs.olap_scan_node))
      return false;
    if (__isset.csv_scan_node != rhs.__isset.csv_scan_node)
      return false;
    else if (__isset.csv_scan_node && !(csv_scan_node == rhs.csv_scan_node))
      return false;
    if (__isset.broker_scan_node != rhs.__isset.broker_scan_node)
      return false;
    else if (__isset.broker_scan_node && !(broker_scan_node == rhs.broker_scan_node))
      return false;
    if (__isset.pre_agg_node != rhs.__isset.pre_agg_node)
      return false;
    else if (__isset.pre_agg_node && !(pre_agg_node == rhs.pre_agg_node))
      return false;
    if (__isset.schema_scan_node != rhs.__isset.schema_scan_node)
      return false;
    else if (__isset.schema_scan_node && !(schema_scan_node == rhs.schema_scan_node))
      return false;
    if (__isset.merge_join_node != rhs.__isset.merge_join_node)
      return false;
    else if (__isset.merge_join_node && !(merge_join_node == rhs.merge_join_node))
      return false;
    if (__isset.meta_scan_node != rhs.__isset.meta_scan_node)
      return false;
    else if (__isset.meta_scan_node && !(meta_scan_node == rhs.meta_scan_node))
      return false;
    if (__isset.analytic_node != rhs.__isset.analytic_node)
      return false;
    else if (__isset.analytic_node && !(analytic_node == rhs.analytic_node))
      return false;
    if (__isset.olap_rewrite_node != rhs.__isset.olap_rewrite_node)
      return false;
    else if (__isset.olap_rewrite_node && !(olap_rewrite_node == rhs.olap_rewrite_node))
      return false;
    if (__isset.kudu_scan_node != rhs.__isset.kudu_scan_node)
      return false;
    else if (__isset.kudu_scan_node && !(kudu_scan_node == rhs.kudu_scan_node))
      return false;
    if (__isset.union_node != rhs.__isset.union_node)
      return false;
    else if (__isset.union_node && !(union_node == rhs.union_node))
      return false;
    return true;
  }
  bool operator != (const TPlanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlanNode &a, TPlanNode &b);

inline std::ostream& operator<<(std::ostream& out, const TPlanNode& obj)
{
  obj.printTo(out);
  return out;
}


class TPlan {
 public:

  TPlan(const TPlan&);
  TPlan& operator=(const TPlan&);
  TPlan() {
  }

  virtual ~TPlan() throw();
  std::vector<TPlanNode>  nodes;

  void __set_nodes(const std::vector<TPlanNode> & val);

  bool operator == (const TPlan & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TPlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlan &a, TPlan &b);

inline std::ostream& operator<<(std::ostream& out, const TPlan& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
