/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Ddl_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTCommonDdlTypeValues[] = {
  TCommonDdlType::CREATE_DATABASE,
  TCommonDdlType::DROP_DATABASE,
  TCommonDdlType::CREATE_TABLE,
  TCommonDdlType::DROP_TABLE,
  TCommonDdlType::LOAD
};
const char* _kTCommonDdlTypeNames[] = {
  "CREATE_DATABASE",
  "DROP_DATABASE",
  "CREATE_TABLE",
  "DROP_TABLE",
  "LOAD"
};
const std::map<int, const char*> _TCommonDdlType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTCommonDdlTypeValues, _kTCommonDdlTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAggTypeValues[] = {
  TAggType::AGG_SUM,
  TAggType::AGG_MIN,
  TAggType::AGG_MAX,
  TAggType::AGG_REPLACE
};
const char* _kTAggTypeNames[] = {
  "AGG_SUM",
  "AGG_MIN",
  "AGG_MAX",
  "AGG_REPLACE"
};
const std::map<int, const char*> _TAggType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTAggTypeValues, _kTAggTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTHashTypeValues[] = {
  THashType::CRC32
};
const char* _kTHashTypeNames[] = {
  "CRC32"
};
const std::map<int, const char*> _THashType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTHashTypeValues, _kTHashTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPrivTypeValues[] = {
  TPrivType::PRIVILEGE_READ_ONLY,
  TPrivType::PRIVILEGE_READ_WRITE
};
const char* _kTPrivTypeNames[] = {
  "PRIVILEGE_READ_ONLY",
  "PRIVILEGE_READ_WRITE"
};
const std::map<int, const char*> _TPrivType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTPrivTypeValues, _kTPrivTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPaloInternalServiceVersionValues[] = {
  TPaloInternalServiceVersion::V1
};
const char* _kTPaloInternalServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _TPaloInternalServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTPaloInternalServiceVersionValues, _kTPaloInternalServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TDdlResult::~TDdlResult() throw() {
}


void TDdlResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

uint32_t TDdlResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDdlResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDdlResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDdlResult &a, TDdlResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TDdlResult::TDdlResult(const TDdlResult& other0) {
  status = other0.status;
  __isset = other0.__isset;
}
TDdlResult& TDdlResult::operator=(const TDdlResult& other1) {
  status = other1.status;
  __isset = other1.__isset;
  return *this;
}
void TDdlResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDdlResult(";
  out << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


TCreateDbParams::~TCreateDbParams() throw() {
}


void TCreateDbParams::__set_database_name(const std::string& val) {
  this->database_name = val;
}

uint32_t TCreateDbParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_database_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database_name);
          isset_database_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_database_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateDbParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateDbParams");

  xfer += oprot->writeFieldBegin("database_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->database_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateDbParams &a, TCreateDbParams &b) {
  using ::std::swap;
  swap(a.database_name, b.database_name);
}

TCreateDbParams::TCreateDbParams(const TCreateDbParams& other2) {
  database_name = other2.database_name;
}
TCreateDbParams& TCreateDbParams::operator=(const TCreateDbParams& other3) {
  database_name = other3.database_name;
  return *this;
}
void TCreateDbParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateDbParams(";
  out << "database_name=" << to_string(database_name);
  out << ")";
}


TDropDbParams::~TDropDbParams() throw() {
}


void TDropDbParams::__set_database_name(const std::string& val) {
  this->database_name = val;
}

uint32_t TDropDbParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_database_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database_name);
          isset_database_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_database_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropDbParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropDbParams");

  xfer += oprot->writeFieldBegin("database_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->database_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropDbParams &a, TDropDbParams &b) {
  using ::std::swap;
  swap(a.database_name, b.database_name);
}

TDropDbParams::TDropDbParams(const TDropDbParams& other4) {
  database_name = other4.database_name;
}
TDropDbParams& TDropDbParams::operator=(const TDropDbParams& other5) {
  database_name = other5.database_name;
  return *this;
}
void TDropDbParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDropDbParams(";
  out << "database_name=" << to_string(database_name);
  out << ")";
}


TTableName::~TTableName() throw() {
}


void TTableName::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TTableName::__set_table_name(const std::string& val) {
  this->table_name = val;
}

uint32_t TTableName::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableName");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableName &a, TTableName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
}

TTableName::TTableName(const TTableName& other6) {
  db_name = other6.db_name;
  table_name = other6.table_name;
}
TTableName& TTableName::operator=(const TTableName& other7) {
  db_name = other7.db_name;
  table_name = other7.table_name;
  return *this;
}
void TTableName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableName(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ")";
}


TRandomPartitionDesc::~TRandomPartitionDesc() throw() {
}


uint32_t TRandomPartitionDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRandomPartitionDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRandomPartitionDesc");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRandomPartitionDesc &a, TRandomPartitionDesc &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TRandomPartitionDesc::TRandomPartitionDesc(const TRandomPartitionDesc& other8) {
  (void) other8;
}
TRandomPartitionDesc& TRandomPartitionDesc::operator=(const TRandomPartitionDesc& other9) {
  (void) other9;
  return *this;
}
void TRandomPartitionDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRandomPartitionDesc(";
  out << ")";
}


THashPartitionDesc::~THashPartitionDesc() throw() {
}


void THashPartitionDesc::__set_column_list(const std::vector<std::string> & val) {
  this->column_list = val;
}

void THashPartitionDesc::__set_hash_buckets(const int32_t val) {
  this->hash_buckets = val;
}

void THashPartitionDesc::__set_hash_type(const THashType::type val) {
  this->hash_type = val;
__isset.hash_type = true;
}

uint32_t THashPartitionDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_list = false;
  bool isset_hash_buckets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_list.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->column_list.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readString(this->column_list[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          isset_column_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hash_buckets);
          isset_hash_buckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->hash_type = (THashType::type)ecast15;
          this->__isset.hash_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hash_buckets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THashPartitionDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THashPartitionDesc");

  xfer += oprot->writeFieldBegin("column_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_list.size()));
    std::vector<std::string> ::const_iterator _iter16;
    for (_iter16 = this->column_list.begin(); _iter16 != this->column_list.end(); ++_iter16)
    {
      xfer += oprot->writeString((*_iter16));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hash_buckets", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->hash_buckets);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hash_type) {
    xfer += oprot->writeFieldBegin("hash_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->hash_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THashPartitionDesc &a, THashPartitionDesc &b) {
  using ::std::swap;
  swap(a.column_list, b.column_list);
  swap(a.hash_buckets, b.hash_buckets);
  swap(a.hash_type, b.hash_type);
  swap(a.__isset, b.__isset);
}

THashPartitionDesc::THashPartitionDesc(const THashPartitionDesc& other17) {
  column_list = other17.column_list;
  hash_buckets = other17.hash_buckets;
  hash_type = other17.hash_type;
  __isset = other17.__isset;
}
THashPartitionDesc& THashPartitionDesc::operator=(const THashPartitionDesc& other18) {
  column_list = other18.column_list;
  hash_buckets = other18.hash_buckets;
  hash_type = other18.hash_type;
  __isset = other18.__isset;
  return *this;
}
void THashPartitionDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THashPartitionDesc(";
  out << "column_list=" << to_string(column_list);
  out << ", " << "hash_buckets=" << to_string(hash_buckets);
  out << ", " << "hash_type="; (__isset.hash_type ? (out << to_string(hash_type)) : (out << "<null>"));
  out << ")";
}


TValue::~TValue() throw() {
}


void TValue::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}

void TValue::__set_max_sign(const bool val) {
  this->max_sign = val;
__isset.max_sign = true;
}

uint32_t TValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->max_sign);
          this->__isset.max_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_sign) {
    xfer += oprot->writeFieldBegin("max_sign", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->max_sign);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TValue &a, TValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.max_sign, b.max_sign);
  swap(a.__isset, b.__isset);
}

TValue::TValue(const TValue& other19) {
  value = other19.value;
  max_sign = other19.max_sign;
  __isset = other19.__isset;
}
TValue& TValue::operator=(const TValue& other20) {
  value = other20.value;
  max_sign = other20.max_sign;
  __isset = other20.__isset;
  return *this;
}
void TValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TValue(";
  out << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "max_sign="; (__isset.max_sign ? (out << to_string(max_sign)) : (out << "<null>"));
  out << ")";
}


TRangeValue::~TRangeValue() throw() {
}


void TRangeValue::__set_value_list(const std::vector<TValue> & val) {
  this->value_list = val;
}

uint32_t TRangeValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value_list.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->value_list.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->value_list[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_value_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRangeValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRangeValue");

  xfer += oprot->writeFieldBegin("value_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->value_list.size()));
    std::vector<TValue> ::const_iterator _iter26;
    for (_iter26 = this->value_list.begin(); _iter26 != this->value_list.end(); ++_iter26)
    {
      xfer += (*_iter26).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRangeValue &a, TRangeValue &b) {
  using ::std::swap;
  swap(a.value_list, b.value_list);
}

TRangeValue::TRangeValue(const TRangeValue& other27) {
  value_list = other27.value_list;
}
TRangeValue& TRangeValue::operator=(const TRangeValue& other28) {
  value_list = other28.value_list;
  return *this;
}
void TRangeValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRangeValue(";
  out << "value_list=" << to_string(value_list);
  out << ")";
}


TRangePartitionDesc::~TRangePartitionDesc() throw() {
}


void TRangePartitionDesc::__set_column_list(const std::vector<std::string> & val) {
  this->column_list = val;
}

void TRangePartitionDesc::__set_range_value(const std::vector<TRangeValue> & val) {
  this->range_value = val;
__isset.range_value = true;
}

uint32_t TRangePartitionDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_list.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->column_list.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readString(this->column_list[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          isset_column_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_value.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->range_value.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->range_value[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRangePartitionDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRangePartitionDesc");

  xfer += oprot->writeFieldBegin("column_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_list.size()));
    std::vector<std::string> ::const_iterator _iter39;
    for (_iter39 = this->column_list.begin(); _iter39 != this->column_list.end(); ++_iter39)
    {
      xfer += oprot->writeString((*_iter39));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.range_value) {
    xfer += oprot->writeFieldBegin("range_value", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->range_value.size()));
      std::vector<TRangeValue> ::const_iterator _iter40;
      for (_iter40 = this->range_value.begin(); _iter40 != this->range_value.end(); ++_iter40)
      {
        xfer += (*_iter40).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRangePartitionDesc &a, TRangePartitionDesc &b) {
  using ::std::swap;
  swap(a.column_list, b.column_list);
  swap(a.range_value, b.range_value);
  swap(a.__isset, b.__isset);
}

TRangePartitionDesc::TRangePartitionDesc(const TRangePartitionDesc& other41) {
  column_list = other41.column_list;
  range_value = other41.range_value;
  __isset = other41.__isset;
}
TRangePartitionDesc& TRangePartitionDesc::operator=(const TRangePartitionDesc& other42) {
  column_list = other42.column_list;
  range_value = other42.range_value;
  __isset = other42.__isset;
  return *this;
}
void TRangePartitionDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRangePartitionDesc(";
  out << "column_list=" << to_string(column_list);
  out << ", " << "range_value="; (__isset.range_value ? (out << to_string(range_value)) : (out << "<null>"));
  out << ")";
}


TPartitionDesc::~TPartitionDesc() throw() {
}


void TPartitionDesc::__set_type(const  ::palo::TPartitionType::type val) {
  this->type = val;
}

void TPartitionDesc::__set_partition_num(const int32_t val) {
  this->partition_num = val;
}

void TPartitionDesc::__set_hash_partition(const THashPartitionDesc& val) {
  this->hash_partition = val;
__isset.hash_partition = true;
}

void TPartitionDesc::__set_range_partition(const TRangePartitionDesc& val) {
  this->range_partition = val;
__isset.range_partition = true;
}

void TPartitionDesc::__set_random_partition(const TRandomPartitionDesc& val) {
  this->random_partition = val;
__isset.random_partition = true;
}

uint32_t TPartitionDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_partition_num = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast43;
          xfer += iprot->readI32(ecast43);
          this->type = ( ::palo::TPartitionType::type)ecast43;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_num);
          isset_partition_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hash_partition.read(iprot);
          this->__isset.hash_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range_partition.read(iprot);
          this->__isset.range_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->random_partition.read(iprot);
          this->__isset.random_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPartitionDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartitionDesc");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->partition_num);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hash_partition) {
    xfer += oprot->writeFieldBegin("hash_partition", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->hash_partition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range_partition) {
    xfer += oprot->writeFieldBegin("range_partition", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->range_partition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.random_partition) {
    xfer += oprot->writeFieldBegin("random_partition", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->random_partition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPartitionDesc &a, TPartitionDesc &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.partition_num, b.partition_num);
  swap(a.hash_partition, b.hash_partition);
  swap(a.range_partition, b.range_partition);
  swap(a.random_partition, b.random_partition);
  swap(a.__isset, b.__isset);
}

TPartitionDesc::TPartitionDesc(const TPartitionDesc& other44) {
  type = other44.type;
  partition_num = other44.partition_num;
  hash_partition = other44.hash_partition;
  range_partition = other44.range_partition;
  random_partition = other44.random_partition;
  __isset = other44.__isset;
}
TPartitionDesc& TPartitionDesc::operator=(const TPartitionDesc& other45) {
  type = other45.type;
  partition_num = other45.partition_num;
  hash_partition = other45.hash_partition;
  range_partition = other45.range_partition;
  random_partition = other45.random_partition;
  __isset = other45.__isset;
  return *this;
}
void TPartitionDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPartitionDesc(";
  out << "type=" << to_string(type);
  out << ", " << "partition_num=" << to_string(partition_num);
  out << ", " << "hash_partition="; (__isset.hash_partition ? (out << to_string(hash_partition)) : (out << "<null>"));
  out << ", " << "range_partition="; (__isset.range_partition ? (out << to_string(range_partition)) : (out << "<null>"));
  out << ", " << "random_partition="; (__isset.random_partition ? (out << to_string(random_partition)) : (out << "<null>"));
  out << ")";
}


TCreateTableParams::~TCreateTableParams() throw() {
}


void TCreateTableParams::__set_table_name(const TTableName& val) {
  this->table_name = val;
}

void TCreateTableParams::__set_engine_name(const std::string& val) {
  this->engine_name = val;
__isset.engine_name = true;
}

void TCreateTableParams::__set_if_not_exists(const bool val) {
  this->if_not_exists = val;
__isset.if_not_exists = true;
}

void TCreateTableParams::__set_partition_desc(const TPartitionDesc& val) {
  this->partition_desc = val;
__isset.partition_desc = true;
}

void TCreateTableParams::__set_row_format_type(const std::string& val) {
  this->row_format_type = val;
__isset.row_format_type = true;
}

void TCreateTableParams::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

uint32_t TCreateTableParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->engine_name);
          this->__isset.engine_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition_desc.read(iprot);
          this->__isset.partition_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->row_format_type);
          this->__isset.row_format_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _ktype47;
            ::apache::thrift::protocol::TType _vtype48;
            xfer += iprot->readMapBegin(_ktype47, _vtype48, _size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              std::string _key51;
              xfer += iprot->readString(_key51);
              std::string& _val52 = this->properties[_key51];
              xfer += iprot->readString(_val52);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateTableParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateTableParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.engine_name) {
    xfer += oprot->writeFieldBegin("engine_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->engine_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.if_not_exists) {
    xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->if_not_exists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_desc) {
    xfer += oprot->writeFieldBegin("partition_desc", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->partition_desc.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_format_type) {
    xfer += oprot->writeFieldBegin("row_format_type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->row_format_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter53;
      for (_iter53 = this->properties.begin(); _iter53 != this->properties.end(); ++_iter53)
      {
        xfer += oprot->writeString(_iter53->first);
        xfer += oprot->writeString(_iter53->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateTableParams &a, TCreateTableParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.engine_name, b.engine_name);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.partition_desc, b.partition_desc);
  swap(a.row_format_type, b.row_format_type);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

TCreateTableParams::TCreateTableParams(const TCreateTableParams& other54) {
  table_name = other54.table_name;
  engine_name = other54.engine_name;
  if_not_exists = other54.if_not_exists;
  partition_desc = other54.partition_desc;
  row_format_type = other54.row_format_type;
  properties = other54.properties;
  __isset = other54.__isset;
}
TCreateTableParams& TCreateTableParams::operator=(const TCreateTableParams& other55) {
  table_name = other55.table_name;
  engine_name = other55.engine_name;
  if_not_exists = other55.if_not_exists;
  partition_desc = other55.partition_desc;
  row_format_type = other55.row_format_type;
  properties = other55.properties;
  __isset = other55.__isset;
  return *this;
}
void TCreateTableParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateTableParams(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "engine_name="; (__isset.engine_name ? (out << to_string(engine_name)) : (out << "<null>"));
  out << ", " << "if_not_exists="; (__isset.if_not_exists ? (out << to_string(if_not_exists)) : (out << "<null>"));
  out << ", " << "partition_desc="; (__isset.partition_desc ? (out << to_string(partition_desc)) : (out << "<null>"));
  out << ", " << "row_format_type="; (__isset.row_format_type ? (out << to_string(row_format_type)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ")";
}


TDropTableParams::~TDropTableParams() throw() {
}


void TDropTableParams::__set_table_name(const TTableName& val) {
  this->table_name = val;
}

void TDropTableParams::__set_if_exists(const bool val) {
  this->if_exists = val;
__isset.if_exists = true;
}

uint32_t TDropTableParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          this->__isset.if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropTableParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropTableParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.if_exists) {
    xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->if_exists);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropTableParams &a, TDropTableParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.if_exists, b.if_exists);
  swap(a.__isset, b.__isset);
}

TDropTableParams::TDropTableParams(const TDropTableParams& other56) {
  table_name = other56.table_name;
  if_exists = other56.if_exists;
  __isset = other56.__isset;
}
TDropTableParams& TDropTableParams::operator=(const TDropTableParams& other57) {
  table_name = other57.table_name;
  if_exists = other57.if_exists;
  __isset = other57.__isset;
  return *this;
}
void TDropTableParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDropTableParams(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "if_exists="; (__isset.if_exists ? (out << to_string(if_exists)) : (out << "<null>"));
  out << ")";
}


TCreateRollupParams::~TCreateRollupParams() throw() {
}


void TCreateRollupParams::__set_table_name(const TTableName& val) {
  this->table_name = val;
}

void TCreateRollupParams::__set_column_names(const std::vector<std::string> & val) {
  this->column_names = val;
}

void TCreateRollupParams::__set_rollup_name(const std::string& val) {
  this->rollup_name = val;
__isset.rollup_name = true;
}

void TCreateRollupParams::__set_partition_desc(const TPartitionDesc& val) {
  this->partition_desc = val;
__isset.partition_desc = true;
}

uint32_t TCreateRollupParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_column_names = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_names.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->column_names.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readString(this->column_names[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          isset_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rollup_name);
          this->__isset.rollup_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition_desc.read(iprot);
          this->__isset.partition_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateRollupParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateRollupParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_names", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_names.size()));
    std::vector<std::string> ::const_iterator _iter63;
    for (_iter63 = this->column_names.begin(); _iter63 != this->column_names.end(); ++_iter63)
    {
      xfer += oprot->writeString((*_iter63));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rollup_name) {
    xfer += oprot->writeFieldBegin("rollup_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->rollup_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_desc) {
    xfer += oprot->writeFieldBegin("partition_desc", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->partition_desc.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateRollupParams &a, TCreateRollupParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.column_names, b.column_names);
  swap(a.rollup_name, b.rollup_name);
  swap(a.partition_desc, b.partition_desc);
  swap(a.__isset, b.__isset);
}

TCreateRollupParams::TCreateRollupParams(const TCreateRollupParams& other64) {
  table_name = other64.table_name;
  column_names = other64.column_names;
  rollup_name = other64.rollup_name;
  partition_desc = other64.partition_desc;
  __isset = other64.__isset;
}
TCreateRollupParams& TCreateRollupParams::operator=(const TCreateRollupParams& other65) {
  table_name = other65.table_name;
  column_names = other65.column_names;
  rollup_name = other65.rollup_name;
  partition_desc = other65.partition_desc;
  __isset = other65.__isset;
  return *this;
}
void TCreateRollupParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateRollupParams(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "column_names=" << to_string(column_names);
  out << ", " << "rollup_name="; (__isset.rollup_name ? (out << to_string(rollup_name)) : (out << "<null>"));
  out << ", " << "partition_desc="; (__isset.partition_desc ? (out << to_string(partition_desc)) : (out << "<null>"));
  out << ")";
}


TDropRollupParams::~TDropRollupParams() throw() {
}


void TDropRollupParams::__set_table_name(const TTableName& val) {
  this->table_name = val;
}

void TDropRollupParams::__set_rollup_name(const std::string& val) {
  this->rollup_name = val;
}

uint32_t TDropRollupParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_rollup_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rollup_name);
          isset_rollup_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rollup_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropRollupParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropRollupParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rollup_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->rollup_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropRollupParams &a, TDropRollupParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.rollup_name, b.rollup_name);
}

TDropRollupParams::TDropRollupParams(const TDropRollupParams& other66) {
  table_name = other66.table_name;
  rollup_name = other66.rollup_name;
}
TDropRollupParams& TDropRollupParams::operator=(const TDropRollupParams& other67) {
  table_name = other67.table_name;
  rollup_name = other67.rollup_name;
  return *this;
}
void TDropRollupParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDropRollupParams(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "rollup_name=" << to_string(rollup_name);
  out << ")";
}


TCreateFunctionParams::~TCreateFunctionParams() throw() {
}


void TCreateFunctionParams::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TCreateFunctionParams::__set_function_name(const std::string& val) {
  this->function_name = val;
}

void TCreateFunctionParams::__set_argument_type(const std::vector< ::palo::TColumnType> & val) {
  this->argument_type = val;
}

void TCreateFunctionParams::__set_return_type(const  ::palo::TColumnType& val) {
  this->return_type = val;
}

void TCreateFunctionParams::__set_so_file_path(const std::string& val) {
  this->so_file_path = val;
}

void TCreateFunctionParams::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

uint32_t TCreateFunctionParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_function_name = false;
  bool isset_argument_type = false;
  bool isset_return_type = false;
  bool isset_so_file_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->argument_type.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            xfer += iprot->readListBegin(_etype71, _size68);
            this->argument_type.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              xfer += this->argument_type[_i72].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_argument_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->return_type.read(iprot);
          isset_return_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->so_file_path);
          isset_so_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _ktype74;
            ::apache::thrift::protocol::TType _vtype75;
            xfer += iprot->readMapBegin(_ktype74, _vtype75, _size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              std::string _key78;
              xfer += iprot->readString(_key78);
              std::string& _val79 = this->properties[_key78];
              xfer += iprot->readString(_val79);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_argument_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_return_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_so_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateFunctionParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateFunctionParams");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argument_type", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->argument_type.size()));
    std::vector< ::palo::TColumnType> ::const_iterator _iter80;
    for (_iter80 = this->argument_type.begin(); _iter80 != this->argument_type.end(); ++_iter80)
    {
      xfer += (*_iter80).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("return_type", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->return_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("so_file_path", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->so_file_path);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter81;
      for (_iter81 = this->properties.begin(); _iter81 != this->properties.end(); ++_iter81)
      {
        xfer += oprot->writeString(_iter81->first);
        xfer += oprot->writeString(_iter81->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateFunctionParams &a, TCreateFunctionParams &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.function_name, b.function_name);
  swap(a.argument_type, b.argument_type);
  swap(a.return_type, b.return_type);
  swap(a.so_file_path, b.so_file_path);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

TCreateFunctionParams::TCreateFunctionParams(const TCreateFunctionParams& other82) {
  db_name = other82.db_name;
  function_name = other82.function_name;
  argument_type = other82.argument_type;
  return_type = other82.return_type;
  so_file_path = other82.so_file_path;
  properties = other82.properties;
  __isset = other82.__isset;
}
TCreateFunctionParams& TCreateFunctionParams::operator=(const TCreateFunctionParams& other83) {
  db_name = other83.db_name;
  function_name = other83.function_name;
  argument_type = other83.argument_type;
  return_type = other83.return_type;
  so_file_path = other83.so_file_path;
  properties = other83.properties;
  __isset = other83.__isset;
  return *this;
}
void TCreateFunctionParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateFunctionParams(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "function_name=" << to_string(function_name);
  out << ", " << "argument_type=" << to_string(argument_type);
  out << ", " << "return_type=" << to_string(return_type);
  out << ", " << "so_file_path=" << to_string(so_file_path);
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ")";
}


TDropFunctionParams::~TDropFunctionParams() throw() {
}


void TDropFunctionParams::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDropFunctionParams::__set_function_name(const std::string& val) {
  this->function_name = val;
}

uint32_t TDropFunctionParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_function_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropFunctionParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropFunctionParams");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropFunctionParams &a, TDropFunctionParams &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.function_name, b.function_name);
}

TDropFunctionParams::TDropFunctionParams(const TDropFunctionParams& other84) {
  db_name = other84.db_name;
  function_name = other84.function_name;
}
TDropFunctionParams& TDropFunctionParams::operator=(const TDropFunctionParams& other85) {
  db_name = other85.db_name;
  function_name = other85.function_name;
  return *this;
}
void TDropFunctionParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDropFunctionParams(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "function_name=" << to_string(function_name);
  out << ")";
}


TUserSpecification::~TUserSpecification() throw() {
}


void TUserSpecification::__set_user_name(const std::string& val) {
  this->user_name = val;
}

void TUserSpecification::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

uint32_t TUserSpecification::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user_name);
          isset_user_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUserSpecification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserSpecification");

  xfer += oprot->writeFieldBegin("user_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserSpecification &a, TUserSpecification &b) {
  using ::std::swap;
  swap(a.user_name, b.user_name);
  swap(a.host_name, b.host_name);
  swap(a.__isset, b.__isset);
}

TUserSpecification::TUserSpecification(const TUserSpecification& other86) {
  user_name = other86.user_name;
  host_name = other86.host_name;
  __isset = other86.__isset;
}
TUserSpecification& TUserSpecification::operator=(const TUserSpecification& other87) {
  user_name = other87.user_name;
  host_name = other87.host_name;
  __isset = other87.__isset;
  return *this;
}
void TUserSpecification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserSpecification(";
  out << "user_name=" << to_string(user_name);
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ")";
}


TCreateUserParams::~TCreateUserParams() throw() {
}


void TCreateUserParams::__set_user_spec(const TUserSpecification& val) {
  this->user_spec = val;
}

void TCreateUserParams::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

uint32_t TCreateUserParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user_spec = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->user_spec.read(iprot);
          isset_user_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateUserParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateUserParams");

  xfer += oprot->writeFieldBegin("user_spec", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->user_spec.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateUserParams &a, TCreateUserParams &b) {
  using ::std::swap;
  swap(a.user_spec, b.user_spec);
  swap(a.password, b.password);
  swap(a.__isset, b.__isset);
}

TCreateUserParams::TCreateUserParams(const TCreateUserParams& other88) {
  user_spec = other88.user_spec;
  password = other88.password;
  __isset = other88.__isset;
}
TCreateUserParams& TCreateUserParams::operator=(const TCreateUserParams& other89) {
  user_spec = other89.user_spec;
  password = other89.password;
  __isset = other89.__isset;
  return *this;
}
void TCreateUserParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateUserParams(";
  out << "user_spec=" << to_string(user_spec);
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ")";
}


TDropUserParams::~TDropUserParams() throw() {
}


void TDropUserParams::__set_user_spec(const std::string& val) {
  this->user_spec = val;
}

uint32_t TDropUserParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user_spec = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user_spec);
          isset_user_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropUserParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropUserParams");

  xfer += oprot->writeFieldBegin("user_spec", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user_spec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropUserParams &a, TDropUserParams &b) {
  using ::std::swap;
  swap(a.user_spec, b.user_spec);
}

TDropUserParams::TDropUserParams(const TDropUserParams& other90) {
  user_spec = other90.user_spec;
}
TDropUserParams& TDropUserParams::operator=(const TDropUserParams& other91) {
  user_spec = other91.user_spec;
  return *this;
}
void TDropUserParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDropUserParams(";
  out << "user_spec=" << to_string(user_spec);
  out << ")";
}


TSetPasswordParams::~TSetPasswordParams() throw() {
}


void TSetPasswordParams::__set_user_spec(const TUserSpecification& val) {
  this->user_spec = val;
}

void TSetPasswordParams::__set_password(const std::string& val) {
  this->password = val;
}

uint32_t TSetPasswordParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user_spec = false;
  bool isset_password = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->user_spec.read(iprot);
          isset_user_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          isset_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_password)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetPasswordParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetPasswordParams");

  xfer += oprot->writeFieldBegin("user_spec", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->user_spec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetPasswordParams &a, TSetPasswordParams &b) {
  using ::std::swap;
  swap(a.user_spec, b.user_spec);
  swap(a.password, b.password);
}

TSetPasswordParams::TSetPasswordParams(const TSetPasswordParams& other92) {
  user_spec = other92.user_spec;
  password = other92.password;
}
TSetPasswordParams& TSetPasswordParams::operator=(const TSetPasswordParams& other93) {
  user_spec = other93.user_spec;
  password = other93.password;
  return *this;
}
void TSetPasswordParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetPasswordParams(";
  out << "user_spec=" << to_string(user_spec);
  out << ", " << "password=" << to_string(password);
  out << ")";
}


TGrantParams::~TGrantParams() throw() {
}


void TGrantParams::__set_user_spec(const TUserSpecification& val) {
  this->user_spec = val;
}

void TGrantParams::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TGrantParams::__set_priv_types(const std::vector<TPrivType::type> & val) {
  this->priv_types = val;
}

uint32_t TGrantParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user_spec = false;
  bool isset_db_name = false;
  bool isset_priv_types = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->user_spec.read(iprot);
          isset_user_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->priv_types.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->priv_types.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              int32_t ecast99;
              xfer += iprot->readI32(ecast99);
              this->priv_types[_i98] = (TPrivType::type)ecast99;
            }
            xfer += iprot->readListEnd();
          }
          isset_priv_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_priv_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGrantParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGrantParams");

  xfer += oprot->writeFieldBegin("user_spec", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->user_spec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priv_types", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->priv_types.size()));
    std::vector<TPrivType::type> ::const_iterator _iter100;
    for (_iter100 = this->priv_types.begin(); _iter100 != this->priv_types.end(); ++_iter100)
    {
      xfer += oprot->writeI32((int32_t)(*_iter100));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGrantParams &a, TGrantParams &b) {
  using ::std::swap;
  swap(a.user_spec, b.user_spec);
  swap(a.db_name, b.db_name);
  swap(a.priv_types, b.priv_types);
}

TGrantParams::TGrantParams(const TGrantParams& other101) {
  user_spec = other101.user_spec;
  db_name = other101.db_name;
  priv_types = other101.priv_types;
}
TGrantParams& TGrantParams::operator=(const TGrantParams& other102) {
  user_spec = other102.user_spec;
  db_name = other102.db_name;
  priv_types = other102.priv_types;
  return *this;
}
void TGrantParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGrantParams(";
  out << "user_spec=" << to_string(user_spec);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "priv_types=" << to_string(priv_types);
  out << ")";
}


TDataSpecification::~TDataSpecification() throw() {
}


void TDataSpecification::__set_table_name(const TTableName& val) {
  this->table_name = val;
}

void TDataSpecification::__set_file_path(const std::vector<std::string> & val) {
  this->file_path = val;
}

void TDataSpecification::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
__isset.columns = true;
}

void TDataSpecification::__set_column_separator(const std::string& val) {
  this->column_separator = val;
__isset.column_separator = true;
}

void TDataSpecification::__set_line_separator(const std::string& val) {
  this->line_separator = val;
__isset.line_separator = true;
}

void TDataSpecification::__set_is_negative(const bool val) {
  this->is_negative = val;
__isset.is_negative = true;
}

uint32_t TDataSpecification::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_file_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->file_path.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->file_path.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              xfer += iprot->readString(this->file_path[_i107]);
            }
            xfer += iprot->readListEnd();
          }
          isset_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _etype111;
            xfer += iprot->readListBegin(_etype111, _size108);
            this->columns.resize(_size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              xfer += iprot->readString(this->columns[_i112]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_separator);
          this->__isset.column_separator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_separator);
          this->__isset.line_separator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_negative);
          this->__isset.is_negative = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataSpecification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataSpecification");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_path", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->file_path.size()));
    std::vector<std::string> ::const_iterator _iter113;
    for (_iter113 = this->file_path.begin(); _iter113 != this->file_path.end(); ++_iter113)
    {
      xfer += oprot->writeString((*_iter113));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter114;
      for (_iter114 = this->columns.begin(); _iter114 != this->columns.end(); ++_iter114)
      {
        xfer += oprot->writeString((*_iter114));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_separator) {
    xfer += oprot->writeFieldBegin("column_separator", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->column_separator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.line_separator) {
    xfer += oprot->writeFieldBegin("line_separator", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->line_separator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_negative) {
    xfer += oprot->writeFieldBegin("is_negative", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_negative);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataSpecification &a, TDataSpecification &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.file_path, b.file_path);
  swap(a.columns, b.columns);
  swap(a.column_separator, b.column_separator);
  swap(a.line_separator, b.line_separator);
  swap(a.is_negative, b.is_negative);
  swap(a.__isset, b.__isset);
}

TDataSpecification::TDataSpecification(const TDataSpecification& other115) {
  table_name = other115.table_name;
  file_path = other115.file_path;
  columns = other115.columns;
  column_separator = other115.column_separator;
  line_separator = other115.line_separator;
  is_negative = other115.is_negative;
  __isset = other115.__isset;
}
TDataSpecification& TDataSpecification::operator=(const TDataSpecification& other116) {
  table_name = other116.table_name;
  file_path = other116.file_path;
  columns = other116.columns;
  column_separator = other116.column_separator;
  line_separator = other116.line_separator;
  is_negative = other116.is_negative;
  __isset = other116.__isset;
  return *this;
}
void TDataSpecification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataSpecification(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "file_path=" << to_string(file_path);
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "column_separator="; (__isset.column_separator ? (out << to_string(column_separator)) : (out << "<null>"));
  out << ", " << "line_separator="; (__isset.line_separator ? (out << to_string(line_separator)) : (out << "<null>"));
  out << ", " << "is_negative="; (__isset.is_negative ? (out << to_string(is_negative)) : (out << "<null>"));
  out << ")";
}


TLabelName::~TLabelName() throw() {
}


void TLabelName::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TLabelName::__set_load_label(const std::string& val) {
  this->load_label = val;
}

uint32_t TLabelName::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_load_label = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->load_label);
          isset_load_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_load_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLabelName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLabelName");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("load_label", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->load_label);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLabelName &a, TLabelName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.load_label, b.load_label);
}

TLabelName::TLabelName(const TLabelName& other117) {
  db_name = other117.db_name;
  load_label = other117.load_label;
}
TLabelName& TLabelName::operator=(const TLabelName& other118) {
  db_name = other118.db_name;
  load_label = other118.load_label;
  return *this;
}
void TLabelName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLabelName(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "load_label=" << to_string(load_label);
  out << ")";
}


TLoadParams::~TLoadParams() throw() {
}


void TLoadParams::__set_load_label(const TLabelName& val) {
  this->load_label = val;
}

void TLoadParams::__set_data_profiles(const std::vector<TDataSpecification> & val) {
  this->data_profiles = val;
}

void TLoadParams::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

uint32_t TLoadParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_load_label = false;
  bool isset_data_profiles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_label.read(iprot);
          isset_load_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data_profiles.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->data_profiles.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += this->data_profiles[_i123].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_data_profiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              std::string _key129;
              xfer += iprot->readString(_key129);
              std::string& _val130 = this->properties[_key129];
              xfer += iprot->readString(_val130);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_load_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data_profiles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLoadParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLoadParams");

  xfer += oprot->writeFieldBegin("load_label", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->load_label.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_profiles", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data_profiles.size()));
    std::vector<TDataSpecification> ::const_iterator _iter131;
    for (_iter131 = this->data_profiles.begin(); _iter131 != this->data_profiles.end(); ++_iter131)
    {
      xfer += (*_iter131).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter132;
      for (_iter132 = this->properties.begin(); _iter132 != this->properties.end(); ++_iter132)
      {
        xfer += oprot->writeString(_iter132->first);
        xfer += oprot->writeString(_iter132->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLoadParams &a, TLoadParams &b) {
  using ::std::swap;
  swap(a.load_label, b.load_label);
  swap(a.data_profiles, b.data_profiles);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

TLoadParams::TLoadParams(const TLoadParams& other133) {
  load_label = other133.load_label;
  data_profiles = other133.data_profiles;
  properties = other133.properties;
  __isset = other133.__isset;
}
TLoadParams& TLoadParams::operator=(const TLoadParams& other134) {
  load_label = other134.load_label;
  data_profiles = other134.data_profiles;
  properties = other134.properties;
  __isset = other134.__isset;
  return *this;
}
void TLoadParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLoadParams(";
  out << "load_label=" << to_string(load_label);
  out << ", " << "data_profiles=" << to_string(data_profiles);
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ")";
}


TCancelLoadParams::~TCancelLoadParams() throw() {
}


void TCancelLoadParams::__set_load_label(const TLabelName& val) {
  this->load_label = val;
}

uint32_t TCancelLoadParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_load_label = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_label.read(iprot);
          isset_load_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_load_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelLoadParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelLoadParams");

  xfer += oprot->writeFieldBegin("load_label", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->load_label.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelLoadParams &a, TCancelLoadParams &b) {
  using ::std::swap;
  swap(a.load_label, b.load_label);
}

TCancelLoadParams::TCancelLoadParams(const TCancelLoadParams& other135) {
  load_label = other135.load_label;
}
TCancelLoadParams& TCancelLoadParams::operator=(const TCancelLoadParams& other136) {
  load_label = other136.load_label;
  return *this;
}
void TCancelLoadParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelLoadParams(";
  out << "load_label=" << to_string(load_label);
  out << ")";
}


TMasterDdlRequest::~TMasterDdlRequest() throw() {
}


void TMasterDdlRequest::__set_protocol_version(const TPaloInternalServiceVersion::type val) {
  this->protocol_version = val;
}

void TMasterDdlRequest::__set_ddl_type(const TCommonDdlType::type val) {
  this->ddl_type = val;
}

void TMasterDdlRequest::__set_create_db_params(const TCreateDbParams& val) {
  this->create_db_params = val;
__isset.create_db_params = true;
}

void TMasterDdlRequest::__set_drop_db_params(const TDropDbParams& val) {
  this->drop_db_params = val;
__isset.drop_db_params = true;
}

void TMasterDdlRequest::__set_drop_table_params(const TDropTableParams& val) {
  this->drop_table_params = val;
__isset.drop_table_params = true;
}

void TMasterDdlRequest::__set_load_params(const TLoadParams& val) {
  this->load_params = val;
__isset.load_params = true;
}

void TMasterDdlRequest::__set_cancel_load_params(const TCancelLoadParams& val) {
  this->cancel_load_params = val;
__isset.cancel_load_params = true;
}

void TMasterDdlRequest::__set_create_user_params(const TCreateUserParams& val) {
  this->create_user_params = val;
__isset.create_user_params = true;
}

void TMasterDdlRequest::__set_drop_user_params(const TDropUserParams& val) {
  this->drop_user_params = val;
__isset.drop_user_params = true;
}

void TMasterDdlRequest::__set_create_rollup_params(const TCreateRollupParams& val) {
  this->create_rollup_params = val;
__isset.create_rollup_params = true;
}

void TMasterDdlRequest::__set_drop_rollup_params(const TDropRollupParams& val) {
  this->drop_rollup_params = val;
__isset.drop_rollup_params = true;
}

void TMasterDdlRequest::__set_create_function_params(const TCreateFunctionParams& val) {
  this->create_function_params = val;
__isset.create_function_params = true;
}

void TMasterDdlRequest::__set_drop_function_params(const TDropFunctionParams& val) {
  this->drop_function_params = val;
__isset.drop_function_params = true;
}

uint32_t TMasterDdlRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_ddl_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast137;
          xfer += iprot->readI32(ecast137);
          this->protocol_version = (TPaloInternalServiceVersion::type)ecast137;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast138;
          xfer += iprot->readI32(ecast138);
          this->ddl_type = (TCommonDdlType::type)ecast138;
          isset_ddl_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_db_params.read(iprot);
          this->__isset.create_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_db_params.read(iprot);
          this->__isset.drop_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_table_params.read(iprot);
          this->__isset.drop_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_params.read(iprot);
          this->__isset.load_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cancel_load_params.read(iprot);
          this->__isset.cancel_load_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_user_params.read(iprot);
          this->__isset.create_user_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_user_params.read(iprot);
          this->__isset.drop_user_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_rollup_params.read(iprot);
          this->__isset.create_rollup_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_rollup_params.read(iprot);
          this->__isset.drop_rollup_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_function_params.read(iprot);
          this->__isset.create_function_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_function_params.read(iprot);
          this->__isset.drop_function_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ddl_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMasterDdlRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMasterDdlRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ddl_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->ddl_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.create_db_params) {
    xfer += oprot->writeFieldBegin("create_db_params", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->create_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_db_params) {
    xfer += oprot->writeFieldBegin("drop_db_params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->drop_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_table_params) {
    xfer += oprot->writeFieldBegin("drop_table_params", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->drop_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.load_params) {
    xfer += oprot->writeFieldBegin("load_params", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->load_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cancel_load_params) {
    xfer += oprot->writeFieldBegin("cancel_load_params", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->cancel_load_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_user_params) {
    xfer += oprot->writeFieldBegin("create_user_params", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->create_user_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_user_params) {
    xfer += oprot->writeFieldBegin("drop_user_params", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->drop_user_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_rollup_params) {
    xfer += oprot->writeFieldBegin("create_rollup_params", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->create_rollup_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_rollup_params) {
    xfer += oprot->writeFieldBegin("drop_rollup_params", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->drop_rollup_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_function_params) {
    xfer += oprot->writeFieldBegin("create_function_params", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->create_function_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_function_params) {
    xfer += oprot->writeFieldBegin("drop_function_params", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->drop_function_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMasterDdlRequest &a, TMasterDdlRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.ddl_type, b.ddl_type);
  swap(a.create_db_params, b.create_db_params);
  swap(a.drop_db_params, b.drop_db_params);
  swap(a.drop_table_params, b.drop_table_params);
  swap(a.load_params, b.load_params);
  swap(a.cancel_load_params, b.cancel_load_params);
  swap(a.create_user_params, b.create_user_params);
  swap(a.drop_user_params, b.drop_user_params);
  swap(a.create_rollup_params, b.create_rollup_params);
  swap(a.drop_rollup_params, b.drop_rollup_params);
  swap(a.create_function_params, b.create_function_params);
  swap(a.drop_function_params, b.drop_function_params);
  swap(a.__isset, b.__isset);
}

TMasterDdlRequest::TMasterDdlRequest(const TMasterDdlRequest& other139) {
  protocol_version = other139.protocol_version;
  ddl_type = other139.ddl_type;
  create_db_params = other139.create_db_params;
  drop_db_params = other139.drop_db_params;
  drop_table_params = other139.drop_table_params;
  load_params = other139.load_params;
  cancel_load_params = other139.cancel_load_params;
  create_user_params = other139.create_user_params;
  drop_user_params = other139.drop_user_params;
  create_rollup_params = other139.create_rollup_params;
  drop_rollup_params = other139.drop_rollup_params;
  create_function_params = other139.create_function_params;
  drop_function_params = other139.drop_function_params;
  __isset = other139.__isset;
}
TMasterDdlRequest& TMasterDdlRequest::operator=(const TMasterDdlRequest& other140) {
  protocol_version = other140.protocol_version;
  ddl_type = other140.ddl_type;
  create_db_params = other140.create_db_params;
  drop_db_params = other140.drop_db_params;
  drop_table_params = other140.drop_table_params;
  load_params = other140.load_params;
  cancel_load_params = other140.cancel_load_params;
  create_user_params = other140.create_user_params;
  drop_user_params = other140.drop_user_params;
  create_rollup_params = other140.create_rollup_params;
  drop_rollup_params = other140.drop_rollup_params;
  create_function_params = other140.create_function_params;
  drop_function_params = other140.drop_function_params;
  __isset = other140.__isset;
  return *this;
}
void TMasterDdlRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMasterDdlRequest(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "ddl_type=" << to_string(ddl_type);
  out << ", " << "create_db_params="; (__isset.create_db_params ? (out << to_string(create_db_params)) : (out << "<null>"));
  out << ", " << "drop_db_params="; (__isset.drop_db_params ? (out << to_string(drop_db_params)) : (out << "<null>"));
  out << ", " << "drop_table_params="; (__isset.drop_table_params ? (out << to_string(drop_table_params)) : (out << "<null>"));
  out << ", " << "load_params="; (__isset.load_params ? (out << to_string(load_params)) : (out << "<null>"));
  out << ", " << "cancel_load_params="; (__isset.cancel_load_params ? (out << to_string(cancel_load_params)) : (out << "<null>"));
  out << ", " << "create_user_params="; (__isset.create_user_params ? (out << to_string(create_user_params)) : (out << "<null>"));
  out << ", " << "drop_user_params="; (__isset.drop_user_params ? (out << to_string(drop_user_params)) : (out << "<null>"));
  out << ", " << "create_rollup_params="; (__isset.create_rollup_params ? (out << to_string(create_rollup_params)) : (out << "<null>"));
  out << ", " << "drop_rollup_params="; (__isset.drop_rollup_params ? (out << to_string(drop_rollup_params)) : (out << "<null>"));
  out << ", " << "create_function_params="; (__isset.create_function_params ? (out << to_string(create_function_params)) : (out << "<null>"));
  out << ", " << "drop_function_params="; (__isset.drop_function_params ? (out << to_string(drop_function_params)) : (out << "<null>"));
  out << ")";
}


TMasterDdlResponse::~TMasterDdlResponse() throw() {
}


void TMasterDdlResponse::__set_protocol_version(const TPaloInternalServiceVersion::type val) {
  this->protocol_version = val;
}

void TMasterDdlResponse::__set_ddl_type(const TCommonDdlType::type val) {
  this->ddl_type = val;
}

void TMasterDdlResponse::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

uint32_t TMasterDdlResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_ddl_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast141;
          xfer += iprot->readI32(ecast141);
          this->protocol_version = (TPaloInternalServiceVersion::type)ecast141;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast142;
          xfer += iprot->readI32(ecast142);
          this->ddl_type = (TCommonDdlType::type)ecast142;
          isset_ddl_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ddl_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMasterDdlResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMasterDdlResponse");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ddl_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->ddl_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMasterDdlResponse &a, TMasterDdlResponse &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.ddl_type, b.ddl_type);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TMasterDdlResponse::TMasterDdlResponse(const TMasterDdlResponse& other143) {
  protocol_version = other143.protocol_version;
  ddl_type = other143.ddl_type;
  status = other143.status;
  __isset = other143.__isset;
}
TMasterDdlResponse& TMasterDdlResponse::operator=(const TMasterDdlResponse& other144) {
  protocol_version = other144.protocol_version;
  ddl_type = other144.ddl_type;
  status = other144.status;
  __isset = other144.__isset;
  return *this;
}
void TMasterDdlResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMasterDdlResponse(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "ddl_type=" << to_string(ddl_type);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}

} // namespace
