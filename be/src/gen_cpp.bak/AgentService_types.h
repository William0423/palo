/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef AgentService_TYPES_H
#define AgentService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Status_types.h"
#include "Types_types.h"
#include "PaloInternalService_types.h"


namespace palo {

struct TAgentServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _TAgentServiceVersion_VALUES_TO_NAMES;

struct TTopicType {
  enum type {
    RESOURCE = 0
  };
};

extern const std::map<int, const char*> _TTopicType_VALUES_TO_NAMES;

class TColumn;

class TTabletSchema;

class TCreateTabletReq;

class TDropTabletReq;

class TAlterTabletReq;

class TClusterInfo;

class TPushReq;

class TCloneReq;

class TStorageMediumMigrateReq;

class TCancelDeleteDataReq;

class TCheckConsistencyReq;

class TUploadReq;

class TRestoreReq;

class TSnapshotRequest;

class TReleaseSnapshotRequest;

class TClearRemoteFileReq;

class TAgentTaskRequest;

class TAgentResult;

class TTopicItem;

class TTopicUpdate;

class TAgentPublishRequest;

class TMiniLoadEtlTaskRequest;

class TMiniLoadEtlStatusRequest;

class TMiniLoadEtlStatusResult;

class TDeleteEtlFilesRequest;

typedef struct _TColumn__isset {
  _TColumn__isset() : aggregation_type(false), is_key(false), is_allow_null(false), default_value(false), is_bloom_filter_column(false) {}
  bool aggregation_type :1;
  bool is_key :1;
  bool is_allow_null :1;
  bool default_value :1;
  bool is_bloom_filter_column :1;
} _TColumn__isset;

class TColumn {
 public:

  TColumn(const TColumn&);
  TColumn& operator=(const TColumn&);
  TColumn() : column_name(), aggregation_type(( ::palo::TAggregationType::type)0), is_key(0), is_allow_null(0), default_value(), is_bloom_filter_column(0) {
  }

  virtual ~TColumn() throw();
  std::string column_name;
   ::palo::TColumnType column_type;
   ::palo::TAggregationType::type aggregation_type;
  bool is_key;
  bool is_allow_null;
  std::string default_value;
  bool is_bloom_filter_column;

  _TColumn__isset __isset;

  void __set_column_name(const std::string& val);

  void __set_column_type(const  ::palo::TColumnType& val);

  void __set_aggregation_type(const  ::palo::TAggregationType::type val);

  void __set_is_key(const bool val);

  void __set_is_allow_null(const bool val);

  void __set_default_value(const std::string& val);

  void __set_is_bloom_filter_column(const bool val);

  bool operator == (const TColumn & rhs) const
  {
    if (!(column_name == rhs.column_name))
      return false;
    if (!(column_type == rhs.column_type))
      return false;
    if (__isset.aggregation_type != rhs.__isset.aggregation_type)
      return false;
    else if (__isset.aggregation_type && !(aggregation_type == rhs.aggregation_type))
      return false;
    if (__isset.is_key != rhs.__isset.is_key)
      return false;
    else if (__isset.is_key && !(is_key == rhs.is_key))
      return false;
    if (__isset.is_allow_null != rhs.__isset.is_allow_null)
      return false;
    else if (__isset.is_allow_null && !(is_allow_null == rhs.is_allow_null))
      return false;
    if (__isset.default_value != rhs.__isset.default_value)
      return false;
    else if (__isset.default_value && !(default_value == rhs.default_value))
      return false;
    if (__isset.is_bloom_filter_column != rhs.__isset.is_bloom_filter_column)
      return false;
    else if (__isset.is_bloom_filter_column && !(is_bloom_filter_column == rhs.is_bloom_filter_column))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumn &a, TColumn &b);

inline std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTabletSchema__isset {
  _TTabletSchema__isset() : bloom_filter_fpp(false) {}
  bool bloom_filter_fpp :1;
} _TTabletSchema__isset;

class TTabletSchema {
 public:

  TTabletSchema(const TTabletSchema&);
  TTabletSchema& operator=(const TTabletSchema&);
  TTabletSchema() : short_key_column_count(0), schema_hash(0), keys_type(( ::palo::TKeysType::type)0), storage_type(( ::palo::TStorageType::type)0), bloom_filter_fpp(0) {
  }

  virtual ~TTabletSchema() throw();
  int16_t short_key_column_count;
   ::palo::TSchemaHash schema_hash;
   ::palo::TKeysType::type keys_type;
   ::palo::TStorageType::type storage_type;
  std::vector<TColumn>  columns;
  double bloom_filter_fpp;

  _TTabletSchema__isset __isset;

  void __set_short_key_column_count(const int16_t val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_keys_type(const  ::palo::TKeysType::type val);

  void __set_storage_type(const  ::palo::TStorageType::type val);

  void __set_columns(const std::vector<TColumn> & val);

  void __set_bloom_filter_fpp(const double val);

  bool operator == (const TTabletSchema & rhs) const
  {
    if (!(short_key_column_count == rhs.short_key_column_count))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(keys_type == rhs.keys_type))
      return false;
    if (!(storage_type == rhs.storage_type))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (__isset.bloom_filter_fpp != rhs.__isset.bloom_filter_fpp)
      return false;
    else if (__isset.bloom_filter_fpp && !(bloom_filter_fpp == rhs.bloom_filter_fpp))
      return false;
    return true;
  }
  bool operator != (const TTabletSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTabletSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTabletSchema &a, TTabletSchema &b);

inline std::ostream& operator<<(std::ostream& out, const TTabletSchema& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCreateTabletReq__isset {
  _TCreateTabletReq__isset() : version(false), version_hash(false), storage_medium(false) {}
  bool version :1;
  bool version_hash :1;
  bool storage_medium :1;
} _TCreateTabletReq__isset;

class TCreateTabletReq {
 public:

  TCreateTabletReq(const TCreateTabletReq&);
  TCreateTabletReq& operator=(const TCreateTabletReq&);
  TCreateTabletReq() : tablet_id(0), version(0), version_hash(0), storage_medium(( ::palo::TStorageMedium::type)0) {
  }

  virtual ~TCreateTabletReq() throw();
   ::palo::TTabletId tablet_id;
  TTabletSchema tablet_schema;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;
   ::palo::TStorageMedium::type storage_medium;

  _TCreateTabletReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_tablet_schema(const TTabletSchema& val);

  void __set_version(const  ::palo::TVersion val);

  void __set_version_hash(const  ::palo::TVersionHash val);

  void __set_storage_medium(const  ::palo::TStorageMedium::type val);

  bool operator == (const TCreateTabletReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(tablet_schema == rhs.tablet_schema))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.version_hash != rhs.__isset.version_hash)
      return false;
    else if (__isset.version_hash && !(version_hash == rhs.version_hash))
      return false;
    if (__isset.storage_medium != rhs.__isset.storage_medium)
      return false;
    else if (__isset.storage_medium && !(storage_medium == rhs.storage_medium))
      return false;
    return true;
  }
  bool operator != (const TCreateTabletReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateTabletReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateTabletReq &a, TCreateTabletReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCreateTabletReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TDropTabletReq__isset {
  _TDropTabletReq__isset() : schema_hash(false) {}
  bool schema_hash :1;
} _TDropTabletReq__isset;

class TDropTabletReq {
 public:

  TDropTabletReq(const TDropTabletReq&);
  TDropTabletReq& operator=(const TDropTabletReq&);
  TDropTabletReq() : tablet_id(0), schema_hash(0) {
  }

  virtual ~TDropTabletReq() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;

  _TDropTabletReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  bool operator == (const TDropTabletReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (__isset.schema_hash != rhs.__isset.schema_hash)
      return false;
    else if (__isset.schema_hash && !(schema_hash == rhs.schema_hash))
      return false;
    return true;
  }
  bool operator != (const TDropTabletReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropTabletReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropTabletReq &a, TDropTabletReq &b);

inline std::ostream& operator<<(std::ostream& out, const TDropTabletReq& obj)
{
  obj.printTo(out);
  return out;
}


class TAlterTabletReq {
 public:

  TAlterTabletReq(const TAlterTabletReq&);
  TAlterTabletReq& operator=(const TAlterTabletReq&);
  TAlterTabletReq() : base_tablet_id(0), base_schema_hash(0) {
  }

  virtual ~TAlterTabletReq() throw();
   ::palo::TTabletId base_tablet_id;
   ::palo::TSchemaHash base_schema_hash;
  TCreateTabletReq new_tablet_req;

  void __set_base_tablet_id(const  ::palo::TTabletId val);

  void __set_base_schema_hash(const  ::palo::TSchemaHash val);

  void __set_new_tablet_req(const TCreateTabletReq& val);

  bool operator == (const TAlterTabletReq & rhs) const
  {
    if (!(base_tablet_id == rhs.base_tablet_id))
      return false;
    if (!(base_schema_hash == rhs.base_schema_hash))
      return false;
    if (!(new_tablet_req == rhs.new_tablet_req))
      return false;
    return true;
  }
  bool operator != (const TAlterTabletReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTabletReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTabletReq &a, TAlterTabletReq &b);

inline std::ostream& operator<<(std::ostream& out, const TAlterTabletReq& obj)
{
  obj.printTo(out);
  return out;
}


class TClusterInfo {
 public:

  TClusterInfo(const TClusterInfo&);
  TClusterInfo& operator=(const TClusterInfo&);
  TClusterInfo() : user(), password() {
  }

  virtual ~TClusterInfo() throw();
  std::string user;
  std::string password;

  void __set_user(const std::string& val);

  void __set_password(const std::string& val);

  bool operator == (const TClusterInfo & rhs) const
  {
    if (!(user == rhs.user))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const TClusterInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TClusterInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TClusterInfo &a, TClusterInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TClusterInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPushReq__isset {
  _TPushReq__isset() : http_file_path(false), http_file_size(false), delete_conditions(false), need_decompress(false) {}
  bool http_file_path :1;
  bool http_file_size :1;
  bool delete_conditions :1;
  bool need_decompress :1;
} _TPushReq__isset;

class TPushReq {
 public:

  TPushReq(const TPushReq&);
  TPushReq& operator=(const TPushReq&);
  TPushReq() : tablet_id(0), schema_hash(0), version(0), version_hash(0), timeout(0), push_type(( ::palo::TPushType::type)0), http_file_path(), http_file_size(0), need_decompress(0) {
  }

  virtual ~TPushReq() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;
  int64_t timeout;
   ::palo::TPushType::type push_type;
  std::string http_file_path;
  int64_t http_file_size;
  std::vector< ::palo::TCondition>  delete_conditions;
  bool need_decompress;

  _TPushReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_version(const  ::palo::TVersion val);

  void __set_version_hash(const  ::palo::TVersionHash val);

  void __set_timeout(const int64_t val);

  void __set_push_type(const  ::palo::TPushType::type val);

  void __set_http_file_path(const std::string& val);

  void __set_http_file_size(const int64_t val);

  void __set_delete_conditions(const std::vector< ::palo::TCondition> & val);

  void __set_need_decompress(const bool val);

  bool operator == (const TPushReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    if (!(push_type == rhs.push_type))
      return false;
    if (__isset.http_file_path != rhs.__isset.http_file_path)
      return false;
    else if (__isset.http_file_path && !(http_file_path == rhs.http_file_path))
      return false;
    if (__isset.http_file_size != rhs.__isset.http_file_size)
      return false;
    else if (__isset.http_file_size && !(http_file_size == rhs.http_file_size))
      return false;
    if (__isset.delete_conditions != rhs.__isset.delete_conditions)
      return false;
    else if (__isset.delete_conditions && !(delete_conditions == rhs.delete_conditions))
      return false;
    if (__isset.need_decompress != rhs.__isset.need_decompress)
      return false;
    else if (__isset.need_decompress && !(need_decompress == rhs.need_decompress))
      return false;
    return true;
  }
  bool operator != (const TPushReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPushReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPushReq &a, TPushReq &b);

inline std::ostream& operator<<(std::ostream& out, const TPushReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TCloneReq__isset {
  _TCloneReq__isset() : storage_medium(false), committed_version(false), committed_version_hash(false) {}
  bool storage_medium :1;
  bool committed_version :1;
  bool committed_version_hash :1;
} _TCloneReq__isset;

class TCloneReq {
 public:

  TCloneReq(const TCloneReq&);
  TCloneReq& operator=(const TCloneReq&);
  TCloneReq() : tablet_id(0), schema_hash(0), storage_medium(( ::palo::TStorageMedium::type)0), committed_version(0), committed_version_hash(0) {
  }

  virtual ~TCloneReq() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
  std::vector< ::palo::TBackend>  src_backends;
   ::palo::TStorageMedium::type storage_medium;
   ::palo::TVersion committed_version;
   ::palo::TVersionHash committed_version_hash;

  _TCloneReq__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_src_backends(const std::vector< ::palo::TBackend> & val);

  void __set_storage_medium(const  ::palo::TStorageMedium::type val);

  void __set_committed_version(const  ::palo::TVersion val);

  void __set_committed_version_hash(const  ::palo::TVersionHash val);

  bool operator == (const TCloneReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(src_backends == rhs.src_backends))
      return false;
    if (__isset.storage_medium != rhs.__isset.storage_medium)
      return false;
    else if (__isset.storage_medium && !(storage_medium == rhs.storage_medium))
      return false;
    if (__isset.committed_version != rhs.__isset.committed_version)
      return false;
    else if (__isset.committed_version && !(committed_version == rhs.committed_version))
      return false;
    if (__isset.committed_version_hash != rhs.__isset.committed_version_hash)
      return false;
    else if (__isset.committed_version_hash && !(committed_version_hash == rhs.committed_version_hash))
      return false;
    return true;
  }
  bool operator != (const TCloneReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloneReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCloneReq &a, TCloneReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCloneReq& obj)
{
  obj.printTo(out);
  return out;
}


class TStorageMediumMigrateReq {
 public:

  TStorageMediumMigrateReq(const TStorageMediumMigrateReq&);
  TStorageMediumMigrateReq& operator=(const TStorageMediumMigrateReq&);
  TStorageMediumMigrateReq() : tablet_id(0), schema_hash(0), storage_medium(( ::palo::TStorageMedium::type)0) {
  }

  virtual ~TStorageMediumMigrateReq() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TStorageMedium::type storage_medium;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_storage_medium(const  ::palo::TStorageMedium::type val);

  bool operator == (const TStorageMediumMigrateReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(storage_medium == rhs.storage_medium))
      return false;
    return true;
  }
  bool operator != (const TStorageMediumMigrateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStorageMediumMigrateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStorageMediumMigrateReq &a, TStorageMediumMigrateReq &b);

inline std::ostream& operator<<(std::ostream& out, const TStorageMediumMigrateReq& obj)
{
  obj.printTo(out);
  return out;
}


class TCancelDeleteDataReq {
 public:

  TCancelDeleteDataReq(const TCancelDeleteDataReq&);
  TCancelDeleteDataReq& operator=(const TCancelDeleteDataReq&);
  TCancelDeleteDataReq() : tablet_id(0), schema_hash(0), version(0), version_hash(0) {
  }

  virtual ~TCancelDeleteDataReq() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_version(const  ::palo::TVersion val);

  void __set_version_hash(const  ::palo::TVersionHash val);

  bool operator == (const TCancelDeleteDataReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    return true;
  }
  bool operator != (const TCancelDeleteDataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelDeleteDataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCancelDeleteDataReq &a, TCancelDeleteDataReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCancelDeleteDataReq& obj)
{
  obj.printTo(out);
  return out;
}


class TCheckConsistencyReq {
 public:

  TCheckConsistencyReq(const TCheckConsistencyReq&);
  TCheckConsistencyReq& operator=(const TCheckConsistencyReq&);
  TCheckConsistencyReq() : tablet_id(0), schema_hash(0), version(0), version_hash(0) {
  }

  virtual ~TCheckConsistencyReq() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_version(const  ::palo::TVersion val);

  void __set_version_hash(const  ::palo::TVersionHash val);

  bool operator == (const TCheckConsistencyReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(version_hash == rhs.version_hash))
      return false;
    return true;
  }
  bool operator != (const TCheckConsistencyReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCheckConsistencyReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCheckConsistencyReq &a, TCheckConsistencyReq &b);

inline std::ostream& operator<<(std::ostream& out, const TCheckConsistencyReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TUploadReq__isset {
  _TUploadReq__isset() : tablet_id(false) {}
  bool tablet_id :1;
} _TUploadReq__isset;

class TUploadReq {
 public:

  TUploadReq(const TUploadReq&);
  TUploadReq& operator=(const TUploadReq&);
  TUploadReq() : local_file_path(), remote_file_path(), tablet_id(0) {
  }

  virtual ~TUploadReq() throw();
  std::string local_file_path;
  std::string remote_file_path;
  std::map<std::string, std::string>  remote_source_properties;
   ::palo::TTabletId tablet_id;

  _TUploadReq__isset __isset;

  void __set_local_file_path(const std::string& val);

  void __set_remote_file_path(const std::string& val);

  void __set_remote_source_properties(const std::map<std::string, std::string> & val);

  void __set_tablet_id(const  ::palo::TTabletId val);

  bool operator == (const TUploadReq & rhs) const
  {
    if (!(local_file_path == rhs.local_file_path))
      return false;
    if (!(remote_file_path == rhs.remote_file_path))
      return false;
    if (!(remote_source_properties == rhs.remote_source_properties))
      return false;
    if (__isset.tablet_id != rhs.__isset.tablet_id)
      return false;
    else if (__isset.tablet_id && !(tablet_id == rhs.tablet_id))
      return false;
    return true;
  }
  bool operator != (const TUploadReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUploadReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUploadReq &a, TUploadReq &b);

inline std::ostream& operator<<(std::ostream& out, const TUploadReq& obj)
{
  obj.printTo(out);
  return out;
}


class TRestoreReq {
 public:

  TRestoreReq(const TRestoreReq&);
  TRestoreReq& operator=(const TRestoreReq&);
  TRestoreReq() : tablet_id(0), schema_hash(0), remote_file_path() {
  }

  virtual ~TRestoreReq() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
  std::string remote_file_path;
  std::map<std::string, std::string>  remote_source_properties;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_remote_file_path(const std::string& val);

  void __set_remote_source_properties(const std::map<std::string, std::string> & val);

  bool operator == (const TRestoreReq & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (!(remote_file_path == rhs.remote_file_path))
      return false;
    if (!(remote_source_properties == rhs.remote_source_properties))
      return false;
    return true;
  }
  bool operator != (const TRestoreReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRestoreReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRestoreReq &a, TRestoreReq &b);

inline std::ostream& operator<<(std::ostream& out, const TRestoreReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TSnapshotRequest__isset {
  _TSnapshotRequest__isset() : version(false), version_hash(false), timeout(false) {}
  bool version :1;
  bool version_hash :1;
  bool timeout :1;
} _TSnapshotRequest__isset;

class TSnapshotRequest {
 public:

  TSnapshotRequest(const TSnapshotRequest&);
  TSnapshotRequest& operator=(const TSnapshotRequest&);
  TSnapshotRequest() : tablet_id(0), schema_hash(0), version(0), version_hash(0), timeout(0) {
  }

  virtual ~TSnapshotRequest() throw();
   ::palo::TTabletId tablet_id;
   ::palo::TSchemaHash schema_hash;
   ::palo::TVersion version;
   ::palo::TVersionHash version_hash;
  int64_t timeout;

  _TSnapshotRequest__isset __isset;

  void __set_tablet_id(const  ::palo::TTabletId val);

  void __set_schema_hash(const  ::palo::TSchemaHash val);

  void __set_version(const  ::palo::TVersion val);

  void __set_version_hash(const  ::palo::TVersionHash val);

  void __set_timeout(const int64_t val);

  bool operator == (const TSnapshotRequest & rhs) const
  {
    if (!(tablet_id == rhs.tablet_id))
      return false;
    if (!(schema_hash == rhs.schema_hash))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.version_hash != rhs.__isset.version_hash)
      return false;
    else if (__isset.version_hash && !(version_hash == rhs.version_hash))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const TSnapshotRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSnapshotRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSnapshotRequest &a, TSnapshotRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TReleaseSnapshotRequest {
 public:

  TReleaseSnapshotRequest(const TReleaseSnapshotRequest&);
  TReleaseSnapshotRequest& operator=(const TReleaseSnapshotRequest&);
  TReleaseSnapshotRequest() : snapshot_path() {
  }

  virtual ~TReleaseSnapshotRequest() throw();
  std::string snapshot_path;

  void __set_snapshot_path(const std::string& val);

  bool operator == (const TReleaseSnapshotRequest & rhs) const
  {
    if (!(snapshot_path == rhs.snapshot_path))
      return false;
    return true;
  }
  bool operator != (const TReleaseSnapshotRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TReleaseSnapshotRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TReleaseSnapshotRequest &a, TReleaseSnapshotRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TReleaseSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TClearRemoteFileReq {
 public:

  TClearRemoteFileReq(const TClearRemoteFileReq&);
  TClearRemoteFileReq& operator=(const TClearRemoteFileReq&);
  TClearRemoteFileReq() : remote_file_path() {
  }

  virtual ~TClearRemoteFileReq() throw();
  std::string remote_file_path;
  std::map<std::string, std::string>  remote_source_properties;

  void __set_remote_file_path(const std::string& val);

  void __set_remote_source_properties(const std::map<std::string, std::string> & val);

  bool operator == (const TClearRemoteFileReq & rhs) const
  {
    if (!(remote_file_path == rhs.remote_file_path))
      return false;
    if (!(remote_source_properties == rhs.remote_source_properties))
      return false;
    return true;
  }
  bool operator != (const TClearRemoteFileReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TClearRemoteFileReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TClearRemoteFileReq &a, TClearRemoteFileReq &b);

inline std::ostream& operator<<(std::ostream& out, const TClearRemoteFileReq& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TAgentTaskRequest__isset {
  _TAgentTaskRequest__isset() : priority(false), create_tablet_req(false), drop_tablet_req(false), alter_tablet_req(false), clone_req(false), push_req(false), cancel_delete_data_req(false), resource_info(false), storage_medium_migrate_req(false), check_consistency_req(false), upload_req(false), restore_req(false), snapshot_req(false), release_snapshot_req(false), clear_remote_file_req(false) {}
  bool priority :1;
  bool create_tablet_req :1;
  bool drop_tablet_req :1;
  bool alter_tablet_req :1;
  bool clone_req :1;
  bool push_req :1;
  bool cancel_delete_data_req :1;
  bool resource_info :1;
  bool storage_medium_migrate_req :1;
  bool check_consistency_req :1;
  bool upload_req :1;
  bool restore_req :1;
  bool snapshot_req :1;
  bool release_snapshot_req :1;
  bool clear_remote_file_req :1;
} _TAgentTaskRequest__isset;

class TAgentTaskRequest {
 public:

  TAgentTaskRequest(const TAgentTaskRequest&);
  TAgentTaskRequest& operator=(const TAgentTaskRequest&);
  TAgentTaskRequest() : protocol_version((TAgentServiceVersion::type)0), task_type(( ::palo::TTaskType::type)0), signature(0), priority(( ::palo::TPriority::type)0) {
  }

  virtual ~TAgentTaskRequest() throw();
  TAgentServiceVersion::type protocol_version;
   ::palo::TTaskType::type task_type;
  int64_t signature;
   ::palo::TPriority::type priority;
  TCreateTabletReq create_tablet_req;
  TDropTabletReq drop_tablet_req;
  TAlterTabletReq alter_tablet_req;
  TCloneReq clone_req;
  TPushReq push_req;
  TCancelDeleteDataReq cancel_delete_data_req;
   ::palo::TResourceInfo resource_info;
  TStorageMediumMigrateReq storage_medium_migrate_req;
  TCheckConsistencyReq check_consistency_req;
  TUploadReq upload_req;
  TRestoreReq restore_req;
  TSnapshotRequest snapshot_req;
  TReleaseSnapshotRequest release_snapshot_req;
  TClearRemoteFileReq clear_remote_file_req;

  _TAgentTaskRequest__isset __isset;

  void __set_protocol_version(const TAgentServiceVersion::type val);

  void __set_task_type(const  ::palo::TTaskType::type val);

  void __set_signature(const int64_t val);

  void __set_priority(const  ::palo::TPriority::type val);

  void __set_create_tablet_req(const TCreateTabletReq& val);

  void __set_drop_tablet_req(const TDropTabletReq& val);

  void __set_alter_tablet_req(const TAlterTabletReq& val);

  void __set_clone_req(const TCloneReq& val);

  void __set_push_req(const TPushReq& val);

  void __set_cancel_delete_data_req(const TCancelDeleteDataReq& val);

  void __set_resource_info(const  ::palo::TResourceInfo& val);

  void __set_storage_medium_migrate_req(const TStorageMediumMigrateReq& val);

  void __set_check_consistency_req(const TCheckConsistencyReq& val);

  void __set_upload_req(const TUploadReq& val);

  void __set_restore_req(const TRestoreReq& val);

  void __set_snapshot_req(const TSnapshotRequest& val);

  void __set_release_snapshot_req(const TReleaseSnapshotRequest& val);

  void __set_clear_remote_file_req(const TClearRemoteFileReq& val);

  bool operator == (const TAgentTaskRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(task_type == rhs.task_type))
      return false;
    if (!(signature == rhs.signature))
      return false;
    if (__isset.priority != rhs.__isset.priority)
      return false;
    else if (__isset.priority && !(priority == rhs.priority))
      return false;
    if (__isset.create_tablet_req != rhs.__isset.create_tablet_req)
      return false;
    else if (__isset.create_tablet_req && !(create_tablet_req == rhs.create_tablet_req))
      return false;
    if (__isset.drop_tablet_req != rhs.__isset.drop_tablet_req)
      return false;
    else if (__isset.drop_tablet_req && !(drop_tablet_req == rhs.drop_tablet_req))
      return false;
    if (__isset.alter_tablet_req != rhs.__isset.alter_tablet_req)
      return false;
    else if (__isset.alter_tablet_req && !(alter_tablet_req == rhs.alter_tablet_req))
      return false;
    if (__isset.clone_req != rhs.__isset.clone_req)
      return false;
    else if (__isset.clone_req && !(clone_req == rhs.clone_req))
      return false;
    if (__isset.push_req != rhs.__isset.push_req)
      return false;
    else if (__isset.push_req && !(push_req == rhs.push_req))
      return false;
    if (__isset.cancel_delete_data_req != rhs.__isset.cancel_delete_data_req)
      return false;
    else if (__isset.cancel_delete_data_req && !(cancel_delete_data_req == rhs.cancel_delete_data_req))
      return false;
    if (__isset.resource_info != rhs.__isset.resource_info)
      return false;
    else if (__isset.resource_info && !(resource_info == rhs.resource_info))
      return false;
    if (__isset.storage_medium_migrate_req != rhs.__isset.storage_medium_migrate_req)
      return false;
    else if (__isset.storage_medium_migrate_req && !(storage_medium_migrate_req == rhs.storage_medium_migrate_req))
      return false;
    if (__isset.check_consistency_req != rhs.__isset.check_consistency_req)
      return false;
    else if (__isset.check_consistency_req && !(check_consistency_req == rhs.check_consistency_req))
      return false;
    if (__isset.upload_req != rhs.__isset.upload_req)
      return false;
    else if (__isset.upload_req && !(upload_req == rhs.upload_req))
      return false;
    if (__isset.restore_req != rhs.__isset.restore_req)
      return false;
    else if (__isset.restore_req && !(restore_req == rhs.restore_req))
      return false;
    if (__isset.snapshot_req != rhs.__isset.snapshot_req)
      return false;
    else if (__isset.snapshot_req && !(snapshot_req == rhs.snapshot_req))
      return false;
    if (__isset.release_snapshot_req != rhs.__isset.release_snapshot_req)
      return false;
    else if (__isset.release_snapshot_req && !(release_snapshot_req == rhs.release_snapshot_req))
      return false;
    if (__isset.clear_remote_file_req != rhs.__isset.clear_remote_file_req)
      return false;
    else if (__isset.clear_remote_file_req && !(clear_remote_file_req == rhs.clear_remote_file_req))
      return false;
    return true;
  }
  bool operator != (const TAgentTaskRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentTaskRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAgentTaskRequest &a, TAgentTaskRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TAgentTaskRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TAgentResult__isset {
  _TAgentResult__isset() : snapshot_path(false) {}
  bool snapshot_path :1;
} _TAgentResult__isset;

class TAgentResult {
 public:

  TAgentResult(const TAgentResult&);
  TAgentResult& operator=(const TAgentResult&);
  TAgentResult() : snapshot_path() {
  }

  virtual ~TAgentResult() throw();
   ::palo::TStatus status;
  std::string snapshot_path;

  _TAgentResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val);

  void __set_snapshot_path(const std::string& val);

  bool operator == (const TAgentResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.snapshot_path != rhs.__isset.snapshot_path)
      return false;
    else if (__isset.snapshot_path && !(snapshot_path == rhs.snapshot_path))
      return false;
    return true;
  }
  bool operator != (const TAgentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAgentResult &a, TAgentResult &b);

inline std::ostream& operator<<(std::ostream& out, const TAgentResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTopicItem__isset {
  _TTopicItem__isset() : int_value(false), double_value(false), string_value(false) {}
  bool int_value :1;
  bool double_value :1;
  bool string_value :1;
} _TTopicItem__isset;

class TTopicItem {
 public:

  TTopicItem(const TTopicItem&);
  TTopicItem& operator=(const TTopicItem&);
  TTopicItem() : key(), int_value(0), double_value(0), string_value() {
  }

  virtual ~TTopicItem() throw();
  std::string key;
  int64_t int_value;
  double double_value;
  std::string string_value;

  _TTopicItem__isset __isset;

  void __set_key(const std::string& val);

  void __set_int_value(const int64_t val);

  void __set_double_value(const double val);

  void __set_string_value(const std::string& val);

  bool operator == (const TTopicItem & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (__isset.int_value != rhs.__isset.int_value)
      return false;
    else if (__isset.int_value && !(int_value == rhs.int_value))
      return false;
    if (__isset.double_value != rhs.__isset.double_value)
      return false;
    else if (__isset.double_value && !(double_value == rhs.double_value))
      return false;
    if (__isset.string_value != rhs.__isset.string_value)
      return false;
    else if (__isset.string_value && !(string_value == rhs.string_value))
      return false;
    return true;
  }
  bool operator != (const TTopicItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTopicItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTopicItem &a, TTopicItem &b);

inline std::ostream& operator<<(std::ostream& out, const TTopicItem& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTopicUpdate__isset {
  _TTopicUpdate__isset() : updates(false), deletes(false) {}
  bool updates :1;
  bool deletes :1;
} _TTopicUpdate__isset;

class TTopicUpdate {
 public:

  TTopicUpdate(const TTopicUpdate&);
  TTopicUpdate& operator=(const TTopicUpdate&);
  TTopicUpdate() : type((TTopicType::type)0) {
  }

  virtual ~TTopicUpdate() throw();
  TTopicType::type type;
  std::vector<TTopicItem>  updates;
  std::vector<std::string>  deletes;

  _TTopicUpdate__isset __isset;

  void __set_type(const TTopicType::type val);

  void __set_updates(const std::vector<TTopicItem> & val);

  void __set_deletes(const std::vector<std::string> & val);

  bool operator == (const TTopicUpdate & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.updates != rhs.__isset.updates)
      return false;
    else if (__isset.updates && !(updates == rhs.updates))
      return false;
    if (__isset.deletes != rhs.__isset.deletes)
      return false;
    else if (__isset.deletes && !(deletes == rhs.deletes))
      return false;
    return true;
  }
  bool operator != (const TTopicUpdate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTopicUpdate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTopicUpdate &a, TTopicUpdate &b);

inline std::ostream& operator<<(std::ostream& out, const TTopicUpdate& obj)
{
  obj.printTo(out);
  return out;
}


class TAgentPublishRequest {
 public:

  TAgentPublishRequest(const TAgentPublishRequest&);
  TAgentPublishRequest& operator=(const TAgentPublishRequest&);
  TAgentPublishRequest() : protocol_version((TAgentServiceVersion::type)0) {
  }

  virtual ~TAgentPublishRequest() throw();
  TAgentServiceVersion::type protocol_version;
  std::vector<TTopicUpdate>  updates;

  void __set_protocol_version(const TAgentServiceVersion::type val);

  void __set_updates(const std::vector<TTopicUpdate> & val);

  bool operator == (const TAgentPublishRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(updates == rhs.updates))
      return false;
    return true;
  }
  bool operator != (const TAgentPublishRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAgentPublishRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAgentPublishRequest &a, TAgentPublishRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TAgentPublishRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TMiniLoadEtlTaskRequest {
 public:

  TMiniLoadEtlTaskRequest(const TMiniLoadEtlTaskRequest&);
  TMiniLoadEtlTaskRequest& operator=(const TMiniLoadEtlTaskRequest&);
  TMiniLoadEtlTaskRequest() : protocol_version((TAgentServiceVersion::type)0) {
  }

  virtual ~TMiniLoadEtlTaskRequest() throw();
  TAgentServiceVersion::type protocol_version;
   ::palo::TExecPlanFragmentParams params;

  void __set_protocol_version(const TAgentServiceVersion::type val);

  void __set_params(const  ::palo::TExecPlanFragmentParams& val);

  bool operator == (const TMiniLoadEtlTaskRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(params == rhs.params))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlTaskRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlTaskRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMiniLoadEtlTaskRequest &a, TMiniLoadEtlTaskRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TMiniLoadEtlTaskRequest& obj)
{
  obj.printTo(out);
  return out;
}


class TMiniLoadEtlStatusRequest {
 public:

  TMiniLoadEtlStatusRequest(const TMiniLoadEtlStatusRequest&);
  TMiniLoadEtlStatusRequest& operator=(const TMiniLoadEtlStatusRequest&);
  TMiniLoadEtlStatusRequest() : protocol_version((TAgentServiceVersion::type)0) {
  }

  virtual ~TMiniLoadEtlStatusRequest() throw();
  TAgentServiceVersion::type protocol_version;
   ::palo::TUniqueId mini_load_id;

  void __set_protocol_version(const TAgentServiceVersion::type val);

  void __set_mini_load_id(const  ::palo::TUniqueId& val);

  bool operator == (const TMiniLoadEtlStatusRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(mini_load_id == rhs.mini_load_id))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlStatusRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlStatusRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMiniLoadEtlStatusRequest &a, TMiniLoadEtlStatusRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TMiniLoadEtlStatusRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TMiniLoadEtlStatusResult__isset {
  _TMiniLoadEtlStatusResult__isset() : file_map(false), counters(false), tracking_url(false) {}
  bool file_map :1;
  bool counters :1;
  bool tracking_url :1;
} _TMiniLoadEtlStatusResult__isset;

class TMiniLoadEtlStatusResult {
 public:

  TMiniLoadEtlStatusResult(const TMiniLoadEtlStatusResult&);
  TMiniLoadEtlStatusResult& operator=(const TMiniLoadEtlStatusResult&);
  TMiniLoadEtlStatusResult() : etl_state(( ::palo::TEtlState::type)0), tracking_url() {
  }

  virtual ~TMiniLoadEtlStatusResult() throw();
   ::palo::TStatus status;
   ::palo::TEtlState::type etl_state;
  std::map<std::string, int64_t>  file_map;
  std::map<std::string, std::string>  counters;
  std::string tracking_url;

  _TMiniLoadEtlStatusResult__isset __isset;

  void __set_status(const  ::palo::TStatus& val);

  void __set_etl_state(const  ::palo::TEtlState::type val);

  void __set_file_map(const std::map<std::string, int64_t> & val);

  void __set_counters(const std::map<std::string, std::string> & val);

  void __set_tracking_url(const std::string& val);

  bool operator == (const TMiniLoadEtlStatusResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(etl_state == rhs.etl_state))
      return false;
    if (__isset.file_map != rhs.__isset.file_map)
      return false;
    else if (__isset.file_map && !(file_map == rhs.file_map))
      return false;
    if (__isset.counters != rhs.__isset.counters)
      return false;
    else if (__isset.counters && !(counters == rhs.counters))
      return false;
    if (__isset.tracking_url != rhs.__isset.tracking_url)
      return false;
    else if (__isset.tracking_url && !(tracking_url == rhs.tracking_url))
      return false;
    return true;
  }
  bool operator != (const TMiniLoadEtlStatusResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMiniLoadEtlStatusResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMiniLoadEtlStatusResult &a, TMiniLoadEtlStatusResult &b);

inline std::ostream& operator<<(std::ostream& out, const TMiniLoadEtlStatusResult& obj)
{
  obj.printTo(out);
  return out;
}


class TDeleteEtlFilesRequest {
 public:

  TDeleteEtlFilesRequest(const TDeleteEtlFilesRequest&);
  TDeleteEtlFilesRequest& operator=(const TDeleteEtlFilesRequest&);
  TDeleteEtlFilesRequest() : protocol_version((TAgentServiceVersion::type)0), db_name(), label() {
  }

  virtual ~TDeleteEtlFilesRequest() throw();
  TAgentServiceVersion::type protocol_version;
   ::palo::TUniqueId mini_load_id;
  std::string db_name;
  std::string label;

  void __set_protocol_version(const TAgentServiceVersion::type val);

  void __set_mini_load_id(const  ::palo::TUniqueId& val);

  void __set_db_name(const std::string& val);

  void __set_label(const std::string& val);

  bool operator == (const TDeleteEtlFilesRequest & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (!(mini_load_id == rhs.mini_load_id))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(label == rhs.label))
      return false;
    return true;
  }
  bool operator != (const TDeleteEtlFilesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDeleteEtlFilesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDeleteEtlFilesRequest &a, TDeleteEtlFilesRequest &b);

inline std::ostream& operator<<(std::ostream& out, const TDeleteEtlFilesRequest& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
