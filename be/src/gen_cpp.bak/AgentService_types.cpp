/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "AgentService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTAgentServiceVersionValues[] = {
  TAgentServiceVersion::V1
};
const char* _kTAgentServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _TAgentServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTAgentServiceVersionValues, _kTAgentServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTopicTypeValues[] = {
  TTopicType::RESOURCE
};
const char* _kTTopicTypeNames[] = {
  "RESOURCE"
};
const std::map<int, const char*> _TTopicType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTTopicTypeValues, _kTTopicTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TColumn::~TColumn() throw() {
}


void TColumn::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void TColumn::__set_column_type(const  ::palo::TColumnType& val) {
  this->column_type = val;
}

void TColumn::__set_aggregation_type(const  ::palo::TAggregationType::type val) {
  this->aggregation_type = val;
__isset.aggregation_type = true;
}

void TColumn::__set_is_key(const bool val) {
  this->is_key = val;
__isset.is_key = true;
}

void TColumn::__set_is_allow_null(const bool val) {
  this->is_allow_null = val;
__isset.is_allow_null = true;
}

void TColumn::__set_default_value(const std::string& val) {
  this->default_value = val;
__isset.default_value = true;
}

void TColumn::__set_is_bloom_filter_column(const bool val) {
  this->is_bloom_filter_column = val;
__isset.is_bloom_filter_column = true;
}

uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_name = false;
  bool isset_column_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_type.read(iprot);
          isset_column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->aggregation_type = ( ::palo::TAggregationType::type)ecast0;
          this->__isset.aggregation_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_key);
          this->__isset.is_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allow_null);
          this->__isset.is_allow_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_value);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_bloom_filter_column);
          this->__isset.is_bloom_filter_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->column_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.aggregation_type) {
    xfer += oprot->writeFieldBegin("aggregation_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->aggregation_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_key) {
    xfer += oprot->writeFieldBegin("is_key", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_allow_null) {
    xfer += oprot->writeFieldBegin("is_allow_null", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_allow_null);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_value) {
    xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->default_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_bloom_filter_column) {
    xfer += oprot->writeFieldBegin("is_bloom_filter_column", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_bloom_filter_column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.column_type, b.column_type);
  swap(a.aggregation_type, b.aggregation_type);
  swap(a.is_key, b.is_key);
  swap(a.is_allow_null, b.is_allow_null);
  swap(a.default_value, b.default_value);
  swap(a.is_bloom_filter_column, b.is_bloom_filter_column);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other1) {
  column_name = other1.column_name;
  column_type = other1.column_type;
  aggregation_type = other1.aggregation_type;
  is_key = other1.is_key;
  is_allow_null = other1.is_allow_null;
  default_value = other1.default_value;
  is_bloom_filter_column = other1.is_bloom_filter_column;
  __isset = other1.__isset;
}
TColumn& TColumn::operator=(const TColumn& other2) {
  column_name = other2.column_name;
  column_type = other2.column_type;
  aggregation_type = other2.aggregation_type;
  is_key = other2.is_key;
  is_allow_null = other2.is_allow_null;
  default_value = other2.default_value;
  is_bloom_filter_column = other2.is_bloom_filter_column;
  __isset = other2.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "column_type=" << to_string(column_type);
  out << ", " << "aggregation_type="; (__isset.aggregation_type ? (out << to_string(aggregation_type)) : (out << "<null>"));
  out << ", " << "is_key="; (__isset.is_key ? (out << to_string(is_key)) : (out << "<null>"));
  out << ", " << "is_allow_null="; (__isset.is_allow_null ? (out << to_string(is_allow_null)) : (out << "<null>"));
  out << ", " << "default_value="; (__isset.default_value ? (out << to_string(default_value)) : (out << "<null>"));
  out << ", " << "is_bloom_filter_column="; (__isset.is_bloom_filter_column ? (out << to_string(is_bloom_filter_column)) : (out << "<null>"));
  out << ")";
}


TTabletSchema::~TTabletSchema() throw() {
}


void TTabletSchema::__set_short_key_column_count(const int16_t val) {
  this->short_key_column_count = val;
}

void TTabletSchema::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TTabletSchema::__set_keys_type(const  ::palo::TKeysType::type val) {
  this->keys_type = val;
}

void TTabletSchema::__set_storage_type(const  ::palo::TStorageType::type val) {
  this->storage_type = val;
}

void TTabletSchema::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
}

void TTabletSchema::__set_bloom_filter_fpp(const double val) {
  this->bloom_filter_fpp = val;
__isset.bloom_filter_fpp = true;
}

uint32_t TTabletSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_short_key_column_count = false;
  bool isset_schema_hash = false;
  bool isset_keys_type = false;
  bool isset_storage_type = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->short_key_column_count);
          isset_short_key_column_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->keys_type = ( ::palo::TKeysType::type)ecast3;
          isset_keys_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->storage_type = ( ::palo::TStorageType::type)ecast4;
          isset_storage_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->columns.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->columns[_i9].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->bloom_filter_fpp);
          this->__isset.bloom_filter_fpp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_short_key_column_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_keys_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_storage_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTabletSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTabletSchema");

  xfer += oprot->writeFieldBegin("short_key_column_count", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->short_key_column_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keys_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->keys_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->storage_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumn> ::const_iterator _iter10;
    for (_iter10 = this->columns.begin(); _iter10 != this->columns.end(); ++_iter10)
    {
      xfer += (*_iter10).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bloom_filter_fpp) {
    xfer += oprot->writeFieldBegin("bloom_filter_fpp", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->bloom_filter_fpp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTabletSchema &a, TTabletSchema &b) {
  using ::std::swap;
  swap(a.short_key_column_count, b.short_key_column_count);
  swap(a.schema_hash, b.schema_hash);
  swap(a.keys_type, b.keys_type);
  swap(a.storage_type, b.storage_type);
  swap(a.columns, b.columns);
  swap(a.bloom_filter_fpp, b.bloom_filter_fpp);
  swap(a.__isset, b.__isset);
}

TTabletSchema::TTabletSchema(const TTabletSchema& other11) {
  short_key_column_count = other11.short_key_column_count;
  schema_hash = other11.schema_hash;
  keys_type = other11.keys_type;
  storage_type = other11.storage_type;
  columns = other11.columns;
  bloom_filter_fpp = other11.bloom_filter_fpp;
  __isset = other11.__isset;
}
TTabletSchema& TTabletSchema::operator=(const TTabletSchema& other12) {
  short_key_column_count = other12.short_key_column_count;
  schema_hash = other12.schema_hash;
  keys_type = other12.keys_type;
  storage_type = other12.storage_type;
  columns = other12.columns;
  bloom_filter_fpp = other12.bloom_filter_fpp;
  __isset = other12.__isset;
  return *this;
}
void TTabletSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTabletSchema(";
  out << "short_key_column_count=" << to_string(short_key_column_count);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "keys_type=" << to_string(keys_type);
  out << ", " << "storage_type=" << to_string(storage_type);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "bloom_filter_fpp="; (__isset.bloom_filter_fpp ? (out << to_string(bloom_filter_fpp)) : (out << "<null>"));
  out << ")";
}


TCreateTabletReq::~TCreateTabletReq() throw() {
}


void TCreateTabletReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TCreateTabletReq::__set_tablet_schema(const TTabletSchema& val) {
  this->tablet_schema = val;
}

void TCreateTabletReq::__set_version(const  ::palo::TVersion val) {
  this->version = val;
__isset.version = true;
}

void TCreateTabletReq::__set_version_hash(const  ::palo::TVersionHash val) {
  this->version_hash = val;
__isset.version_hash = true;
}

void TCreateTabletReq::__set_storage_medium(const  ::palo::TStorageMedium::type val) {
  this->storage_medium = val;
__isset.storage_medium = true;
}

uint32_t TCreateTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_tablet_schema = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tablet_schema.read(iprot);
          isset_tablet_schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          this->__isset.version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->storage_medium = ( ::palo::TStorageMedium::type)ecast13;
          this->__isset.storage_medium = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablet_schema)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateTabletReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablet_schema", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tablet_schema.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version_hash) {
    xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->version_hash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_medium) {
    xfer += oprot->writeFieldBegin("storage_medium", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->storage_medium);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateTabletReq &a, TCreateTabletReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.tablet_schema, b.tablet_schema);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.storage_medium, b.storage_medium);
  swap(a.__isset, b.__isset);
}

TCreateTabletReq::TCreateTabletReq(const TCreateTabletReq& other14) {
  tablet_id = other14.tablet_id;
  tablet_schema = other14.tablet_schema;
  version = other14.version;
  version_hash = other14.version_hash;
  storage_medium = other14.storage_medium;
  __isset = other14.__isset;
}
TCreateTabletReq& TCreateTabletReq::operator=(const TCreateTabletReq& other15) {
  tablet_id = other15.tablet_id;
  tablet_schema = other15.tablet_schema;
  version = other15.version;
  version_hash = other15.version_hash;
  storage_medium = other15.storage_medium;
  __isset = other15.__isset;
  return *this;
}
void TCreateTabletReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateTabletReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "tablet_schema=" << to_string(tablet_schema);
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "version_hash="; (__isset.version_hash ? (out << to_string(version_hash)) : (out << "<null>"));
  out << ", " << "storage_medium="; (__isset.storage_medium ? (out << to_string(storage_medium)) : (out << "<null>"));
  out << ")";
}


TDropTabletReq::~TDropTabletReq() throw() {
}


void TDropTabletReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TDropTabletReq::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
__isset.schema_hash = true;
}

uint32_t TDropTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          this->__isset.schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropTabletReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schema_hash) {
    xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->schema_hash);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropTabletReq &a, TDropTabletReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.__isset, b.__isset);
}

TDropTabletReq::TDropTabletReq(const TDropTabletReq& other16) {
  tablet_id = other16.tablet_id;
  schema_hash = other16.schema_hash;
  __isset = other16.__isset;
}
TDropTabletReq& TDropTabletReq::operator=(const TDropTabletReq& other17) {
  tablet_id = other17.tablet_id;
  schema_hash = other17.schema_hash;
  __isset = other17.__isset;
  return *this;
}
void TDropTabletReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDropTabletReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash="; (__isset.schema_hash ? (out << to_string(schema_hash)) : (out << "<null>"));
  out << ")";
}


TAlterTabletReq::~TAlterTabletReq() throw() {
}


void TAlterTabletReq::__set_base_tablet_id(const  ::palo::TTabletId val) {
  this->base_tablet_id = val;
}

void TAlterTabletReq::__set_base_schema_hash(const  ::palo::TSchemaHash val) {
  this->base_schema_hash = val;
}

void TAlterTabletReq::__set_new_tablet_req(const TCreateTabletReq& val) {
  this->new_tablet_req = val;
}

uint32_t TAlterTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base_tablet_id = false;
  bool isset_base_schema_hash = false;
  bool isset_new_tablet_req = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->base_tablet_id);
          isset_base_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->base_schema_hash);
          isset_base_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->new_tablet_req.read(iprot);
          isset_new_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_base_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_new_tablet_req)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTabletReq");

  xfer += oprot->writeFieldBegin("base_tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->base_tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("base_schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->base_schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_tablet_req", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->new_tablet_req.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTabletReq &a, TAlterTabletReq &b) {
  using ::std::swap;
  swap(a.base_tablet_id, b.base_tablet_id);
  swap(a.base_schema_hash, b.base_schema_hash);
  swap(a.new_tablet_req, b.new_tablet_req);
}

TAlterTabletReq::TAlterTabletReq(const TAlterTabletReq& other18) {
  base_tablet_id = other18.base_tablet_id;
  base_schema_hash = other18.base_schema_hash;
  new_tablet_req = other18.new_tablet_req;
}
TAlterTabletReq& TAlterTabletReq::operator=(const TAlterTabletReq& other19) {
  base_tablet_id = other19.base_tablet_id;
  base_schema_hash = other19.base_schema_hash;
  new_tablet_req = other19.new_tablet_req;
  return *this;
}
void TAlterTabletReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAlterTabletReq(";
  out << "base_tablet_id=" << to_string(base_tablet_id);
  out << ", " << "base_schema_hash=" << to_string(base_schema_hash);
  out << ", " << "new_tablet_req=" << to_string(new_tablet_req);
  out << ")";
}


TClusterInfo::~TClusterInfo() throw() {
}


void TClusterInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TClusterInfo::__set_password(const std::string& val) {
  this->password = val;
}

uint32_t TClusterInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;
  bool isset_password = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          isset_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_password)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TClusterInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClusterInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClusterInfo &a, TClusterInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.password, b.password);
}

TClusterInfo::TClusterInfo(const TClusterInfo& other20) {
  user = other20.user;
  password = other20.password;
}
TClusterInfo& TClusterInfo::operator=(const TClusterInfo& other21) {
  user = other21.user;
  password = other21.password;
  return *this;
}
void TClusterInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClusterInfo(";
  out << "user=" << to_string(user);
  out << ", " << "password=" << to_string(password);
  out << ")";
}


TPushReq::~TPushReq() throw() {
}


void TPushReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TPushReq::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TPushReq::__set_version(const  ::palo::TVersion val) {
  this->version = val;
}

void TPushReq::__set_version_hash(const  ::palo::TVersionHash val) {
  this->version_hash = val;
}

void TPushReq::__set_timeout(const int64_t val) {
  this->timeout = val;
}

void TPushReq::__set_push_type(const  ::palo::TPushType::type val) {
  this->push_type = val;
}

void TPushReq::__set_http_file_path(const std::string& val) {
  this->http_file_path = val;
__isset.http_file_path = true;
}

void TPushReq::__set_http_file_size(const int64_t val) {
  this->http_file_size = val;
__isset.http_file_size = true;
}

void TPushReq::__set_delete_conditions(const std::vector< ::palo::TCondition> & val) {
  this->delete_conditions = val;
__isset.delete_conditions = true;
}

void TPushReq::__set_need_decompress(const bool val) {
  this->need_decompress = val;
__isset.need_decompress = true;
}

uint32_t TPushReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;
  bool isset_timeout = false;
  bool isset_push_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          isset_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->push_type = ( ::palo::TPushType::type)ecast22;
          isset_push_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->http_file_path);
          this->__isset.http_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->http_file_size);
          this->__isset.http_file_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->delete_conditions.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->delete_conditions.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->delete_conditions[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.delete_conditions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_decompress);
          this->__isset.need_decompress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeout)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_push_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPushReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPushReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("push_type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->push_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.http_file_path) {
    xfer += oprot->writeFieldBegin("http_file_path", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->http_file_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.http_file_size) {
    xfer += oprot->writeFieldBegin("http_file_size", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->http_file_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.delete_conditions) {
    xfer += oprot->writeFieldBegin("delete_conditions", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->delete_conditions.size()));
      std::vector< ::palo::TCondition> ::const_iterator _iter28;
      for (_iter28 = this->delete_conditions.begin(); _iter28 != this->delete_conditions.end(); ++_iter28)
      {
        xfer += (*_iter28).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.need_decompress) {
    xfer += oprot->writeFieldBegin("need_decompress", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->need_decompress);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPushReq &a, TPushReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.timeout, b.timeout);
  swap(a.push_type, b.push_type);
  swap(a.http_file_path, b.http_file_path);
  swap(a.http_file_size, b.http_file_size);
  swap(a.delete_conditions, b.delete_conditions);
  swap(a.need_decompress, b.need_decompress);
  swap(a.__isset, b.__isset);
}

TPushReq::TPushReq(const TPushReq& other29) {
  tablet_id = other29.tablet_id;
  schema_hash = other29.schema_hash;
  version = other29.version;
  version_hash = other29.version_hash;
  timeout = other29.timeout;
  push_type = other29.push_type;
  http_file_path = other29.http_file_path;
  http_file_size = other29.http_file_size;
  delete_conditions = other29.delete_conditions;
  need_decompress = other29.need_decompress;
  __isset = other29.__isset;
}
TPushReq& TPushReq::operator=(const TPushReq& other30) {
  tablet_id = other30.tablet_id;
  schema_hash = other30.schema_hash;
  version = other30.version;
  version_hash = other30.version_hash;
  timeout = other30.timeout;
  push_type = other30.push_type;
  http_file_path = other30.http_file_path;
  http_file_size = other30.http_file_size;
  delete_conditions = other30.delete_conditions;
  need_decompress = other30.need_decompress;
  __isset = other30.__isset;
  return *this;
}
void TPushReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPushReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "version=" << to_string(version);
  out << ", " << "version_hash=" << to_string(version_hash);
  out << ", " << "timeout=" << to_string(timeout);
  out << ", " << "push_type=" << to_string(push_type);
  out << ", " << "http_file_path="; (__isset.http_file_path ? (out << to_string(http_file_path)) : (out << "<null>"));
  out << ", " << "http_file_size="; (__isset.http_file_size ? (out << to_string(http_file_size)) : (out << "<null>"));
  out << ", " << "delete_conditions="; (__isset.delete_conditions ? (out << to_string(delete_conditions)) : (out << "<null>"));
  out << ", " << "need_decompress="; (__isset.need_decompress ? (out << to_string(need_decompress)) : (out << "<null>"));
  out << ")";
}


TCloneReq::~TCloneReq() throw() {
}


void TCloneReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TCloneReq::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TCloneReq::__set_src_backends(const std::vector< ::palo::TBackend> & val) {
  this->src_backends = val;
}

void TCloneReq::__set_storage_medium(const  ::palo::TStorageMedium::type val) {
  this->storage_medium = val;
__isset.storage_medium = true;
}

void TCloneReq::__set_committed_version(const  ::palo::TVersion val) {
  this->committed_version = val;
__isset.committed_version = true;
}

void TCloneReq::__set_committed_version_hash(const  ::palo::TVersionHash val) {
  this->committed_version_hash = val;
__isset.committed_version_hash = true;
}

uint32_t TCloneReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_src_backends = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src_backends.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->src_backends.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->src_backends[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_src_backends = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast36;
          xfer += iprot->readI32(ecast36);
          this->storage_medium = ( ::palo::TStorageMedium::type)ecast36;
          this->__isset.storage_medium = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->committed_version);
          this->__isset.committed_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->committed_version_hash);
          this->__isset.committed_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_backends)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCloneReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCloneReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_backends", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->src_backends.size()));
    std::vector< ::palo::TBackend> ::const_iterator _iter37;
    for (_iter37 = this->src_backends.begin(); _iter37 != this->src_backends.end(); ++_iter37)
    {
      xfer += (*_iter37).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.storage_medium) {
    xfer += oprot->writeFieldBegin("storage_medium", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->storage_medium);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.committed_version) {
    xfer += oprot->writeFieldBegin("committed_version", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->committed_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.committed_version_hash) {
    xfer += oprot->writeFieldBegin("committed_version_hash", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->committed_version_hash);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCloneReq &a, TCloneReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.src_backends, b.src_backends);
  swap(a.storage_medium, b.storage_medium);
  swap(a.committed_version, b.committed_version);
  swap(a.committed_version_hash, b.committed_version_hash);
  swap(a.__isset, b.__isset);
}

TCloneReq::TCloneReq(const TCloneReq& other38) {
  tablet_id = other38.tablet_id;
  schema_hash = other38.schema_hash;
  src_backends = other38.src_backends;
  storage_medium = other38.storage_medium;
  committed_version = other38.committed_version;
  committed_version_hash = other38.committed_version_hash;
  __isset = other38.__isset;
}
TCloneReq& TCloneReq::operator=(const TCloneReq& other39) {
  tablet_id = other39.tablet_id;
  schema_hash = other39.schema_hash;
  src_backends = other39.src_backends;
  storage_medium = other39.storage_medium;
  committed_version = other39.committed_version;
  committed_version_hash = other39.committed_version_hash;
  __isset = other39.__isset;
  return *this;
}
void TCloneReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCloneReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "src_backends=" << to_string(src_backends);
  out << ", " << "storage_medium="; (__isset.storage_medium ? (out << to_string(storage_medium)) : (out << "<null>"));
  out << ", " << "committed_version="; (__isset.committed_version ? (out << to_string(committed_version)) : (out << "<null>"));
  out << ", " << "committed_version_hash="; (__isset.committed_version_hash ? (out << to_string(committed_version_hash)) : (out << "<null>"));
  out << ")";
}


TStorageMediumMigrateReq::~TStorageMediumMigrateReq() throw() {
}


void TStorageMediumMigrateReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TStorageMediumMigrateReq::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TStorageMediumMigrateReq::__set_storage_medium(const  ::palo::TStorageMedium::type val) {
  this->storage_medium = val;
}

uint32_t TStorageMediumMigrateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_storage_medium = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast40;
          xfer += iprot->readI32(ecast40);
          this->storage_medium = ( ::palo::TStorageMedium::type)ecast40;
          isset_storage_medium = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_storage_medium)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStorageMediumMigrateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStorageMediumMigrateReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage_medium", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->storage_medium);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStorageMediumMigrateReq &a, TStorageMediumMigrateReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.storage_medium, b.storage_medium);
}

TStorageMediumMigrateReq::TStorageMediumMigrateReq(const TStorageMediumMigrateReq& other41) {
  tablet_id = other41.tablet_id;
  schema_hash = other41.schema_hash;
  storage_medium = other41.storage_medium;
}
TStorageMediumMigrateReq& TStorageMediumMigrateReq::operator=(const TStorageMediumMigrateReq& other42) {
  tablet_id = other42.tablet_id;
  schema_hash = other42.schema_hash;
  storage_medium = other42.storage_medium;
  return *this;
}
void TStorageMediumMigrateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStorageMediumMigrateReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "storage_medium=" << to_string(storage_medium);
  out << ")";
}


TCancelDeleteDataReq::~TCancelDeleteDataReq() throw() {
}


void TCancelDeleteDataReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TCancelDeleteDataReq::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TCancelDeleteDataReq::__set_version(const  ::palo::TVersion val) {
  this->version = val;
}

void TCancelDeleteDataReq::__set_version_hash(const  ::palo::TVersionHash val) {
  this->version_hash = val;
}

uint32_t TCancelDeleteDataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelDeleteDataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelDeleteDataReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelDeleteDataReq &a, TCancelDeleteDataReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
}

TCancelDeleteDataReq::TCancelDeleteDataReq(const TCancelDeleteDataReq& other43) {
  tablet_id = other43.tablet_id;
  schema_hash = other43.schema_hash;
  version = other43.version;
  version_hash = other43.version_hash;
}
TCancelDeleteDataReq& TCancelDeleteDataReq::operator=(const TCancelDeleteDataReq& other44) {
  tablet_id = other44.tablet_id;
  schema_hash = other44.schema_hash;
  version = other44.version;
  version_hash = other44.version_hash;
  return *this;
}
void TCancelDeleteDataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelDeleteDataReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "version=" << to_string(version);
  out << ", " << "version_hash=" << to_string(version_hash);
  out << ")";
}


TCheckConsistencyReq::~TCheckConsistencyReq() throw() {
}


void TCheckConsistencyReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TCheckConsistencyReq::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TCheckConsistencyReq::__set_version(const  ::palo::TVersion val) {
  this->version = val;
}

void TCheckConsistencyReq::__set_version_hash(const  ::palo::TVersionHash val) {
  this->version_hash = val;
}

uint32_t TCheckConsistencyReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCheckConsistencyReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCheckConsistencyReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCheckConsistencyReq &a, TCheckConsistencyReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
}

TCheckConsistencyReq::TCheckConsistencyReq(const TCheckConsistencyReq& other45) {
  tablet_id = other45.tablet_id;
  schema_hash = other45.schema_hash;
  version = other45.version;
  version_hash = other45.version_hash;
}
TCheckConsistencyReq& TCheckConsistencyReq::operator=(const TCheckConsistencyReq& other46) {
  tablet_id = other46.tablet_id;
  schema_hash = other46.schema_hash;
  version = other46.version;
  version_hash = other46.version_hash;
  return *this;
}
void TCheckConsistencyReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCheckConsistencyReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "version=" << to_string(version);
  out << ", " << "version_hash=" << to_string(version_hash);
  out << ")";
}


TUploadReq::~TUploadReq() throw() {
}


void TUploadReq::__set_local_file_path(const std::string& val) {
  this->local_file_path = val;
}

void TUploadReq::__set_remote_file_path(const std::string& val) {
  this->remote_file_path = val;
}

void TUploadReq::__set_remote_source_properties(const std::map<std::string, std::string> & val) {
  this->remote_source_properties = val;
}

void TUploadReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
__isset.tablet_id = true;
}

uint32_t TUploadReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_local_file_path = false;
  bool isset_remote_file_path = false;
  bool isset_remote_source_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->local_file_path);
          isset_local_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_file_path);
          isset_remote_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->remote_source_properties.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _ktype48;
            ::apache::thrift::protocol::TType _vtype49;
            xfer += iprot->readMapBegin(_ktype48, _vtype49, _size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              std::string _key52;
              xfer += iprot->readString(_key52);
              std::string& _val53 = this->remote_source_properties[_key52];
              xfer += iprot->readString(_val53);
            }
            xfer += iprot->readMapEnd();
          }
          isset_remote_source_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          this->__isset.tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_local_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_source_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUploadReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUploadReq");

  xfer += oprot->writeFieldBegin("local_file_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->local_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_file_path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->remote_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_source_properties", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->remote_source_properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter54;
    for (_iter54 = this->remote_source_properties.begin(); _iter54 != this->remote_source_properties.end(); ++_iter54)
    {
      xfer += oprot->writeString(_iter54->first);
      xfer += oprot->writeString(_iter54->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablet_id) {
    xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->tablet_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUploadReq &a, TUploadReq &b) {
  using ::std::swap;
  swap(a.local_file_path, b.local_file_path);
  swap(a.remote_file_path, b.remote_file_path);
  swap(a.remote_source_properties, b.remote_source_properties);
  swap(a.tablet_id, b.tablet_id);
  swap(a.__isset, b.__isset);
}

TUploadReq::TUploadReq(const TUploadReq& other55) {
  local_file_path = other55.local_file_path;
  remote_file_path = other55.remote_file_path;
  remote_source_properties = other55.remote_source_properties;
  tablet_id = other55.tablet_id;
  __isset = other55.__isset;
}
TUploadReq& TUploadReq::operator=(const TUploadReq& other56) {
  local_file_path = other56.local_file_path;
  remote_file_path = other56.remote_file_path;
  remote_source_properties = other56.remote_source_properties;
  tablet_id = other56.tablet_id;
  __isset = other56.__isset;
  return *this;
}
void TUploadReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUploadReq(";
  out << "local_file_path=" << to_string(local_file_path);
  out << ", " << "remote_file_path=" << to_string(remote_file_path);
  out << ", " << "remote_source_properties=" << to_string(remote_source_properties);
  out << ", " << "tablet_id="; (__isset.tablet_id ? (out << to_string(tablet_id)) : (out << "<null>"));
  out << ")";
}


TRestoreReq::~TRestoreReq() throw() {
}


void TRestoreReq::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TRestoreReq::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TRestoreReq::__set_remote_file_path(const std::string& val) {
  this->remote_file_path = val;
}

void TRestoreReq::__set_remote_source_properties(const std::map<std::string, std::string> & val) {
  this->remote_source_properties = val;
}

uint32_t TRestoreReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_remote_file_path = false;
  bool isset_remote_source_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_file_path);
          isset_remote_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->remote_source_properties.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _ktype58;
            ::apache::thrift::protocol::TType _vtype59;
            xfer += iprot->readMapBegin(_ktype58, _vtype59, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              std::string _key62;
              xfer += iprot->readString(_key62);
              std::string& _val63 = this->remote_source_properties[_key62];
              xfer += iprot->readString(_val63);
            }
            xfer += iprot->readMapEnd();
          }
          isset_remote_source_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_source_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRestoreReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRestoreReq");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_file_path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->remote_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_source_properties", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->remote_source_properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter64;
    for (_iter64 = this->remote_source_properties.begin(); _iter64 != this->remote_source_properties.end(); ++_iter64)
    {
      xfer += oprot->writeString(_iter64->first);
      xfer += oprot->writeString(_iter64->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRestoreReq &a, TRestoreReq &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.remote_file_path, b.remote_file_path);
  swap(a.remote_source_properties, b.remote_source_properties);
}

TRestoreReq::TRestoreReq(const TRestoreReq& other65) {
  tablet_id = other65.tablet_id;
  schema_hash = other65.schema_hash;
  remote_file_path = other65.remote_file_path;
  remote_source_properties = other65.remote_source_properties;
}
TRestoreReq& TRestoreReq::operator=(const TRestoreReq& other66) {
  tablet_id = other66.tablet_id;
  schema_hash = other66.schema_hash;
  remote_file_path = other66.remote_file_path;
  remote_source_properties = other66.remote_source_properties;
  return *this;
}
void TRestoreReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRestoreReq(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "remote_file_path=" << to_string(remote_file_path);
  out << ", " << "remote_source_properties=" << to_string(remote_source_properties);
  out << ")";
}


TSnapshotRequest::~TSnapshotRequest() throw() {
}


void TSnapshotRequest::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TSnapshotRequest::__set_schema_hash(const  ::palo::TSchemaHash val) {
  this->schema_hash = val;
}

void TSnapshotRequest::__set_version(const  ::palo::TVersion val) {
  this->version = val;
__isset.version = true;
}

void TSnapshotRequest::__set_version_hash(const  ::palo::TVersionHash val) {
  this->version_hash = val;
__isset.version_hash = true;
}

void TSnapshotRequest::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

uint32_t TSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          this->__isset.version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSnapshotRequest");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version_hash) {
    xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->version_hash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSnapshotRequest &a, TSnapshotRequest &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

TSnapshotRequest::TSnapshotRequest(const TSnapshotRequest& other67) {
  tablet_id = other67.tablet_id;
  schema_hash = other67.schema_hash;
  version = other67.version;
  version_hash = other67.version_hash;
  timeout = other67.timeout;
  __isset = other67.__isset;
}
TSnapshotRequest& TSnapshotRequest::operator=(const TSnapshotRequest& other68) {
  tablet_id = other68.tablet_id;
  schema_hash = other68.schema_hash;
  version = other68.version;
  version_hash = other68.version_hash;
  timeout = other68.timeout;
  __isset = other68.__isset;
  return *this;
}
void TSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSnapshotRequest(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "version_hash="; (__isset.version_hash ? (out << to_string(version_hash)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


TReleaseSnapshotRequest::~TReleaseSnapshotRequest() throw() {
}


void TReleaseSnapshotRequest::__set_snapshot_path(const std::string& val) {
  this->snapshot_path = val;
}

uint32_t TReleaseSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_snapshot_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_path);
          isset_snapshot_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_snapshot_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TReleaseSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TReleaseSnapshotRequest");

  xfer += oprot->writeFieldBegin("snapshot_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->snapshot_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TReleaseSnapshotRequest &a, TReleaseSnapshotRequest &b) {
  using ::std::swap;
  swap(a.snapshot_path, b.snapshot_path);
}

TReleaseSnapshotRequest::TReleaseSnapshotRequest(const TReleaseSnapshotRequest& other69) {
  snapshot_path = other69.snapshot_path;
}
TReleaseSnapshotRequest& TReleaseSnapshotRequest::operator=(const TReleaseSnapshotRequest& other70) {
  snapshot_path = other70.snapshot_path;
  return *this;
}
void TReleaseSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TReleaseSnapshotRequest(";
  out << "snapshot_path=" << to_string(snapshot_path);
  out << ")";
}


TClearRemoteFileReq::~TClearRemoteFileReq() throw() {
}


void TClearRemoteFileReq::__set_remote_file_path(const std::string& val) {
  this->remote_file_path = val;
}

void TClearRemoteFileReq::__set_remote_source_properties(const std::map<std::string, std::string> & val) {
  this->remote_source_properties = val;
}

uint32_t TClearRemoteFileReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_remote_file_path = false;
  bool isset_remote_source_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_file_path);
          isset_remote_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->remote_source_properties.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _ktype72;
            ::apache::thrift::protocol::TType _vtype73;
            xfer += iprot->readMapBegin(_ktype72, _vtype73, _size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              std::string _key76;
              xfer += iprot->readString(_key76);
              std::string& _val77 = this->remote_source_properties[_key76];
              xfer += iprot->readString(_val77);
            }
            xfer += iprot->readMapEnd();
          }
          isset_remote_source_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_remote_file_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_source_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TClearRemoteFileReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClearRemoteFileReq");

  xfer += oprot->writeFieldBegin("remote_file_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->remote_file_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_source_properties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->remote_source_properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter78;
    for (_iter78 = this->remote_source_properties.begin(); _iter78 != this->remote_source_properties.end(); ++_iter78)
    {
      xfer += oprot->writeString(_iter78->first);
      xfer += oprot->writeString(_iter78->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClearRemoteFileReq &a, TClearRemoteFileReq &b) {
  using ::std::swap;
  swap(a.remote_file_path, b.remote_file_path);
  swap(a.remote_source_properties, b.remote_source_properties);
}

TClearRemoteFileReq::TClearRemoteFileReq(const TClearRemoteFileReq& other79) {
  remote_file_path = other79.remote_file_path;
  remote_source_properties = other79.remote_source_properties;
}
TClearRemoteFileReq& TClearRemoteFileReq::operator=(const TClearRemoteFileReq& other80) {
  remote_file_path = other80.remote_file_path;
  remote_source_properties = other80.remote_source_properties;
  return *this;
}
void TClearRemoteFileReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClearRemoteFileReq(";
  out << "remote_file_path=" << to_string(remote_file_path);
  out << ", " << "remote_source_properties=" << to_string(remote_source_properties);
  out << ")";
}


TAgentTaskRequest::~TAgentTaskRequest() throw() {
}


void TAgentTaskRequest::__set_protocol_version(const TAgentServiceVersion::type val) {
  this->protocol_version = val;
}

void TAgentTaskRequest::__set_task_type(const  ::palo::TTaskType::type val) {
  this->task_type = val;
}

void TAgentTaskRequest::__set_signature(const int64_t val) {
  this->signature = val;
}

void TAgentTaskRequest::__set_priority(const  ::palo::TPriority::type val) {
  this->priority = val;
__isset.priority = true;
}

void TAgentTaskRequest::__set_create_tablet_req(const TCreateTabletReq& val) {
  this->create_tablet_req = val;
__isset.create_tablet_req = true;
}

void TAgentTaskRequest::__set_drop_tablet_req(const TDropTabletReq& val) {
  this->drop_tablet_req = val;
__isset.drop_tablet_req = true;
}

void TAgentTaskRequest::__set_alter_tablet_req(const TAlterTabletReq& val) {
  this->alter_tablet_req = val;
__isset.alter_tablet_req = true;
}

void TAgentTaskRequest::__set_clone_req(const TCloneReq& val) {
  this->clone_req = val;
__isset.clone_req = true;
}

void TAgentTaskRequest::__set_push_req(const TPushReq& val) {
  this->push_req = val;
__isset.push_req = true;
}

void TAgentTaskRequest::__set_cancel_delete_data_req(const TCancelDeleteDataReq& val) {
  this->cancel_delete_data_req = val;
__isset.cancel_delete_data_req = true;
}

void TAgentTaskRequest::__set_resource_info(const  ::palo::TResourceInfo& val) {
  this->resource_info = val;
__isset.resource_info = true;
}

void TAgentTaskRequest::__set_storage_medium_migrate_req(const TStorageMediumMigrateReq& val) {
  this->storage_medium_migrate_req = val;
__isset.storage_medium_migrate_req = true;
}

void TAgentTaskRequest::__set_check_consistency_req(const TCheckConsistencyReq& val) {
  this->check_consistency_req = val;
__isset.check_consistency_req = true;
}

void TAgentTaskRequest::__set_upload_req(const TUploadReq& val) {
  this->upload_req = val;
__isset.upload_req = true;
}

void TAgentTaskRequest::__set_restore_req(const TRestoreReq& val) {
  this->restore_req = val;
__isset.restore_req = true;
}

void TAgentTaskRequest::__set_snapshot_req(const TSnapshotRequest& val) {
  this->snapshot_req = val;
__isset.snapshot_req = true;
}

void TAgentTaskRequest::__set_release_snapshot_req(const TReleaseSnapshotRequest& val) {
  this->release_snapshot_req = val;
__isset.release_snapshot_req = true;
}

void TAgentTaskRequest::__set_clear_remote_file_req(const TClearRemoteFileReq& val) {
  this->clear_remote_file_req = val;
__isset.clear_remote_file_req = true;
}

uint32_t TAgentTaskRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_task_type = false;
  bool isset_signature = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast81;
          xfer += iprot->readI32(ecast81);
          this->protocol_version = (TAgentServiceVersion::type)ecast81;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast82;
          xfer += iprot->readI32(ecast82);
          this->task_type = ( ::palo::TTaskType::type)ecast82;
          isset_task_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->signature);
          isset_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast83;
          xfer += iprot->readI32(ecast83);
          this->priority = ( ::palo::TPriority::type)ecast83;
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_tablet_req.read(iprot);
          this->__isset.create_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_tablet_req.read(iprot);
          this->__isset.drop_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->alter_tablet_req.read(iprot);
          this->__isset.alter_tablet_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clone_req.read(iprot);
          this->__isset.clone_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->push_req.read(iprot);
          this->__isset.push_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cancel_delete_data_req.read(iprot);
          this->__isset.cancel_delete_data_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_info.read(iprot);
          this->__isset.resource_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->storage_medium_migrate_req.read(iprot);
          this->__isset.storage_medium_migrate_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->check_consistency_req.read(iprot);
          this->__isset.check_consistency_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->upload_req.read(iprot);
          this->__isset.upload_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->restore_req.read(iprot);
          this->__isset.restore_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->snapshot_req.read(iprot);
          this->__isset.snapshot_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->release_snapshot_req.read(iprot);
          this->__isset.release_snapshot_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clear_remote_file_req.read(iprot);
          this->__isset.clear_remote_file_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_task_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_signature)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAgentTaskRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAgentTaskRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->task_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->signature);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.priority) {
    xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->priority);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_tablet_req) {
    xfer += oprot->writeFieldBegin("create_tablet_req", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->create_tablet_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_tablet_req) {
    xfer += oprot->writeFieldBegin("drop_tablet_req", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->drop_tablet_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alter_tablet_req) {
    xfer += oprot->writeFieldBegin("alter_tablet_req", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->alter_tablet_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clone_req) {
    xfer += oprot->writeFieldBegin("clone_req", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->clone_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.push_req) {
    xfer += oprot->writeFieldBegin("push_req", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->push_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cancel_delete_data_req) {
    xfer += oprot->writeFieldBegin("cancel_delete_data_req", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->cancel_delete_data_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_info) {
    xfer += oprot->writeFieldBegin("resource_info", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->resource_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_medium_migrate_req) {
    xfer += oprot->writeFieldBegin("storage_medium_migrate_req", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->storage_medium_migrate_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.check_consistency_req) {
    xfer += oprot->writeFieldBegin("check_consistency_req", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->check_consistency_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_req) {
    xfer += oprot->writeFieldBegin("upload_req", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->upload_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.restore_req) {
    xfer += oprot->writeFieldBegin("restore_req", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->restore_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_req) {
    xfer += oprot->writeFieldBegin("snapshot_req", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->snapshot_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.release_snapshot_req) {
    xfer += oprot->writeFieldBegin("release_snapshot_req", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->release_snapshot_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clear_remote_file_req) {
    xfer += oprot->writeFieldBegin("clear_remote_file_req", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->clear_remote_file_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentTaskRequest &a, TAgentTaskRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.task_type, b.task_type);
  swap(a.signature, b.signature);
  swap(a.priority, b.priority);
  swap(a.create_tablet_req, b.create_tablet_req);
  swap(a.drop_tablet_req, b.drop_tablet_req);
  swap(a.alter_tablet_req, b.alter_tablet_req);
  swap(a.clone_req, b.clone_req);
  swap(a.push_req, b.push_req);
  swap(a.cancel_delete_data_req, b.cancel_delete_data_req);
  swap(a.resource_info, b.resource_info);
  swap(a.storage_medium_migrate_req, b.storage_medium_migrate_req);
  swap(a.check_consistency_req, b.check_consistency_req);
  swap(a.upload_req, b.upload_req);
  swap(a.restore_req, b.restore_req);
  swap(a.snapshot_req, b.snapshot_req);
  swap(a.release_snapshot_req, b.release_snapshot_req);
  swap(a.clear_remote_file_req, b.clear_remote_file_req);
  swap(a.__isset, b.__isset);
}

TAgentTaskRequest::TAgentTaskRequest(const TAgentTaskRequest& other84) {
  protocol_version = other84.protocol_version;
  task_type = other84.task_type;
  signature = other84.signature;
  priority = other84.priority;
  create_tablet_req = other84.create_tablet_req;
  drop_tablet_req = other84.drop_tablet_req;
  alter_tablet_req = other84.alter_tablet_req;
  clone_req = other84.clone_req;
  push_req = other84.push_req;
  cancel_delete_data_req = other84.cancel_delete_data_req;
  resource_info = other84.resource_info;
  storage_medium_migrate_req = other84.storage_medium_migrate_req;
  check_consistency_req = other84.check_consistency_req;
  upload_req = other84.upload_req;
  restore_req = other84.restore_req;
  snapshot_req = other84.snapshot_req;
  release_snapshot_req = other84.release_snapshot_req;
  clear_remote_file_req = other84.clear_remote_file_req;
  __isset = other84.__isset;
}
TAgentTaskRequest& TAgentTaskRequest::operator=(const TAgentTaskRequest& other85) {
  protocol_version = other85.protocol_version;
  task_type = other85.task_type;
  signature = other85.signature;
  priority = other85.priority;
  create_tablet_req = other85.create_tablet_req;
  drop_tablet_req = other85.drop_tablet_req;
  alter_tablet_req = other85.alter_tablet_req;
  clone_req = other85.clone_req;
  push_req = other85.push_req;
  cancel_delete_data_req = other85.cancel_delete_data_req;
  resource_info = other85.resource_info;
  storage_medium_migrate_req = other85.storage_medium_migrate_req;
  check_consistency_req = other85.check_consistency_req;
  upload_req = other85.upload_req;
  restore_req = other85.restore_req;
  snapshot_req = other85.snapshot_req;
  release_snapshot_req = other85.release_snapshot_req;
  clear_remote_file_req = other85.clear_remote_file_req;
  __isset = other85.__isset;
  return *this;
}
void TAgentTaskRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAgentTaskRequest(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "task_type=" << to_string(task_type);
  out << ", " << "signature=" << to_string(signature);
  out << ", " << "priority="; (__isset.priority ? (out << to_string(priority)) : (out << "<null>"));
  out << ", " << "create_tablet_req="; (__isset.create_tablet_req ? (out << to_string(create_tablet_req)) : (out << "<null>"));
  out << ", " << "drop_tablet_req="; (__isset.drop_tablet_req ? (out << to_string(drop_tablet_req)) : (out << "<null>"));
  out << ", " << "alter_tablet_req="; (__isset.alter_tablet_req ? (out << to_string(alter_tablet_req)) : (out << "<null>"));
  out << ", " << "clone_req="; (__isset.clone_req ? (out << to_string(clone_req)) : (out << "<null>"));
  out << ", " << "push_req="; (__isset.push_req ? (out << to_string(push_req)) : (out << "<null>"));
  out << ", " << "cancel_delete_data_req="; (__isset.cancel_delete_data_req ? (out << to_string(cancel_delete_data_req)) : (out << "<null>"));
  out << ", " << "resource_info="; (__isset.resource_info ? (out << to_string(resource_info)) : (out << "<null>"));
  out << ", " << "storage_medium_migrate_req="; (__isset.storage_medium_migrate_req ? (out << to_string(storage_medium_migrate_req)) : (out << "<null>"));
  out << ", " << "check_consistency_req="; (__isset.check_consistency_req ? (out << to_string(check_consistency_req)) : (out << "<null>"));
  out << ", " << "upload_req="; (__isset.upload_req ? (out << to_string(upload_req)) : (out << "<null>"));
  out << ", " << "restore_req="; (__isset.restore_req ? (out << to_string(restore_req)) : (out << "<null>"));
  out << ", " << "snapshot_req="; (__isset.snapshot_req ? (out << to_string(snapshot_req)) : (out << "<null>"));
  out << ", " << "release_snapshot_req="; (__isset.release_snapshot_req ? (out << to_string(release_snapshot_req)) : (out << "<null>"));
  out << ", " << "clear_remote_file_req="; (__isset.clear_remote_file_req ? (out << to_string(clear_remote_file_req)) : (out << "<null>"));
  out << ")";
}


TAgentResult::~TAgentResult() throw() {
}


void TAgentResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
}

void TAgentResult::__set_snapshot_path(const std::string& val) {
  this->snapshot_path = val;
__isset.snapshot_path = true;
}

uint32_t TAgentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_path);
          this->__isset.snapshot_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAgentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAgentResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.snapshot_path) {
    xfer += oprot->writeFieldBegin("snapshot_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->snapshot_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentResult &a, TAgentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.snapshot_path, b.snapshot_path);
  swap(a.__isset, b.__isset);
}

TAgentResult::TAgentResult(const TAgentResult& other86) {
  status = other86.status;
  snapshot_path = other86.snapshot_path;
  __isset = other86.__isset;
}
TAgentResult& TAgentResult::operator=(const TAgentResult& other87) {
  status = other87.status;
  snapshot_path = other87.snapshot_path;
  __isset = other87.__isset;
  return *this;
}
void TAgentResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAgentResult(";
  out << "status=" << to_string(status);
  out << ", " << "snapshot_path="; (__isset.snapshot_path ? (out << to_string(snapshot_path)) : (out << "<null>"));
  out << ")";
}


TTopicItem::~TTopicItem() throw() {
}


void TTopicItem::__set_key(const std::string& val) {
  this->key = val;
}

void TTopicItem::__set_int_value(const int64_t val) {
  this->int_value = val;
__isset.int_value = true;
}

void TTopicItem::__set_double_value(const double val) {
  this->double_value = val;
__isset.double_value = true;
}

void TTopicItem::__set_string_value(const std::string& val) {
  this->string_value = val;
__isset.string_value = true;
}

uint32_t TTopicItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_value);
          this->__isset.int_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->double_value);
          this->__isset.double_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_value);
          this->__isset.string_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTopicItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTopicItem");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.int_value) {
    xfer += oprot->writeFieldBegin("int_value", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->int_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.double_value) {
    xfer += oprot->writeFieldBegin("double_value", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->double_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_value) {
    xfer += oprot->writeFieldBegin("string_value", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->string_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTopicItem &a, TTopicItem &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.int_value, b.int_value);
  swap(a.double_value, b.double_value);
  swap(a.string_value, b.string_value);
  swap(a.__isset, b.__isset);
}

TTopicItem::TTopicItem(const TTopicItem& other88) {
  key = other88.key;
  int_value = other88.int_value;
  double_value = other88.double_value;
  string_value = other88.string_value;
  __isset = other88.__isset;
}
TTopicItem& TTopicItem::operator=(const TTopicItem& other89) {
  key = other89.key;
  int_value = other89.int_value;
  double_value = other89.double_value;
  string_value = other89.string_value;
  __isset = other89.__isset;
  return *this;
}
void TTopicItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTopicItem(";
  out << "key=" << to_string(key);
  out << ", " << "int_value="; (__isset.int_value ? (out << to_string(int_value)) : (out << "<null>"));
  out << ", " << "double_value="; (__isset.double_value ? (out << to_string(double_value)) : (out << "<null>"));
  out << ", " << "string_value="; (__isset.string_value ? (out << to_string(string_value)) : (out << "<null>"));
  out << ")";
}


TTopicUpdate::~TTopicUpdate() throw() {
}


void TTopicUpdate::__set_type(const TTopicType::type val) {
  this->type = val;
}

void TTopicUpdate::__set_updates(const std::vector<TTopicItem> & val) {
  this->updates = val;
__isset.updates = true;
}

void TTopicUpdate::__set_deletes(const std::vector<std::string> & val) {
  this->deletes = val;
__isset.deletes = true;
}

uint32_t TTopicUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast90;
          xfer += iprot->readI32(ecast90);
          this->type = (TTopicType::type)ecast90;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _etype94;
            xfer += iprot->readListBegin(_etype94, _size91);
            this->updates.resize(_size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              xfer += this->updates[_i95].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deletes.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            xfer += iprot->readListBegin(_etype99, _size96);
            this->deletes.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += iprot->readString(this->deletes[_i100]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deletes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTopicUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTopicUpdate");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.updates) {
    xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
      std::vector<TTopicItem> ::const_iterator _iter101;
      for (_iter101 = this->updates.begin(); _iter101 != this->updates.end(); ++_iter101)
      {
        xfer += (*_iter101).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deletes) {
    xfer += oprot->writeFieldBegin("deletes", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->deletes.size()));
      std::vector<std::string> ::const_iterator _iter102;
      for (_iter102 = this->deletes.begin(); _iter102 != this->deletes.end(); ++_iter102)
      {
        xfer += oprot->writeString((*_iter102));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTopicUpdate &a, TTopicUpdate &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.updates, b.updates);
  swap(a.deletes, b.deletes);
  swap(a.__isset, b.__isset);
}

TTopicUpdate::TTopicUpdate(const TTopicUpdate& other103) {
  type = other103.type;
  updates = other103.updates;
  deletes = other103.deletes;
  __isset = other103.__isset;
}
TTopicUpdate& TTopicUpdate::operator=(const TTopicUpdate& other104) {
  type = other104.type;
  updates = other104.updates;
  deletes = other104.deletes;
  __isset = other104.__isset;
  return *this;
}
void TTopicUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTopicUpdate(";
  out << "type=" << to_string(type);
  out << ", " << "updates="; (__isset.updates ? (out << to_string(updates)) : (out << "<null>"));
  out << ", " << "deletes="; (__isset.deletes ? (out << to_string(deletes)) : (out << "<null>"));
  out << ")";
}


TAgentPublishRequest::~TAgentPublishRequest() throw() {
}


void TAgentPublishRequest::__set_protocol_version(const TAgentServiceVersion::type val) {
  this->protocol_version = val;
}

void TAgentPublishRequest::__set_updates(const std::vector<TTopicUpdate> & val) {
  this->updates = val;
}

uint32_t TAgentPublishRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_updates = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->protocol_version = (TAgentServiceVersion::type)ecast105;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size106;
            ::apache::thrift::protocol::TType _etype109;
            xfer += iprot->readListBegin(_etype109, _size106);
            this->updates.resize(_size106);
            uint32_t _i110;
            for (_i110 = 0; _i110 < _size106; ++_i110)
            {
              xfer += this->updates[_i110].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updates)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAgentPublishRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAgentPublishRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
    std::vector<TTopicUpdate> ::const_iterator _iter111;
    for (_iter111 = this->updates.begin(); _iter111 != this->updates.end(); ++_iter111)
    {
      xfer += (*_iter111).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAgentPublishRequest &a, TAgentPublishRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.updates, b.updates);
}

TAgentPublishRequest::TAgentPublishRequest(const TAgentPublishRequest& other112) {
  protocol_version = other112.protocol_version;
  updates = other112.updates;
}
TAgentPublishRequest& TAgentPublishRequest::operator=(const TAgentPublishRequest& other113) {
  protocol_version = other113.protocol_version;
  updates = other113.updates;
  return *this;
}
void TAgentPublishRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAgentPublishRequest(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "updates=" << to_string(updates);
  out << ")";
}


TMiniLoadEtlTaskRequest::~TMiniLoadEtlTaskRequest() throw() {
}


void TMiniLoadEtlTaskRequest::__set_protocol_version(const TAgentServiceVersion::type val) {
  this->protocol_version = val;
}

void TMiniLoadEtlTaskRequest::__set_params(const  ::palo::TExecPlanFragmentParams& val) {
  this->params = val;
}

uint32_t TMiniLoadEtlTaskRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_params = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast114;
          xfer += iprot->readI32(ecast114);
          this->protocol_version = (TAgentServiceVersion::type)ecast114;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          isset_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_params)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlTaskRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMiniLoadEtlTaskRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlTaskRequest &a, TMiniLoadEtlTaskRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.params, b.params);
}

TMiniLoadEtlTaskRequest::TMiniLoadEtlTaskRequest(const TMiniLoadEtlTaskRequest& other115) {
  protocol_version = other115.protocol_version;
  params = other115.params;
}
TMiniLoadEtlTaskRequest& TMiniLoadEtlTaskRequest::operator=(const TMiniLoadEtlTaskRequest& other116) {
  protocol_version = other116.protocol_version;
  params = other116.params;
  return *this;
}
void TMiniLoadEtlTaskRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMiniLoadEtlTaskRequest(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "params=" << to_string(params);
  out << ")";
}


TMiniLoadEtlStatusRequest::~TMiniLoadEtlStatusRequest() throw() {
}


void TMiniLoadEtlStatusRequest::__set_protocol_version(const TAgentServiceVersion::type val) {
  this->protocol_version = val;
}

void TMiniLoadEtlStatusRequest::__set_mini_load_id(const  ::palo::TUniqueId& val) {
  this->mini_load_id = val;
}

uint32_t TMiniLoadEtlStatusRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_mini_load_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast117;
          xfer += iprot->readI32(ecast117);
          this->protocol_version = (TAgentServiceVersion::type)ecast117;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mini_load_id.read(iprot);
          isset_mini_load_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mini_load_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlStatusRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMiniLoadEtlStatusRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mini_load_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->mini_load_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlStatusRequest &a, TMiniLoadEtlStatusRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.mini_load_id, b.mini_load_id);
}

TMiniLoadEtlStatusRequest::TMiniLoadEtlStatusRequest(const TMiniLoadEtlStatusRequest& other118) {
  protocol_version = other118.protocol_version;
  mini_load_id = other118.mini_load_id;
}
TMiniLoadEtlStatusRequest& TMiniLoadEtlStatusRequest::operator=(const TMiniLoadEtlStatusRequest& other119) {
  protocol_version = other119.protocol_version;
  mini_load_id = other119.mini_load_id;
  return *this;
}
void TMiniLoadEtlStatusRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMiniLoadEtlStatusRequest(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "mini_load_id=" << to_string(mini_load_id);
  out << ")";
}


TMiniLoadEtlStatusResult::~TMiniLoadEtlStatusResult() throw() {
}


void TMiniLoadEtlStatusResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
}

void TMiniLoadEtlStatusResult::__set_etl_state(const  ::palo::TEtlState::type val) {
  this->etl_state = val;
}

void TMiniLoadEtlStatusResult::__set_file_map(const std::map<std::string, int64_t> & val) {
  this->file_map = val;
__isset.file_map = true;
}

void TMiniLoadEtlStatusResult::__set_counters(const std::map<std::string, std::string> & val) {
  this->counters = val;
__isset.counters = true;
}

void TMiniLoadEtlStatusResult::__set_tracking_url(const std::string& val) {
  this->tracking_url = val;
__isset.tracking_url = true;
}

uint32_t TMiniLoadEtlStatusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_etl_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast120;
          xfer += iprot->readI32(ecast120);
          this->etl_state = ( ::palo::TEtlState::type)ecast120;
          isset_etl_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->file_map.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _ktype122;
            ::apache::thrift::protocol::TType _vtype123;
            xfer += iprot->readMapBegin(_ktype122, _vtype123, _size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              std::string _key126;
              xfer += iprot->readString(_key126);
              int64_t& _val127 = this->file_map[_key126];
              xfer += iprot->readI64(_val127);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.file_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->counters.clear();
            uint32_t _size128;
            ::apache::thrift::protocol::TType _ktype129;
            ::apache::thrift::protocol::TType _vtype130;
            xfer += iprot->readMapBegin(_ktype129, _vtype130, _size128);
            uint32_t _i132;
            for (_i132 = 0; _i132 < _size128; ++_i132)
            {
              std::string _key133;
              xfer += iprot->readString(_key133);
              std::string& _val134 = this->counters[_key133];
              xfer += iprot->readString(_val134);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tracking_url);
          this->__isset.tracking_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_etl_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlStatusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMiniLoadEtlStatusResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("etl_state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->etl_state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_map) {
    xfer += oprot->writeFieldBegin("file_map", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->file_map.size()));
      std::map<std::string, int64_t> ::const_iterator _iter135;
      for (_iter135 = this->file_map.begin(); _iter135 != this->file_map.end(); ++_iter135)
      {
        xfer += oprot->writeString(_iter135->first);
        xfer += oprot->writeI64(_iter135->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counters) {
    xfer += oprot->writeFieldBegin("counters", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->counters.size()));
      std::map<std::string, std::string> ::const_iterator _iter136;
      for (_iter136 = this->counters.begin(); _iter136 != this->counters.end(); ++_iter136)
      {
        xfer += oprot->writeString(_iter136->first);
        xfer += oprot->writeString(_iter136->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracking_url) {
    xfer += oprot->writeFieldBegin("tracking_url", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tracking_url);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlStatusResult &a, TMiniLoadEtlStatusResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.etl_state, b.etl_state);
  swap(a.file_map, b.file_map);
  swap(a.counters, b.counters);
  swap(a.tracking_url, b.tracking_url);
  swap(a.__isset, b.__isset);
}

TMiniLoadEtlStatusResult::TMiniLoadEtlStatusResult(const TMiniLoadEtlStatusResult& other137) {
  status = other137.status;
  etl_state = other137.etl_state;
  file_map = other137.file_map;
  counters = other137.counters;
  tracking_url = other137.tracking_url;
  __isset = other137.__isset;
}
TMiniLoadEtlStatusResult& TMiniLoadEtlStatusResult::operator=(const TMiniLoadEtlStatusResult& other138) {
  status = other138.status;
  etl_state = other138.etl_state;
  file_map = other138.file_map;
  counters = other138.counters;
  tracking_url = other138.tracking_url;
  __isset = other138.__isset;
  return *this;
}
void TMiniLoadEtlStatusResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMiniLoadEtlStatusResult(";
  out << "status=" << to_string(status);
  out << ", " << "etl_state=" << to_string(etl_state);
  out << ", " << "file_map="; (__isset.file_map ? (out << to_string(file_map)) : (out << "<null>"));
  out << ", " << "counters="; (__isset.counters ? (out << to_string(counters)) : (out << "<null>"));
  out << ", " << "tracking_url="; (__isset.tracking_url ? (out << to_string(tracking_url)) : (out << "<null>"));
  out << ")";
}


TDeleteEtlFilesRequest::~TDeleteEtlFilesRequest() throw() {
}


void TDeleteEtlFilesRequest::__set_protocol_version(const TAgentServiceVersion::type val) {
  this->protocol_version = val;
}

void TDeleteEtlFilesRequest::__set_mini_load_id(const  ::palo::TUniqueId& val) {
  this->mini_load_id = val;
}

void TDeleteEtlFilesRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDeleteEtlFilesRequest::__set_label(const std::string& val) {
  this->label = val;
}

uint32_t TDeleteEtlFilesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_mini_load_id = false;
  bool isset_db_name = false;
  bool isset_label = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast139;
          xfer += iprot->readI32(ecast139);
          this->protocol_version = (TAgentServiceVersion::type)ecast139;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mini_load_id.read(iprot);
          isset_mini_load_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          isset_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mini_load_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDeleteEtlFilesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDeleteEtlFilesRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mini_load_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->mini_load_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->label);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDeleteEtlFilesRequest &a, TDeleteEtlFilesRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.mini_load_id, b.mini_load_id);
  swap(a.db_name, b.db_name);
  swap(a.label, b.label);
}

TDeleteEtlFilesRequest::TDeleteEtlFilesRequest(const TDeleteEtlFilesRequest& other140) {
  protocol_version = other140.protocol_version;
  mini_load_id = other140.mini_load_id;
  db_name = other140.db_name;
  label = other140.label;
}
TDeleteEtlFilesRequest& TDeleteEtlFilesRequest::operator=(const TDeleteEtlFilesRequest& other141) {
  protocol_version = other141.protocol_version;
  mini_load_id = other141.mini_load_id;
  db_name = other141.db_name;
  label = other141.label;
  return *this;
}
void TDeleteEtlFilesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDeleteEtlFilesRequest(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "mini_load_id=" << to_string(mini_load_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "label=" << to_string(label);
  out << ")";
}

} // namespace
