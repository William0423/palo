/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "PlanNodes_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTPlanNodeTypeValues[] = {
  TPlanNodeType::OLAP_SCAN_NODE,
  TPlanNodeType::MYSQL_SCAN_NODE,
  TPlanNodeType::CSV_SCAN_NODE,
  TPlanNodeType::SCHEMA_SCAN_NODE,
  TPlanNodeType::HASH_JOIN_NODE,
  TPlanNodeType::MERGE_JOIN_NODE,
  TPlanNodeType::AGGREGATION_NODE,
  TPlanNodeType::PRE_AGGREGATION_NODE,
  TPlanNodeType::SORT_NODE,
  TPlanNodeType::EXCHANGE_NODE,
  TPlanNodeType::MERGE_NODE,
  TPlanNodeType::SELECT_NODE,
  TPlanNodeType::CROSS_JOIN_NODE,
  TPlanNodeType::META_SCAN_NODE,
  TPlanNodeType::ANALYTIC_EVAL_NODE,
  TPlanNodeType::OLAP_REWRITE_NODE,
  TPlanNodeType::KUDU_SCAN_NODE,
  TPlanNodeType::BROKER_SCAN_NODE,
  TPlanNodeType::EMPTY_SET_NODE,
  TPlanNodeType::UNION_NODE
};
const char* _kTPlanNodeTypeNames[] = {
  "OLAP_SCAN_NODE",
  "MYSQL_SCAN_NODE",
  "CSV_SCAN_NODE",
  "SCHEMA_SCAN_NODE",
  "HASH_JOIN_NODE",
  "MERGE_JOIN_NODE",
  "AGGREGATION_NODE",
  "PRE_AGGREGATION_NODE",
  "SORT_NODE",
  "EXCHANGE_NODE",
  "MERGE_NODE",
  "SELECT_NODE",
  "CROSS_JOIN_NODE",
  "META_SCAN_NODE",
  "ANALYTIC_EVAL_NODE",
  "OLAP_REWRITE_NODE",
  "KUDU_SCAN_NODE",
  "BROKER_SCAN_NODE",
  "EMPTY_SET_NODE",
  "UNION_NODE"
};
const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kTPlanNodeTypeValues, _kTPlanNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExecNodePhaseValues[] = {
  TExecNodePhase::PREPARE,
  TExecNodePhase::OPEN,
  TExecNodePhase::GETNEXT,
  TExecNodePhase::CLOSE,
  TExecNodePhase::INVALID
};
const char* _kTExecNodePhaseNames[] = {
  "PREPARE",
  "OPEN",
  "GETNEXT",
  "CLOSE",
  "INVALID"
};
const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTExecNodePhaseValues, _kTExecNodePhaseNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDebugActionValues[] = {
  TDebugAction::WAIT,
  TDebugAction::FAIL
};
const char* _kTDebugActionNames[] = {
  "WAIT",
  "FAIL"
};
const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTDebugActionValues, _kTDebugActionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFileFormatTypeValues[] = {
  TFileFormatType::FORMAT_CSV_PLAIN,
  TFileFormatType::FORMAT_CSV_GZ,
  TFileFormatType::FORMAT_CSV_LZO,
  TFileFormatType::FORMAT_CSV_BZ2,
  TFileFormatType::FORMAT_CSV_LZ4FRAME,
  TFileFormatType::FORMAT_CSV_LZOP
};
const char* _kTFileFormatTypeNames[] = {
  "FORMAT_CSV_PLAIN",
  "FORMAT_CSV_GZ",
  "FORMAT_CSV_LZO",
  "FORMAT_CSV_BZ2",
  "FORMAT_CSV_LZ4FRAME",
  "FORMAT_CSV_LZOP"
};
const std::map<int, const char*> _TFileFormatType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTFileFormatTypeValues, _kTFileFormatTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTJoinOpValues[] = {
  TJoinOp::INNER_JOIN,
  TJoinOp::LEFT_OUTER_JOIN,
  TJoinOp::LEFT_SEMI_JOIN,
  TJoinOp::RIGHT_OUTER_JOIN,
  TJoinOp::FULL_OUTER_JOIN,
  TJoinOp::CROSS_JOIN,
  TJoinOp::MERGE_JOIN,
  TJoinOp::RIGHT_SEMI_JOIN,
  TJoinOp::LEFT_ANTI_JOIN,
  TJoinOp::RIGHT_ANTI_JOIN,
  TJoinOp::NULL_AWARE_LEFT_ANTI_JOIN
};
const char* _kTJoinOpNames[] = {
  "INNER_JOIN",
  "LEFT_OUTER_JOIN",
  "LEFT_SEMI_JOIN",
  "RIGHT_OUTER_JOIN",
  "FULL_OUTER_JOIN",
  "CROSS_JOIN",
  "MERGE_JOIN",
  "RIGHT_SEMI_JOIN",
  "LEFT_ANTI_JOIN",
  "RIGHT_ANTI_JOIN",
  "NULL_AWARE_LEFT_ANTI_JOIN"
};
const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kTJoinOpValues, _kTJoinOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAggregationOpValues[] = {
  TAggregationOp::INVALID,
  TAggregationOp::COUNT,
  TAggregationOp::MAX,
  TAggregationOp::DISTINCT_PC,
  TAggregationOp::DISTINCT_PCSA,
  TAggregationOp::MIN,
  TAggregationOp::SUM,
  TAggregationOp::GROUP_CONCAT,
  TAggregationOp::HLL,
  TAggregationOp::COUNT_DISTINCT,
  TAggregationOp::SUM_DISTINCT,
  TAggregationOp::LEAD,
  TAggregationOp::FIRST_VALUE,
  TAggregationOp::LAST_VALUE,
  TAggregationOp::RANK,
  TAggregationOp::DENSE_RANK,
  TAggregationOp::ROW_NUMBER,
  TAggregationOp::LAG,
  TAggregationOp::HLL_C
};
const char* _kTAggregationOpNames[] = {
  "INVALID",
  "COUNT",
  "MAX",
  "DISTINCT_PC",
  "DISTINCT_PCSA",
  "MIN",
  "SUM",
  "GROUP_CONCAT",
  "HLL",
  "COUNT_DISTINCT",
  "SUM_DISTINCT",
  "LEAD",
  "FIRST_VALUE",
  "LAST_VALUE",
  "RANK",
  "DENSE_RANK",
  "ROW_NUMBER",
  "LAG",
  "HLL_C"
};
const std::map<int, const char*> _TAggregationOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kTAggregationOpValues, _kTAggregationOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAnalyticWindowTypeValues[] = {
  TAnalyticWindowType::RANGE,
  TAnalyticWindowType::ROWS
};
const char* _kTAnalyticWindowTypeNames[] = {
  "RANGE",
  "ROWS"
};
const std::map<int, const char*> _TAnalyticWindowType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTAnalyticWindowTypeValues, _kTAnalyticWindowTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAnalyticWindowBoundaryTypeValues[] = {
  TAnalyticWindowBoundaryType::CURRENT_ROW,
  TAnalyticWindowBoundaryType::PRECEDING,
  TAnalyticWindowBoundaryType::FOLLOWING
};
const char* _kTAnalyticWindowBoundaryTypeNames[] = {
  "CURRENT_ROW",
  "PRECEDING",
  "FOLLOWING"
};
const std::map<int, const char*> _TAnalyticWindowBoundaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTAnalyticWindowBoundaryTypeValues, _kTAnalyticWindowBoundaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TKeyRange::~TKeyRange() throw() {
}


void TKeyRange::__set_begin_key(const int64_t val) {
  this->begin_key = val;
}

void TKeyRange::__set_end_key(const int64_t val) {
  this->end_key = val;
}

void TKeyRange::__set_column_type(const  ::palo::TPrimitiveType::type val) {
  this->column_type = val;
}

void TKeyRange::__set_column_name(const std::string& val) {
  this->column_name = val;
}

uint32_t TKeyRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_begin_key = false;
  bool isset_end_key = false;
  bool isset_column_type = false;
  bool isset_column_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->begin_key);
          isset_begin_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_key);
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->column_type = ( ::palo::TPrimitiveType::type)ecast0;
          isset_column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_begin_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKeyRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKeyRange");

  xfer += oprot->writeFieldBegin("begin_key", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->begin_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->end_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->column_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKeyRange &a, TKeyRange &b) {
  using ::std::swap;
  swap(a.begin_key, b.begin_key);
  swap(a.end_key, b.end_key);
  swap(a.column_type, b.column_type);
  swap(a.column_name, b.column_name);
}

TKeyRange::TKeyRange(const TKeyRange& other1) {
  begin_key = other1.begin_key;
  end_key = other1.end_key;
  column_type = other1.column_type;
  column_name = other1.column_name;
}
TKeyRange& TKeyRange::operator=(const TKeyRange& other2) {
  begin_key = other2.begin_key;
  end_key = other2.end_key;
  column_type = other2.column_type;
  column_name = other2.column_name;
  return *this;
}
void TKeyRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKeyRange(";
  out << "begin_key=" << to_string(begin_key);
  out << ", " << "end_key=" << to_string(end_key);
  out << ", " << "column_type=" << to_string(column_type);
  out << ", " << "column_name=" << to_string(column_name);
  out << ")";
}


TPaloScanRange::~TPaloScanRange() throw() {
}


void TPaloScanRange::__set_hosts(const std::vector< ::palo::TNetworkAddress> & val) {
  this->hosts = val;
}

void TPaloScanRange::__set_schema_hash(const std::string& val) {
  this->schema_hash = val;
}

void TPaloScanRange::__set_version(const std::string& val) {
  this->version = val;
}

void TPaloScanRange::__set_version_hash(const std::string& val) {
  this->version_hash = val;
}

void TPaloScanRange::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TPaloScanRange::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TPaloScanRange::__set_partition_column_ranges(const std::vector<TKeyRange> & val) {
  this->partition_column_ranges = val;
__isset.partition_column_ranges = true;
}

void TPaloScanRange::__set_index_name(const std::string& val) {
  this->index_name = val;
__isset.index_name = true;
}

void TPaloScanRange::__set_table_name(const std::string& val) {
  this->table_name = val;
__isset.table_name = true;
}

uint32_t TPaloScanRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hosts = false;
  bool isset_schema_hash = false;
  bool isset_version = false;
  bool isset_version_hash = false;
  bool isset_tablet_id = false;
  bool isset_db_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hosts.clear();
            uint32_t _size3;
            ::apache::thrift::protocol::TType _etype6;
            xfer += iprot->readListBegin(_etype6, _size3);
            this->hosts.resize(_size3);
            uint32_t _i7;
            for (_i7 = 0; _i7 < _size3; ++_i7)
            {
              xfer += this->hosts[_i7].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_column_ranges.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->partition_column_ranges.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->partition_column_ranges[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_column_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hosts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPaloScanRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPaloScanRange");

  xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hosts.size()));
    std::vector< ::palo::TNetworkAddress> ::const_iterator _iter13;
    for (_iter13 = this->hosts.begin(); _iter13 != this->hosts.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_column_ranges) {
    xfer += oprot->writeFieldBegin("partition_column_ranges", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_column_ranges.size()));
      std::vector<TKeyRange> ::const_iterator _iter14;
      for (_iter14 = this->partition_column_ranges.begin(); _iter14 != this->partition_column_ranges.end(); ++_iter14)
      {
        xfer += (*_iter14).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_name) {
    xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->index_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_name) {
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->table_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPaloScanRange &a, TPaloScanRange &b) {
  using ::std::swap;
  swap(a.hosts, b.hosts);
  swap(a.schema_hash, b.schema_hash);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.tablet_id, b.tablet_id);
  swap(a.db_name, b.db_name);
  swap(a.partition_column_ranges, b.partition_column_ranges);
  swap(a.index_name, b.index_name);
  swap(a.table_name, b.table_name);
  swap(a.__isset, b.__isset);
}

TPaloScanRange::TPaloScanRange(const TPaloScanRange& other15) {
  hosts = other15.hosts;
  schema_hash = other15.schema_hash;
  version = other15.version;
  version_hash = other15.version_hash;
  tablet_id = other15.tablet_id;
  db_name = other15.db_name;
  partition_column_ranges = other15.partition_column_ranges;
  index_name = other15.index_name;
  table_name = other15.table_name;
  __isset = other15.__isset;
}
TPaloScanRange& TPaloScanRange::operator=(const TPaloScanRange& other16) {
  hosts = other16.hosts;
  schema_hash = other16.schema_hash;
  version = other16.version;
  version_hash = other16.version_hash;
  tablet_id = other16.tablet_id;
  db_name = other16.db_name;
  partition_column_ranges = other16.partition_column_ranges;
  index_name = other16.index_name;
  table_name = other16.table_name;
  __isset = other16.__isset;
  return *this;
}
void TPaloScanRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPaloScanRange(";
  out << "hosts=" << to_string(hosts);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "version=" << to_string(version);
  out << ", " << "version_hash=" << to_string(version_hash);
  out << ", " << "tablet_id=" << to_string(tablet_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "partition_column_ranges="; (__isset.partition_column_ranges ? (out << to_string(partition_column_ranges)) : (out << "<null>"));
  out << ", " << "index_name="; (__isset.index_name ? (out << to_string(index_name)) : (out << "<null>"));
  out << ", " << "table_name="; (__isset.table_name ? (out << to_string(table_name)) : (out << "<null>"));
  out << ")";
}


TBrokerRangeDesc::~TBrokerRangeDesc() throw() {
}


void TBrokerRangeDesc::__set_file_type(const  ::palo::TFileType::type val) {
  this->file_type = val;
}

void TBrokerRangeDesc::__set_format_type(const TFileFormatType::type val) {
  this->format_type = val;
}

void TBrokerRangeDesc::__set_splittable(const bool val) {
  this->splittable = val;
}

void TBrokerRangeDesc::__set_path(const std::string& val) {
  this->path = val;
}

void TBrokerRangeDesc::__set_start_offset(const int64_t val) {
  this->start_offset = val;
}

void TBrokerRangeDesc::__set_size(const int64_t val) {
  this->size = val;
}

uint32_t TBrokerRangeDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_type = false;
  bool isset_format_type = false;
  bool isset_splittable = false;
  bool isset_path = false;
  bool isset_start_offset = false;
  bool isset_size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->file_type = ( ::palo::TFileType::type)ecast17;
          isset_file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->format_type = (TFileFormatType::type)ecast18;
          isset_format_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->splittable);
          isset_splittable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_offset);
          isset_start_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_format_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_splittable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerRangeDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBrokerRangeDesc");

  xfer += oprot->writeFieldBegin("file_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->file_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("format_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->format_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splittable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->splittable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_offset", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->start_offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerRangeDesc &a, TBrokerRangeDesc &b) {
  using ::std::swap;
  swap(a.file_type, b.file_type);
  swap(a.format_type, b.format_type);
  swap(a.splittable, b.splittable);
  swap(a.path, b.path);
  swap(a.start_offset, b.start_offset);
  swap(a.size, b.size);
}

TBrokerRangeDesc::TBrokerRangeDesc(const TBrokerRangeDesc& other19) {
  file_type = other19.file_type;
  format_type = other19.format_type;
  splittable = other19.splittable;
  path = other19.path;
  start_offset = other19.start_offset;
  size = other19.size;
}
TBrokerRangeDesc& TBrokerRangeDesc::operator=(const TBrokerRangeDesc& other20) {
  file_type = other20.file_type;
  format_type = other20.format_type;
  splittable = other20.splittable;
  path = other20.path;
  start_offset = other20.start_offset;
  size = other20.size;
  return *this;
}
void TBrokerRangeDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBrokerRangeDesc(";
  out << "file_type=" << to_string(file_type);
  out << ", " << "format_type=" << to_string(format_type);
  out << ", " << "splittable=" << to_string(splittable);
  out << ", " << "path=" << to_string(path);
  out << ", " << "start_offset=" << to_string(start_offset);
  out << ", " << "size=" << to_string(size);
  out << ")";
}


TBrokerScanRangeParams::~TBrokerScanRangeParams() throw() {
}


void TBrokerScanRangeParams::__set_column_separator(const int8_t val) {
  this->column_separator = val;
}

void TBrokerScanRangeParams::__set_line_delimiter(const int8_t val) {
  this->line_delimiter = val;
}

void TBrokerScanRangeParams::__set_src_tuple_id(const  ::palo::TTupleId val) {
  this->src_tuple_id = val;
}

void TBrokerScanRangeParams::__set_src_slot_ids(const std::vector< ::palo::TSlotId> & val) {
  this->src_slot_ids = val;
}

void TBrokerScanRangeParams::__set_dest_tuple_id(const  ::palo::TTupleId val) {
  this->dest_tuple_id = val;
}

void TBrokerScanRangeParams::__set_expr_of_dest_slot(const std::map< ::palo::TSlotId,  ::palo::TExpr> & val) {
  this->expr_of_dest_slot = val;
__isset.expr_of_dest_slot = true;
}

void TBrokerScanRangeParams::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}

void TBrokerScanRangeParams::__set_partition_ids(const std::vector<int64_t> & val) {
  this->partition_ids = val;
__isset.partition_ids = true;
}

uint32_t TBrokerScanRangeParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_separator = false;
  bool isset_line_delimiter = false;
  bool isset_src_tuple_id = false;
  bool isset_src_slot_ids = false;
  bool isset_dest_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->column_separator);
          isset_column_separator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->line_delimiter);
          isset_line_delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->src_tuple_id);
          isset_src_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->src_slot_ids.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->src_slot_ids.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readI32(this->src_slot_ids[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          isset_src_slot_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_tuple_id);
          isset_dest_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->expr_of_dest_slot.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _ktype27;
            ::apache::thrift::protocol::TType _vtype28;
            xfer += iprot->readMapBegin(_ktype27, _vtype28, _size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
               ::palo::TSlotId _key31;
              xfer += iprot->readI32(_key31);
               ::palo::TExpr& _val32 = this->expr_of_dest_slot[_key31];
              xfer += _val32.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.expr_of_dest_slot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _ktype34;
            ::apache::thrift::protocol::TType _vtype35;
            xfer += iprot->readMapBegin(_ktype34, _vtype35, _size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              std::string _key38;
              xfer += iprot->readString(_key38);
              std::string& _val39 = this->properties[_key38];
              xfer += iprot->readString(_val39);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_ids.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->partition_ids.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += iprot->readI64(this->partition_ids[_i44]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_separator)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_line_delimiter)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_slot_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dest_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerScanRangeParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBrokerScanRangeParams");

  xfer += oprot->writeFieldBegin("column_separator", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->column_separator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delimiter", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->line_delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->src_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_slot_ids", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->src_slot_ids.size()));
    std::vector< ::palo::TSlotId> ::const_iterator _iter45;
    for (_iter45 = this->src_slot_ids.begin(); _iter45 != this->src_slot_ids.end(); ++_iter45)
    {
      xfer += oprot->writeI32((*_iter45));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dest_tuple_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->dest_tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expr_of_dest_slot) {
    xfer += oprot->writeFieldBegin("expr_of_dest_slot", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->expr_of_dest_slot.size()));
      std::map< ::palo::TSlotId,  ::palo::TExpr> ::const_iterator _iter46;
      for (_iter46 = this->expr_of_dest_slot.begin(); _iter46 != this->expr_of_dest_slot.end(); ++_iter46)
      {
        xfer += oprot->writeI32(_iter46->first);
        xfer += _iter46->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter47;
      for (_iter47 = this->properties.begin(); _iter47 != this->properties.end(); ++_iter47)
      {
        xfer += oprot->writeString(_iter47->first);
        xfer += oprot->writeString(_iter47->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_ids) {
    xfer += oprot->writeFieldBegin("partition_ids", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->partition_ids.size()));
      std::vector<int64_t> ::const_iterator _iter48;
      for (_iter48 = this->partition_ids.begin(); _iter48 != this->partition_ids.end(); ++_iter48)
      {
        xfer += oprot->writeI64((*_iter48));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerScanRangeParams &a, TBrokerScanRangeParams &b) {
  using ::std::swap;
  swap(a.column_separator, b.column_separator);
  swap(a.line_delimiter, b.line_delimiter);
  swap(a.src_tuple_id, b.src_tuple_id);
  swap(a.src_slot_ids, b.src_slot_ids);
  swap(a.dest_tuple_id, b.dest_tuple_id);
  swap(a.expr_of_dest_slot, b.expr_of_dest_slot);
  swap(a.properties, b.properties);
  swap(a.partition_ids, b.partition_ids);
  swap(a.__isset, b.__isset);
}

TBrokerScanRangeParams::TBrokerScanRangeParams(const TBrokerScanRangeParams& other49) {
  column_separator = other49.column_separator;
  line_delimiter = other49.line_delimiter;
  src_tuple_id = other49.src_tuple_id;
  src_slot_ids = other49.src_slot_ids;
  dest_tuple_id = other49.dest_tuple_id;
  expr_of_dest_slot = other49.expr_of_dest_slot;
  properties = other49.properties;
  partition_ids = other49.partition_ids;
  __isset = other49.__isset;
}
TBrokerScanRangeParams& TBrokerScanRangeParams::operator=(const TBrokerScanRangeParams& other50) {
  column_separator = other50.column_separator;
  line_delimiter = other50.line_delimiter;
  src_tuple_id = other50.src_tuple_id;
  src_slot_ids = other50.src_slot_ids;
  dest_tuple_id = other50.dest_tuple_id;
  expr_of_dest_slot = other50.expr_of_dest_slot;
  properties = other50.properties;
  partition_ids = other50.partition_ids;
  __isset = other50.__isset;
  return *this;
}
void TBrokerScanRangeParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBrokerScanRangeParams(";
  out << "column_separator=" << to_string(column_separator);
  out << ", " << "line_delimiter=" << to_string(line_delimiter);
  out << ", " << "src_tuple_id=" << to_string(src_tuple_id);
  out << ", " << "src_slot_ids=" << to_string(src_slot_ids);
  out << ", " << "dest_tuple_id=" << to_string(dest_tuple_id);
  out << ", " << "expr_of_dest_slot="; (__isset.expr_of_dest_slot ? (out << to_string(expr_of_dest_slot)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ", " << "partition_ids="; (__isset.partition_ids ? (out << to_string(partition_ids)) : (out << "<null>"));
  out << ")";
}


TBrokerScanRange::~TBrokerScanRange() throw() {
}


void TBrokerScanRange::__set_ranges(const std::vector<TBrokerRangeDesc> & val) {
  this->ranges = val;
}

void TBrokerScanRange::__set_params(const TBrokerScanRangeParams& val) {
  this->params = val;
}

void TBrokerScanRange::__set_broker_addresses(const std::vector< ::palo::TNetworkAddress> & val) {
  this->broker_addresses = val;
}

uint32_t TBrokerScanRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ranges = false;
  bool isset_params = false;
  bool isset_broker_addresses = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->ranges.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += this->ranges[_i55].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          isset_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->broker_addresses.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->broker_addresses.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->broker_addresses[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_broker_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ranges)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_params)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_broker_addresses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerScanRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBrokerScanRange");

  xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ranges.size()));
    std::vector<TBrokerRangeDesc> ::const_iterator _iter61;
    for (_iter61 = this->ranges.begin(); _iter61 != this->ranges.end(); ++_iter61)
    {
      xfer += (*_iter61).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("broker_addresses", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->broker_addresses.size()));
    std::vector< ::palo::TNetworkAddress> ::const_iterator _iter62;
    for (_iter62 = this->broker_addresses.begin(); _iter62 != this->broker_addresses.end(); ++_iter62)
    {
      xfer += (*_iter62).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerScanRange &a, TBrokerScanRange &b) {
  using ::std::swap;
  swap(a.ranges, b.ranges);
  swap(a.params, b.params);
  swap(a.broker_addresses, b.broker_addresses);
}

TBrokerScanRange::TBrokerScanRange(const TBrokerScanRange& other63) {
  ranges = other63.ranges;
  params = other63.params;
  broker_addresses = other63.broker_addresses;
}
TBrokerScanRange& TBrokerScanRange::operator=(const TBrokerScanRange& other64) {
  ranges = other64.ranges;
  params = other64.params;
  broker_addresses = other64.broker_addresses;
  return *this;
}
void TBrokerScanRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBrokerScanRange(";
  out << "ranges=" << to_string(ranges);
  out << ", " << "params=" << to_string(params);
  out << ", " << "broker_addresses=" << to_string(broker_addresses);
  out << ")";
}


TScanRange::~TScanRange() throw() {
}


void TScanRange::__set_palo_scan_range(const TPaloScanRange& val) {
  this->palo_scan_range = val;
__isset.palo_scan_range = true;
}

void TScanRange::__set_kudu_scan_token(const std::string& val) {
  this->kudu_scan_token = val;
__isset.kudu_scan_token = true;
}

void TScanRange::__set_broker_scan_range(const TBrokerScanRange& val) {
  this->broker_scan_range = val;
__isset.broker_scan_range = true;
}

uint32_t TScanRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->palo_scan_range.read(iprot);
          this->__isset.palo_scan_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->kudu_scan_token);
          this->__isset.kudu_scan_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->broker_scan_range.read(iprot);
          this->__isset.broker_scan_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScanRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScanRange");

  if (this->__isset.palo_scan_range) {
    xfer += oprot->writeFieldBegin("palo_scan_range", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->palo_scan_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_scan_token) {
    xfer += oprot->writeFieldBegin("kudu_scan_token", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->kudu_scan_token);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.broker_scan_range) {
    xfer += oprot->writeFieldBegin("broker_scan_range", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->broker_scan_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScanRange &a, TScanRange &b) {
  using ::std::swap;
  swap(a.palo_scan_range, b.palo_scan_range);
  swap(a.kudu_scan_token, b.kudu_scan_token);
  swap(a.broker_scan_range, b.broker_scan_range);
  swap(a.__isset, b.__isset);
}

TScanRange::TScanRange(const TScanRange& other65) {
  palo_scan_range = other65.palo_scan_range;
  kudu_scan_token = other65.kudu_scan_token;
  broker_scan_range = other65.broker_scan_range;
  __isset = other65.__isset;
}
TScanRange& TScanRange::operator=(const TScanRange& other66) {
  palo_scan_range = other66.palo_scan_range;
  kudu_scan_token = other66.kudu_scan_token;
  broker_scan_range = other66.broker_scan_range;
  __isset = other66.__isset;
  return *this;
}
void TScanRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScanRange(";
  out << "palo_scan_range="; (__isset.palo_scan_range ? (out << to_string(palo_scan_range)) : (out << "<null>"));
  out << ", " << "kudu_scan_token="; (__isset.kudu_scan_token ? (out << to_string(kudu_scan_token)) : (out << "<null>"));
  out << ", " << "broker_scan_range="; (__isset.broker_scan_range ? (out << to_string(broker_scan_range)) : (out << "<null>"));
  out << ")";
}


TMySQLScanNode::~TMySQLScanNode() throw() {
}


void TMySQLScanNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TMySQLScanNode::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TMySQLScanNode::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
}

void TMySQLScanNode::__set_filters(const std::vector<std::string> & val) {
  this->filters = val;
}

uint32_t TMySQLScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;
  bool isset_columns = false;
  bool isset_filters = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->columns.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readString(this->columns[_i71]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filters.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->filters.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readString(this->filters[_i76]);
            }
            xfer += iprot->readListEnd();
          }
          isset_filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filters)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMySQLScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMySQLScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter77;
    for (_iter77 = this->columns.begin(); _iter77 != this->columns.end(); ++_iter77)
    {
      xfer += oprot->writeString((*_iter77));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filters", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filters.size()));
    std::vector<std::string> ::const_iterator _iter78;
    for (_iter78 = this->filters.begin(); _iter78 != this->filters.end(); ++_iter78)
    {
      xfer += oprot->writeString((*_iter78));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMySQLScanNode &a, TMySQLScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.columns, b.columns);
  swap(a.filters, b.filters);
}

TMySQLScanNode::TMySQLScanNode(const TMySQLScanNode& other79) {
  tuple_id = other79.tuple_id;
  table_name = other79.table_name;
  columns = other79.columns;
  filters = other79.filters;
}
TMySQLScanNode& TMySQLScanNode::operator=(const TMySQLScanNode& other80) {
  tuple_id = other80.tuple_id;
  table_name = other80.table_name;
  columns = other80.columns;
  filters = other80.filters;
  return *this;
}
void TMySQLScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMySQLScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "filters=" << to_string(filters);
  out << ")";
}


TBrokerScanNode::~TBrokerScanNode() throw() {
}


void TBrokerScanNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TBrokerScanNode::__set_partition_exprs(const std::vector< ::palo::TExpr> & val) {
  this->partition_exprs = val;
__isset.partition_exprs = true;
}

void TBrokerScanNode::__set_partition_infos(const std::vector< ::palo::TRangePartition> & val) {
  this->partition_infos = val;
__isset.partition_infos = true;
}

uint32_t TBrokerScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_exprs.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readListBegin(_etype84, _size81);
            this->partition_exprs.resize(_size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              xfer += this->partition_exprs[_i85].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_infos.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->partition_infos.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += this->partition_infos[_i90].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBrokerScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBrokerScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_exprs) {
    xfer += oprot->writeFieldBegin("partition_exprs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter91;
      for (_iter91 = this->partition_exprs.begin(); _iter91 != this->partition_exprs.end(); ++_iter91)
      {
        xfer += (*_iter91).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_infos) {
    xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
      std::vector< ::palo::TRangePartition> ::const_iterator _iter92;
      for (_iter92 = this->partition_infos.begin(); _iter92 != this->partition_infos.end(); ++_iter92)
      {
        xfer += (*_iter92).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerScanNode &a, TBrokerScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.partition_exprs, b.partition_exprs);
  swap(a.partition_infos, b.partition_infos);
  swap(a.__isset, b.__isset);
}

TBrokerScanNode::TBrokerScanNode(const TBrokerScanNode& other93) {
  tuple_id = other93.tuple_id;
  partition_exprs = other93.partition_exprs;
  partition_infos = other93.partition_infos;
  __isset = other93.__isset;
}
TBrokerScanNode& TBrokerScanNode::operator=(const TBrokerScanNode& other94) {
  tuple_id = other94.tuple_id;
  partition_exprs = other94.partition_exprs;
  partition_infos = other94.partition_infos;
  __isset = other94.__isset;
  return *this;
}
void TBrokerScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBrokerScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "partition_exprs="; (__isset.partition_exprs ? (out << to_string(partition_exprs)) : (out << "<null>"));
  out << ", " << "partition_infos="; (__isset.partition_infos ? (out << to_string(partition_infos)) : (out << "<null>"));
  out << ")";
}


TMiniLoadEtlFunction::~TMiniLoadEtlFunction() throw() {
}


void TMiniLoadEtlFunction::__set_function_name(const std::string& val) {
  this->function_name = val;
}

void TMiniLoadEtlFunction::__set_param_column_index(const int32_t val) {
  this->param_column_index = val;
}

uint32_t TMiniLoadEtlFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_function_name = false;
  bool isset_param_column_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->param_column_index);
          isset_param_column_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_param_column_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMiniLoadEtlFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMiniLoadEtlFunction");

  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param_column_index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->param_column_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMiniLoadEtlFunction &a, TMiniLoadEtlFunction &b) {
  using ::std::swap;
  swap(a.function_name, b.function_name);
  swap(a.param_column_index, b.param_column_index);
}

TMiniLoadEtlFunction::TMiniLoadEtlFunction(const TMiniLoadEtlFunction& other95) {
  function_name = other95.function_name;
  param_column_index = other95.param_column_index;
}
TMiniLoadEtlFunction& TMiniLoadEtlFunction::operator=(const TMiniLoadEtlFunction& other96) {
  function_name = other96.function_name;
  param_column_index = other96.param_column_index;
  return *this;
}
void TMiniLoadEtlFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMiniLoadEtlFunction(";
  out << "function_name=" << to_string(function_name);
  out << ", " << "param_column_index=" << to_string(param_column_index);
  out << ")";
}


TCsvScanNode::~TCsvScanNode() throw() {
}


void TCsvScanNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TCsvScanNode::__set_file_paths(const std::vector<std::string> & val) {
  this->file_paths = val;
}

void TCsvScanNode::__set_column_separator(const std::string& val) {
  this->column_separator = val;
__isset.column_separator = true;
}

void TCsvScanNode::__set_line_delimiter(const std::string& val) {
  this->line_delimiter = val;
__isset.line_delimiter = true;
}

void TCsvScanNode::__set_column_type_mapping(const std::map<std::string,  ::palo::TColumnType> & val) {
  this->column_type_mapping = val;
__isset.column_type_mapping = true;
}

void TCsvScanNode::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
__isset.columns = true;
}

void TCsvScanNode::__set_unspecified_columns(const std::vector<std::string> & val) {
  this->unspecified_columns = val;
__isset.unspecified_columns = true;
}

void TCsvScanNode::__set_default_values(const std::vector<std::string> & val) {
  this->default_values = val;
__isset.default_values = true;
}

void TCsvScanNode::__set_max_filter_ratio(const double val) {
  this->max_filter_ratio = val;
__isset.max_filter_ratio = true;
}

void TCsvScanNode::__set_column_function_mapping(const std::map<std::string, TMiniLoadEtlFunction> & val) {
  this->column_function_mapping = val;
__isset.column_function_mapping = true;
}

uint32_t TCsvScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_file_paths = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->file_paths.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _etype100;
            xfer += iprot->readListBegin(_etype100, _size97);
            this->file_paths.resize(_size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              xfer += iprot->readString(this->file_paths[_i101]);
            }
            xfer += iprot->readListEnd();
          }
          isset_file_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_separator);
          this->__isset.column_separator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delimiter);
          this->__isset.line_delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->column_type_mapping.clear();
            uint32_t _size102;
            ::apache::thrift::protocol::TType _ktype103;
            ::apache::thrift::protocol::TType _vtype104;
            xfer += iprot->readMapBegin(_ktype103, _vtype104, _size102);
            uint32_t _i106;
            for (_i106 = 0; _i106 < _size102; ++_i106)
            {
              std::string _key107;
              xfer += iprot->readString(_key107);
               ::palo::TColumnType& _val108 = this->column_type_mapping[_key107];
              xfer += _val108.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.column_type_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _etype112;
            xfer += iprot->readListBegin(_etype112, _size109);
            this->columns.resize(_size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              xfer += iprot->readString(this->columns[_i113]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->unspecified_columns.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            xfer += iprot->readListBegin(_etype117, _size114);
            this->unspecified_columns.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += iprot->readString(this->unspecified_columns[_i118]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.unspecified_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->default_values.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->default_values.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += iprot->readString(this->default_values[_i123]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.default_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max_filter_ratio);
          this->__isset.max_filter_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->column_function_mapping.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              std::string _key129;
              xfer += iprot->readString(_key129);
              TMiniLoadEtlFunction& _val130 = this->column_function_mapping[_key129];
              xfer += _val130.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.column_function_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCsvScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCsvScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->file_paths.size()));
    std::vector<std::string> ::const_iterator _iter131;
    for (_iter131 = this->file_paths.begin(); _iter131 != this->file_paths.end(); ++_iter131)
    {
      xfer += oprot->writeString((*_iter131));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.column_separator) {
    xfer += oprot->writeFieldBegin("column_separator", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->column_separator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.line_delimiter) {
    xfer += oprot->writeFieldBegin("line_delimiter", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->line_delimiter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_type_mapping) {
    xfer += oprot->writeFieldBegin("column_type_mapping", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_type_mapping.size()));
      std::map<std::string,  ::palo::TColumnType> ::const_iterator _iter132;
      for (_iter132 = this->column_type_mapping.begin(); _iter132 != this->column_type_mapping.end(); ++_iter132)
      {
        xfer += oprot->writeString(_iter132->first);
        xfer += _iter132->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter133;
      for (_iter133 = this->columns.begin(); _iter133 != this->columns.end(); ++_iter133)
      {
        xfer += oprot->writeString((*_iter133));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unspecified_columns) {
    xfer += oprot->writeFieldBegin("unspecified_columns", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->unspecified_columns.size()));
      std::vector<std::string> ::const_iterator _iter134;
      for (_iter134 = this->unspecified_columns.begin(); _iter134 != this->unspecified_columns.end(); ++_iter134)
      {
        xfer += oprot->writeString((*_iter134));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_values) {
    xfer += oprot->writeFieldBegin("default_values", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->default_values.size()));
      std::vector<std::string> ::const_iterator _iter135;
      for (_iter135 = this->default_values.begin(); _iter135 != this->default_values.end(); ++_iter135)
      {
        xfer += oprot->writeString((*_iter135));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_filter_ratio) {
    xfer += oprot->writeFieldBegin("max_filter_ratio", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->max_filter_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_function_mapping) {
    xfer += oprot->writeFieldBegin("column_function_mapping", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_function_mapping.size()));
      std::map<std::string, TMiniLoadEtlFunction> ::const_iterator _iter136;
      for (_iter136 = this->column_function_mapping.begin(); _iter136 != this->column_function_mapping.end(); ++_iter136)
      {
        xfer += oprot->writeString(_iter136->first);
        xfer += _iter136->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCsvScanNode &a, TCsvScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.file_paths, b.file_paths);
  swap(a.column_separator, b.column_separator);
  swap(a.line_delimiter, b.line_delimiter);
  swap(a.column_type_mapping, b.column_type_mapping);
  swap(a.columns, b.columns);
  swap(a.unspecified_columns, b.unspecified_columns);
  swap(a.default_values, b.default_values);
  swap(a.max_filter_ratio, b.max_filter_ratio);
  swap(a.column_function_mapping, b.column_function_mapping);
  swap(a.__isset, b.__isset);
}

TCsvScanNode::TCsvScanNode(const TCsvScanNode& other137) {
  tuple_id = other137.tuple_id;
  file_paths = other137.file_paths;
  column_separator = other137.column_separator;
  line_delimiter = other137.line_delimiter;
  column_type_mapping = other137.column_type_mapping;
  columns = other137.columns;
  unspecified_columns = other137.unspecified_columns;
  default_values = other137.default_values;
  max_filter_ratio = other137.max_filter_ratio;
  column_function_mapping = other137.column_function_mapping;
  __isset = other137.__isset;
}
TCsvScanNode& TCsvScanNode::operator=(const TCsvScanNode& other138) {
  tuple_id = other138.tuple_id;
  file_paths = other138.file_paths;
  column_separator = other138.column_separator;
  line_delimiter = other138.line_delimiter;
  column_type_mapping = other138.column_type_mapping;
  columns = other138.columns;
  unspecified_columns = other138.unspecified_columns;
  default_values = other138.default_values;
  max_filter_ratio = other138.max_filter_ratio;
  column_function_mapping = other138.column_function_mapping;
  __isset = other138.__isset;
  return *this;
}
void TCsvScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCsvScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "file_paths=" << to_string(file_paths);
  out << ", " << "column_separator="; (__isset.column_separator ? (out << to_string(column_separator)) : (out << "<null>"));
  out << ", " << "line_delimiter="; (__isset.line_delimiter ? (out << to_string(line_delimiter)) : (out << "<null>"));
  out << ", " << "column_type_mapping="; (__isset.column_type_mapping ? (out << to_string(column_type_mapping)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "unspecified_columns="; (__isset.unspecified_columns ? (out << to_string(unspecified_columns)) : (out << "<null>"));
  out << ", " << "default_values="; (__isset.default_values ? (out << to_string(default_values)) : (out << "<null>"));
  out << ", " << "max_filter_ratio="; (__isset.max_filter_ratio ? (out << to_string(max_filter_ratio)) : (out << "<null>"));
  out << ", " << "column_function_mapping="; (__isset.column_function_mapping ? (out << to_string(column_function_mapping)) : (out << "<null>"));
  out << ")";
}


TSchemaScanNode::~TSchemaScanNode() throw() {
}


void TSchemaScanNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TSchemaScanNode::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TSchemaScanNode::__set_db(const std::string& val) {
  this->db = val;
__isset.db = true;
}

void TSchemaScanNode::__set_table(const std::string& val) {
  this->table = val;
__isset.table = true;
}

void TSchemaScanNode::__set_wild(const std::string& val) {
  this->wild = val;
__isset.wild = true;
}

void TSchemaScanNode::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

void TSchemaScanNode::__set_ip(const std::string& val) {
  this->ip = val;
__isset.ip = true;
}

void TSchemaScanNode::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void TSchemaScanNode::__set_thread_id(const int64_t val) {
  this->thread_id = val;
__isset.thread_id = true;
}

uint32_t TSchemaScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wild);
          this->__isset.wild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thread_id);
          this->__isset.thread_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSchemaScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSchemaScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table) {
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->table);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.wild) {
    xfer += oprot->writeFieldBegin("wild", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->wild);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip) {
    xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.thread_id) {
    xfer += oprot->writeFieldBegin("thread_id", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->thread_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSchemaScanNode &a, TSchemaScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.wild, b.wild);
  swap(a.user, b.user);
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.thread_id, b.thread_id);
  swap(a.__isset, b.__isset);
}

TSchemaScanNode::TSchemaScanNode(const TSchemaScanNode& other139) {
  tuple_id = other139.tuple_id;
  table_name = other139.table_name;
  db = other139.db;
  table = other139.table;
  wild = other139.wild;
  user = other139.user;
  ip = other139.ip;
  port = other139.port;
  thread_id = other139.thread_id;
  __isset = other139.__isset;
}
TSchemaScanNode& TSchemaScanNode::operator=(const TSchemaScanNode& other140) {
  tuple_id = other140.tuple_id;
  table_name = other140.table_name;
  db = other140.db;
  table = other140.table;
  wild = other140.wild;
  user = other140.user;
  ip = other140.ip;
  port = other140.port;
  thread_id = other140.thread_id;
  __isset = other140.__isset;
  return *this;
}
void TSchemaScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSchemaScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "db="; (__isset.db ? (out << to_string(db)) : (out << "<null>"));
  out << ", " << "table="; (__isset.table ? (out << to_string(table)) : (out << "<null>"));
  out << ", " << "wild="; (__isset.wild ? (out << to_string(wild)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ", " << "ip="; (__isset.ip ? (out << to_string(ip)) : (out << "<null>"));
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "thread_id="; (__isset.thread_id ? (out << to_string(thread_id)) : (out << "<null>"));
  out << ")";
}


TMetaScanNode::~TMetaScanNode() throw() {
}


void TMetaScanNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TMetaScanNode::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TMetaScanNode::__set_db(const std::string& val) {
  this->db = val;
__isset.db = true;
}

void TMetaScanNode::__set_table(const std::string& val) {
  this->table = val;
__isset.table = true;
}

void TMetaScanNode::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

uint32_t TMetaScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMetaScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMetaScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table) {
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->table);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMetaScanNode &a, TMetaScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

TMetaScanNode::TMetaScanNode(const TMetaScanNode& other141) {
  tuple_id = other141.tuple_id;
  table_name = other141.table_name;
  db = other141.db;
  table = other141.table;
  user = other141.user;
  __isset = other141.__isset;
}
TMetaScanNode& TMetaScanNode::operator=(const TMetaScanNode& other142) {
  tuple_id = other142.tuple_id;
  table_name = other142.table_name;
  db = other142.db;
  table = other142.table;
  user = other142.user;
  __isset = other142.__isset;
  return *this;
}
void TMetaScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMetaScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "db="; (__isset.db ? (out << to_string(db)) : (out << "<null>"));
  out << ", " << "table="; (__isset.table ? (out << to_string(table)) : (out << "<null>"));
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ")";
}


TOlapScanNode::~TOlapScanNode() throw() {
}


void TOlapScanNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TOlapScanNode::__set_key_column_name(const std::vector<std::string> & val) {
  this->key_column_name = val;
}

void TOlapScanNode::__set_key_column_type(const std::vector< ::palo::TPrimitiveType::type> & val) {
  this->key_column_type = val;
}

void TOlapScanNode::__set_is_preaggregation(const bool val) {
  this->is_preaggregation = val;
}

void TOlapScanNode::__set_sort_column(const std::string& val) {
  this->sort_column = val;
__isset.sort_column = true;
}

uint32_t TOlapScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_key_column_name = false;
  bool isset_key_column_type = false;
  bool isset_is_preaggregation = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_column_name.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->key_column_name.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += iprot->readString(this->key_column_name[_i147]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_column_type.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readListBegin(_etype151, _size148);
            this->key_column_type.resize(_size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              int32_t ecast153;
              xfer += iprot->readI32(ecast153);
              this->key_column_type[_i152] = ( ::palo::TPrimitiveType::type)ecast153;
            }
            xfer += iprot->readListEnd();
          }
          isset_key_column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_preaggregation);
          isset_is_preaggregation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sort_column);
          this->__isset.sort_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_column_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_preaggregation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOlapScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOlapScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_column_name", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key_column_name.size()));
    std::vector<std::string> ::const_iterator _iter154;
    for (_iter154 = this->key_column_name.begin(); _iter154 != this->key_column_name.end(); ++_iter154)
    {
      xfer += oprot->writeString((*_iter154));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_column_type", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->key_column_type.size()));
    std::vector< ::palo::TPrimitiveType::type> ::const_iterator _iter155;
    for (_iter155 = this->key_column_type.begin(); _iter155 != this->key_column_type.end(); ++_iter155)
    {
      xfer += oprot->writeI32((int32_t)(*_iter155));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_preaggregation", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_preaggregation);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_column) {
    xfer += oprot->writeFieldBegin("sort_column", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->sort_column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOlapScanNode &a, TOlapScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.key_column_name, b.key_column_name);
  swap(a.key_column_type, b.key_column_type);
  swap(a.is_preaggregation, b.is_preaggregation);
  swap(a.sort_column, b.sort_column);
  swap(a.__isset, b.__isset);
}

TOlapScanNode::TOlapScanNode(const TOlapScanNode& other156) {
  tuple_id = other156.tuple_id;
  key_column_name = other156.key_column_name;
  key_column_type = other156.key_column_type;
  is_preaggregation = other156.is_preaggregation;
  sort_column = other156.sort_column;
  __isset = other156.__isset;
}
TOlapScanNode& TOlapScanNode::operator=(const TOlapScanNode& other157) {
  tuple_id = other157.tuple_id;
  key_column_name = other157.key_column_name;
  key_column_type = other157.key_column_type;
  is_preaggregation = other157.is_preaggregation;
  sort_column = other157.sort_column;
  __isset = other157.__isset;
  return *this;
}
void TOlapScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOlapScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "key_column_name=" << to_string(key_column_name);
  out << ", " << "key_column_type=" << to_string(key_column_type);
  out << ", " << "is_preaggregation=" << to_string(is_preaggregation);
  out << ", " << "sort_column="; (__isset.sort_column ? (out << to_string(sort_column)) : (out << "<null>"));
  out << ")";
}


TEqJoinCondition::~TEqJoinCondition() throw() {
}


void TEqJoinCondition::__set_left(const  ::palo::TExpr& val) {
  this->left = val;
}

void TEqJoinCondition::__set_right(const  ::palo::TExpr& val) {
  this->right = val;
}

uint32_t TEqJoinCondition::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_left = false;
  bool isset_right = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->left.read(iprot);
          isset_left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->right.read(iprot);
          isset_right = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_left)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_right)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TEqJoinCondition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TEqJoinCondition");

  xfer += oprot->writeFieldBegin("left", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->left.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("right", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->right.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TEqJoinCondition &a, TEqJoinCondition &b) {
  using ::std::swap;
  swap(a.left, b.left);
  swap(a.right, b.right);
}

TEqJoinCondition::TEqJoinCondition(const TEqJoinCondition& other158) {
  left = other158.left;
  right = other158.right;
}
TEqJoinCondition& TEqJoinCondition::operator=(const TEqJoinCondition& other159) {
  left = other159.left;
  right = other159.right;
  return *this;
}
void TEqJoinCondition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TEqJoinCondition(";
  out << "left=" << to_string(left);
  out << ", " << "right=" << to_string(right);
  out << ")";
}


THashJoinNode::~THashJoinNode() throw() {
}


void THashJoinNode::__set_join_op(const TJoinOp::type val) {
  this->join_op = val;
}

void THashJoinNode::__set_eq_join_conjuncts(const std::vector<TEqJoinCondition> & val) {
  this->eq_join_conjuncts = val;
}

void THashJoinNode::__set_other_join_conjuncts(const std::vector< ::palo::TExpr> & val) {
  this->other_join_conjuncts = val;
__isset.other_join_conjuncts = true;
}

void THashJoinNode::__set_is_push_down(const bool val) {
  this->is_push_down = val;
__isset.is_push_down = true;
}

void THashJoinNode::__set_add_probe_filters(const bool val) {
  this->add_probe_filters = val;
__isset.add_probe_filters = true;
}

uint32_t THashJoinNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_join_op = false;
  bool isset_eq_join_conjuncts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast160;
          xfer += iprot->readI32(ecast160);
          this->join_op = (TJoinOp::type)ecast160;
          isset_join_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eq_join_conjuncts.clear();
            uint32_t _size161;
            ::apache::thrift::protocol::TType _etype164;
            xfer += iprot->readListBegin(_etype164, _size161);
            this->eq_join_conjuncts.resize(_size161);
            uint32_t _i165;
            for (_i165 = 0; _i165 < _size161; ++_i165)
            {
              xfer += this->eq_join_conjuncts[_i165].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_eq_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->other_join_conjuncts.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readListBegin(_etype169, _size166);
            this->other_join_conjuncts.resize(_size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              xfer += this->other_join_conjuncts[_i170].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.other_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_push_down);
          this->__isset.is_push_down = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->add_probe_filters);
          this->__isset.add_probe_filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_join_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eq_join_conjuncts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THashJoinNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THashJoinNode");

  xfer += oprot->writeFieldBegin("join_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->join_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eq_join_conjuncts", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->eq_join_conjuncts.size()));
    std::vector<TEqJoinCondition> ::const_iterator _iter171;
    for (_iter171 = this->eq_join_conjuncts.begin(); _iter171 != this->eq_join_conjuncts.end(); ++_iter171)
    {
      xfer += (*_iter171).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_join_conjuncts) {
    xfer += oprot->writeFieldBegin("other_join_conjuncts", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_join_conjuncts.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter172;
      for (_iter172 = this->other_join_conjuncts.begin(); _iter172 != this->other_join_conjuncts.end(); ++_iter172)
      {
        xfer += (*_iter172).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_push_down) {
    xfer += oprot->writeFieldBegin("is_push_down", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_push_down);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.add_probe_filters) {
    xfer += oprot->writeFieldBegin("add_probe_filters", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->add_probe_filters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THashJoinNode &a, THashJoinNode &b) {
  using ::std::swap;
  swap(a.join_op, b.join_op);
  swap(a.eq_join_conjuncts, b.eq_join_conjuncts);
  swap(a.other_join_conjuncts, b.other_join_conjuncts);
  swap(a.is_push_down, b.is_push_down);
  swap(a.add_probe_filters, b.add_probe_filters);
  swap(a.__isset, b.__isset);
}

THashJoinNode::THashJoinNode(const THashJoinNode& other173) {
  join_op = other173.join_op;
  eq_join_conjuncts = other173.eq_join_conjuncts;
  other_join_conjuncts = other173.other_join_conjuncts;
  is_push_down = other173.is_push_down;
  add_probe_filters = other173.add_probe_filters;
  __isset = other173.__isset;
}
THashJoinNode& THashJoinNode::operator=(const THashJoinNode& other174) {
  join_op = other174.join_op;
  eq_join_conjuncts = other174.eq_join_conjuncts;
  other_join_conjuncts = other174.other_join_conjuncts;
  is_push_down = other174.is_push_down;
  add_probe_filters = other174.add_probe_filters;
  __isset = other174.__isset;
  return *this;
}
void THashJoinNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THashJoinNode(";
  out << "join_op=" << to_string(join_op);
  out << ", " << "eq_join_conjuncts=" << to_string(eq_join_conjuncts);
  out << ", " << "other_join_conjuncts="; (__isset.other_join_conjuncts ? (out << to_string(other_join_conjuncts)) : (out << "<null>"));
  out << ", " << "is_push_down="; (__isset.is_push_down ? (out << to_string(is_push_down)) : (out << "<null>"));
  out << ", " << "add_probe_filters="; (__isset.add_probe_filters ? (out << to_string(add_probe_filters)) : (out << "<null>"));
  out << ")";
}


TMergeJoinNode::~TMergeJoinNode() throw() {
}


void TMergeJoinNode::__set_cmp_conjuncts(const std::vector<TEqJoinCondition> & val) {
  this->cmp_conjuncts = val;
}

void TMergeJoinNode::__set_other_join_conjuncts(const std::vector< ::palo::TExpr> & val) {
  this->other_join_conjuncts = val;
__isset.other_join_conjuncts = true;
}

uint32_t TMergeJoinNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cmp_conjuncts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmp_conjuncts.clear();
            uint32_t _size175;
            ::apache::thrift::protocol::TType _etype178;
            xfer += iprot->readListBegin(_etype178, _size175);
            this->cmp_conjuncts.resize(_size175);
            uint32_t _i179;
            for (_i179 = 0; _i179 < _size175; ++_i179)
            {
              xfer += this->cmp_conjuncts[_i179].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cmp_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->other_join_conjuncts.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->other_join_conjuncts.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += this->other_join_conjuncts[_i184].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.other_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cmp_conjuncts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMergeJoinNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMergeJoinNode");

  xfer += oprot->writeFieldBegin("cmp_conjuncts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cmp_conjuncts.size()));
    std::vector<TEqJoinCondition> ::const_iterator _iter185;
    for (_iter185 = this->cmp_conjuncts.begin(); _iter185 != this->cmp_conjuncts.end(); ++_iter185)
    {
      xfer += (*_iter185).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_join_conjuncts) {
    xfer += oprot->writeFieldBegin("other_join_conjuncts", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_join_conjuncts.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter186;
      for (_iter186 = this->other_join_conjuncts.begin(); _iter186 != this->other_join_conjuncts.end(); ++_iter186)
      {
        xfer += (*_iter186).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMergeJoinNode &a, TMergeJoinNode &b) {
  using ::std::swap;
  swap(a.cmp_conjuncts, b.cmp_conjuncts);
  swap(a.other_join_conjuncts, b.other_join_conjuncts);
  swap(a.__isset, b.__isset);
}

TMergeJoinNode::TMergeJoinNode(const TMergeJoinNode& other187) {
  cmp_conjuncts = other187.cmp_conjuncts;
  other_join_conjuncts = other187.other_join_conjuncts;
  __isset = other187.__isset;
}
TMergeJoinNode& TMergeJoinNode::operator=(const TMergeJoinNode& other188) {
  cmp_conjuncts = other188.cmp_conjuncts;
  other_join_conjuncts = other188.other_join_conjuncts;
  __isset = other188.__isset;
  return *this;
}
void TMergeJoinNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMergeJoinNode(";
  out << "cmp_conjuncts=" << to_string(cmp_conjuncts);
  out << ", " << "other_join_conjuncts="; (__isset.other_join_conjuncts ? (out << to_string(other_join_conjuncts)) : (out << "<null>"));
  out << ")";
}


TAggregationNode::~TAggregationNode() throw() {
}


void TAggregationNode::__set_grouping_exprs(const std::vector< ::palo::TExpr> & val) {
  this->grouping_exprs = val;
__isset.grouping_exprs = true;
}

void TAggregationNode::__set_aggregate_functions(const std::vector< ::palo::TExpr> & val) {
  this->aggregate_functions = val;
}

void TAggregationNode::__set_intermediate_tuple_id(const  ::palo::TTupleId val) {
  this->intermediate_tuple_id = val;
}

void TAggregationNode::__set_output_tuple_id(const  ::palo::TTupleId val) {
  this->output_tuple_id = val;
}

void TAggregationNode::__set_need_finalize(const bool val) {
  this->need_finalize = val;
}

uint32_t TAggregationNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aggregate_functions = false;
  bool isset_intermediate_tuple_id = false;
  bool isset_output_tuple_id = false;
  bool isset_need_finalize = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->grouping_exprs.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->grouping_exprs.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += this->grouping_exprs[_i193].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.grouping_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregate_functions.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->aggregate_functions.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              xfer += this->aggregate_functions[_i198].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregate_functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->intermediate_tuple_id);
          isset_intermediate_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_finalize);
          isset_need_finalize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aggregate_functions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_intermediate_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_need_finalize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregationNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAggregationNode");

  if (this->__isset.grouping_exprs) {
    xfer += oprot->writeFieldBegin("grouping_exprs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->grouping_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter199;
      for (_iter199 = this->grouping_exprs.begin(); _iter199 != this->grouping_exprs.end(); ++_iter199)
      {
        xfer += (*_iter199).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("aggregate_functions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggregate_functions.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter200;
    for (_iter200 = this->aggregate_functions.begin(); _iter200 != this->aggregate_functions.end(); ++_iter200)
    {
      xfer += (*_iter200).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intermediate_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->intermediate_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("need_finalize", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->need_finalize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregationNode &a, TAggregationNode &b) {
  using ::std::swap;
  swap(a.grouping_exprs, b.grouping_exprs);
  swap(a.aggregate_functions, b.aggregate_functions);
  swap(a.intermediate_tuple_id, b.intermediate_tuple_id);
  swap(a.output_tuple_id, b.output_tuple_id);
  swap(a.need_finalize, b.need_finalize);
  swap(a.__isset, b.__isset);
}

TAggregationNode::TAggregationNode(const TAggregationNode& other201) {
  grouping_exprs = other201.grouping_exprs;
  aggregate_functions = other201.aggregate_functions;
  intermediate_tuple_id = other201.intermediate_tuple_id;
  output_tuple_id = other201.output_tuple_id;
  need_finalize = other201.need_finalize;
  __isset = other201.__isset;
}
TAggregationNode& TAggregationNode::operator=(const TAggregationNode& other202) {
  grouping_exprs = other202.grouping_exprs;
  aggregate_functions = other202.aggregate_functions;
  intermediate_tuple_id = other202.intermediate_tuple_id;
  output_tuple_id = other202.output_tuple_id;
  need_finalize = other202.need_finalize;
  __isset = other202.__isset;
  return *this;
}
void TAggregationNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregationNode(";
  out << "grouping_exprs="; (__isset.grouping_exprs ? (out << to_string(grouping_exprs)) : (out << "<null>"));
  out << ", " << "aggregate_functions=" << to_string(aggregate_functions);
  out << ", " << "intermediate_tuple_id=" << to_string(intermediate_tuple_id);
  out << ", " << "output_tuple_id=" << to_string(output_tuple_id);
  out << ", " << "need_finalize=" << to_string(need_finalize);
  out << ")";
}


TPreAggregationNode::~TPreAggregationNode() throw() {
}


void TPreAggregationNode::__set_group_exprs(const std::vector< ::palo::TExpr> & val) {
  this->group_exprs = val;
}

void TPreAggregationNode::__set_aggregate_exprs(const std::vector< ::palo::TExpr> & val) {
  this->aggregate_exprs = val;
}

uint32_t TPreAggregationNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_group_exprs = false;
  bool isset_aggregate_exprs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_exprs.clear();
            uint32_t _size203;
            ::apache::thrift::protocol::TType _etype206;
            xfer += iprot->readListBegin(_etype206, _size203);
            this->group_exprs.resize(_size203);
            uint32_t _i207;
            for (_i207 = 0; _i207 < _size203; ++_i207)
            {
              xfer += this->group_exprs[_i207].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_group_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregate_exprs.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _etype211;
            xfer += iprot->readListBegin(_etype211, _size208);
            this->aggregate_exprs.resize(_size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              xfer += this->aggregate_exprs[_i212].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregate_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_group_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregate_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPreAggregationNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPreAggregationNode");

  xfer += oprot->writeFieldBegin("group_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->group_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter213;
    for (_iter213 = this->group_exprs.begin(); _iter213 != this->group_exprs.end(); ++_iter213)
    {
      xfer += (*_iter213).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregate_exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggregate_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter214;
    for (_iter214 = this->aggregate_exprs.begin(); _iter214 != this->aggregate_exprs.end(); ++_iter214)
    {
      xfer += (*_iter214).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPreAggregationNode &a, TPreAggregationNode &b) {
  using ::std::swap;
  swap(a.group_exprs, b.group_exprs);
  swap(a.aggregate_exprs, b.aggregate_exprs);
}

TPreAggregationNode::TPreAggregationNode(const TPreAggregationNode& other215) {
  group_exprs = other215.group_exprs;
  aggregate_exprs = other215.aggregate_exprs;
}
TPreAggregationNode& TPreAggregationNode::operator=(const TPreAggregationNode& other216) {
  group_exprs = other216.group_exprs;
  aggregate_exprs = other216.aggregate_exprs;
  return *this;
}
void TPreAggregationNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPreAggregationNode(";
  out << "group_exprs=" << to_string(group_exprs);
  out << ", " << "aggregate_exprs=" << to_string(aggregate_exprs);
  out << ")";
}


TSortInfo::~TSortInfo() throw() {
}


void TSortInfo::__set_ordering_exprs(const std::vector< ::palo::TExpr> & val) {
  this->ordering_exprs = val;
}

void TSortInfo::__set_is_asc_order(const std::vector<bool> & val) {
  this->is_asc_order = val;
}

void TSortInfo::__set_nulls_first(const std::vector<bool> & val) {
  this->nulls_first = val;
}

void TSortInfo::__set_sort_tuple_slot_exprs(const std::vector< ::palo::TExpr> & val) {
  this->sort_tuple_slot_exprs = val;
__isset.sort_tuple_slot_exprs = true;
}

uint32_t TSortInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ordering_exprs = false;
  bool isset_is_asc_order = false;
  bool isset_nulls_first = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ordering_exprs.clear();
            uint32_t _size217;
            ::apache::thrift::protocol::TType _etype220;
            xfer += iprot->readListBegin(_etype220, _size217);
            this->ordering_exprs.resize(_size217);
            uint32_t _i221;
            for (_i221 = 0; _i221 < _size217; ++_i221)
            {
              xfer += this->ordering_exprs[_i221].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ordering_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_asc_order.clear();
            uint32_t _size222;
            ::apache::thrift::protocol::TType _etype225;
            xfer += iprot->readListBegin(_etype225, _size222);
            this->is_asc_order.resize(_size222);
            uint32_t _i226;
            for (_i226 = 0; _i226 < _size222; ++_i226)
            {
              xfer += iprot->readBool(this->is_asc_order[_i226]);
            }
            xfer += iprot->readListEnd();
          }
          isset_is_asc_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls_first.clear();
            uint32_t _size227;
            ::apache::thrift::protocol::TType _etype230;
            xfer += iprot->readListBegin(_etype230, _size227);
            this->nulls_first.resize(_size227);
            uint32_t _i231;
            for (_i231 = 0; _i231 < _size227; ++_i231)
            {
              xfer += iprot->readBool(this->nulls_first[_i231]);
            }
            xfer += iprot->readListEnd();
          }
          isset_nulls_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_tuple_slot_exprs.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->sort_tuple_slot_exprs.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236)
            {
              xfer += this->sort_tuple_slot_exprs[_i236].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_tuple_slot_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ordering_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_asc_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls_first)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSortInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSortInfo");

  xfer += oprot->writeFieldBegin("ordering_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ordering_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter237;
    for (_iter237 = this->ordering_exprs.begin(); _iter237 != this->ordering_exprs.end(); ++_iter237)
    {
      xfer += (*_iter237).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_asc_order", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_asc_order.size()));
    std::vector<bool> ::const_iterator _iter238;
    for (_iter238 = this->is_asc_order.begin(); _iter238 != this->is_asc_order.end(); ++_iter238)
    {
      xfer += oprot->writeBool((*_iter238));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls_first", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls_first.size()));
    std::vector<bool> ::const_iterator _iter239;
    for (_iter239 = this->nulls_first.begin(); _iter239 != this->nulls_first.end(); ++_iter239)
    {
      xfer += oprot->writeBool((*_iter239));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_tuple_slot_exprs) {
    xfer += oprot->writeFieldBegin("sort_tuple_slot_exprs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sort_tuple_slot_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter240;
      for (_iter240 = this->sort_tuple_slot_exprs.begin(); _iter240 != this->sort_tuple_slot_exprs.end(); ++_iter240)
      {
        xfer += (*_iter240).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSortInfo &a, TSortInfo &b) {
  using ::std::swap;
  swap(a.ordering_exprs, b.ordering_exprs);
  swap(a.is_asc_order, b.is_asc_order);
  swap(a.nulls_first, b.nulls_first);
  swap(a.sort_tuple_slot_exprs, b.sort_tuple_slot_exprs);
  swap(a.__isset, b.__isset);
}

TSortInfo::TSortInfo(const TSortInfo& other241) {
  ordering_exprs = other241.ordering_exprs;
  is_asc_order = other241.is_asc_order;
  nulls_first = other241.nulls_first;
  sort_tuple_slot_exprs = other241.sort_tuple_slot_exprs;
  __isset = other241.__isset;
}
TSortInfo& TSortInfo::operator=(const TSortInfo& other242) {
  ordering_exprs = other242.ordering_exprs;
  is_asc_order = other242.is_asc_order;
  nulls_first = other242.nulls_first;
  sort_tuple_slot_exprs = other242.sort_tuple_slot_exprs;
  __isset = other242.__isset;
  return *this;
}
void TSortInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSortInfo(";
  out << "ordering_exprs=" << to_string(ordering_exprs);
  out << ", " << "is_asc_order=" << to_string(is_asc_order);
  out << ", " << "nulls_first=" << to_string(nulls_first);
  out << ", " << "sort_tuple_slot_exprs="; (__isset.sort_tuple_slot_exprs ? (out << to_string(sort_tuple_slot_exprs)) : (out << "<null>"));
  out << ")";
}


TSortNode::~TSortNode() throw() {
}


void TSortNode::__set_sort_info(const TSortInfo& val) {
  this->sort_info = val;
}

void TSortNode::__set_use_top_n(const bool val) {
  this->use_top_n = val;
}

void TSortNode::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void TSortNode::__set_ordering_exprs(const std::vector< ::palo::TExpr> & val) {
  this->ordering_exprs = val;
__isset.ordering_exprs = true;
}

void TSortNode::__set_is_asc_order(const std::vector<bool> & val) {
  this->is_asc_order = val;
__isset.is_asc_order = true;
}

void TSortNode::__set_is_default_limit(const bool val) {
  this->is_default_limit = val;
__isset.is_default_limit = true;
}

void TSortNode::__set_nulls_first(const std::vector<bool> & val) {
  this->nulls_first = val;
__isset.nulls_first = true;
}

void TSortNode::__set_sort_tuple_slot_exprs(const std::vector< ::palo::TExpr> & val) {
  this->sort_tuple_slot_exprs = val;
__isset.sort_tuple_slot_exprs = true;
}

uint32_t TSortNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sort_info = false;
  bool isset_use_top_n = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_info.read(iprot);
          isset_sort_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_top_n);
          isset_use_top_n = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ordering_exprs.clear();
            uint32_t _size243;
            ::apache::thrift::protocol::TType _etype246;
            xfer += iprot->readListBegin(_etype246, _size243);
            this->ordering_exprs.resize(_size243);
            uint32_t _i247;
            for (_i247 = 0; _i247 < _size243; ++_i247)
            {
              xfer += this->ordering_exprs[_i247].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ordering_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_asc_order.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _etype251;
            xfer += iprot->readListBegin(_etype251, _size248);
            this->is_asc_order.resize(_size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              xfer += iprot->readBool(this->is_asc_order[_i252]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.is_asc_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_default_limit);
          this->__isset.is_default_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls_first.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _etype256;
            xfer += iprot->readListBegin(_etype256, _size253);
            this->nulls_first.resize(_size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              xfer += iprot->readBool(this->nulls_first[_i257]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nulls_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_tuple_slot_exprs.clear();
            uint32_t _size258;
            ::apache::thrift::protocol::TType _etype261;
            xfer += iprot->readListBegin(_etype261, _size258);
            this->sort_tuple_slot_exprs.resize(_size258);
            uint32_t _i262;
            for (_i262 = 0; _i262 < _size258; ++_i262)
            {
              xfer += this->sort_tuple_slot_exprs[_i262].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_tuple_slot_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sort_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_use_top_n)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSortNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSortNode");

  xfer += oprot->writeFieldBegin("sort_info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sort_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_top_n", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->use_top_n);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ordering_exprs) {
    xfer += oprot->writeFieldBegin("ordering_exprs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ordering_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter263;
      for (_iter263 = this->ordering_exprs.begin(); _iter263 != this->ordering_exprs.end(); ++_iter263)
      {
        xfer += (*_iter263).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_asc_order) {
    xfer += oprot->writeFieldBegin("is_asc_order", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_asc_order.size()));
      std::vector<bool> ::const_iterator _iter264;
      for (_iter264 = this->is_asc_order.begin(); _iter264 != this->is_asc_order.end(); ++_iter264)
      {
        xfer += oprot->writeBool((*_iter264));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_default_limit) {
    xfer += oprot->writeFieldBegin("is_default_limit", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_default_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nulls_first) {
    xfer += oprot->writeFieldBegin("nulls_first", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls_first.size()));
      std::vector<bool> ::const_iterator _iter265;
      for (_iter265 = this->nulls_first.begin(); _iter265 != this->nulls_first.end(); ++_iter265)
      {
        xfer += oprot->writeBool((*_iter265));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_tuple_slot_exprs) {
    xfer += oprot->writeFieldBegin("sort_tuple_slot_exprs", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sort_tuple_slot_exprs.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter266;
      for (_iter266 = this->sort_tuple_slot_exprs.begin(); _iter266 != this->sort_tuple_slot_exprs.end(); ++_iter266)
      {
        xfer += (*_iter266).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSortNode &a, TSortNode &b) {
  using ::std::swap;
  swap(a.sort_info, b.sort_info);
  swap(a.use_top_n, b.use_top_n);
  swap(a.offset, b.offset);
  swap(a.ordering_exprs, b.ordering_exprs);
  swap(a.is_asc_order, b.is_asc_order);
  swap(a.is_default_limit, b.is_default_limit);
  swap(a.nulls_first, b.nulls_first);
  swap(a.sort_tuple_slot_exprs, b.sort_tuple_slot_exprs);
  swap(a.__isset, b.__isset);
}

TSortNode::TSortNode(const TSortNode& other267) {
  sort_info = other267.sort_info;
  use_top_n = other267.use_top_n;
  offset = other267.offset;
  ordering_exprs = other267.ordering_exprs;
  is_asc_order = other267.is_asc_order;
  is_default_limit = other267.is_default_limit;
  nulls_first = other267.nulls_first;
  sort_tuple_slot_exprs = other267.sort_tuple_slot_exprs;
  __isset = other267.__isset;
}
TSortNode& TSortNode::operator=(const TSortNode& other268) {
  sort_info = other268.sort_info;
  use_top_n = other268.use_top_n;
  offset = other268.offset;
  ordering_exprs = other268.ordering_exprs;
  is_asc_order = other268.is_asc_order;
  is_default_limit = other268.is_default_limit;
  nulls_first = other268.nulls_first;
  sort_tuple_slot_exprs = other268.sort_tuple_slot_exprs;
  __isset = other268.__isset;
  return *this;
}
void TSortNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSortNode(";
  out << "sort_info=" << to_string(sort_info);
  out << ", " << "use_top_n=" << to_string(use_top_n);
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "ordering_exprs="; (__isset.ordering_exprs ? (out << to_string(ordering_exprs)) : (out << "<null>"));
  out << ", " << "is_asc_order="; (__isset.is_asc_order ? (out << to_string(is_asc_order)) : (out << "<null>"));
  out << ", " << "is_default_limit="; (__isset.is_default_limit ? (out << to_string(is_default_limit)) : (out << "<null>"));
  out << ", " << "nulls_first="; (__isset.nulls_first ? (out << to_string(nulls_first)) : (out << "<null>"));
  out << ", " << "sort_tuple_slot_exprs="; (__isset.sort_tuple_slot_exprs ? (out << to_string(sort_tuple_slot_exprs)) : (out << "<null>"));
  out << ")";
}


TAnalyticWindowBoundary::~TAnalyticWindowBoundary() throw() {
}


void TAnalyticWindowBoundary::__set_type(const TAnalyticWindowBoundaryType::type val) {
  this->type = val;
}

void TAnalyticWindowBoundary::__set_range_offset_predicate(const  ::palo::TExpr& val) {
  this->range_offset_predicate = val;
__isset.range_offset_predicate = true;
}

void TAnalyticWindowBoundary::__set_rows_offset_value(const int64_t val) {
  this->rows_offset_value = val;
__isset.rows_offset_value = true;
}

uint32_t TAnalyticWindowBoundary::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast269;
          xfer += iprot->readI32(ecast269);
          this->type = (TAnalyticWindowBoundaryType::type)ecast269;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range_offset_predicate.read(iprot);
          this->__isset.range_offset_predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_offset_value);
          this->__isset.rows_offset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAnalyticWindowBoundary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAnalyticWindowBoundary");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.range_offset_predicate) {
    xfer += oprot->writeFieldBegin("range_offset_predicate", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->range_offset_predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rows_offset_value) {
    xfer += oprot->writeFieldBegin("rows_offset_value", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->rows_offset_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAnalyticWindowBoundary &a, TAnalyticWindowBoundary &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.range_offset_predicate, b.range_offset_predicate);
  swap(a.rows_offset_value, b.rows_offset_value);
  swap(a.__isset, b.__isset);
}

TAnalyticWindowBoundary::TAnalyticWindowBoundary(const TAnalyticWindowBoundary& other270) {
  type = other270.type;
  range_offset_predicate = other270.range_offset_predicate;
  rows_offset_value = other270.rows_offset_value;
  __isset = other270.__isset;
}
TAnalyticWindowBoundary& TAnalyticWindowBoundary::operator=(const TAnalyticWindowBoundary& other271) {
  type = other271.type;
  range_offset_predicate = other271.range_offset_predicate;
  rows_offset_value = other271.rows_offset_value;
  __isset = other271.__isset;
  return *this;
}
void TAnalyticWindowBoundary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAnalyticWindowBoundary(";
  out << "type=" << to_string(type);
  out << ", " << "range_offset_predicate="; (__isset.range_offset_predicate ? (out << to_string(range_offset_predicate)) : (out << "<null>"));
  out << ", " << "rows_offset_value="; (__isset.rows_offset_value ? (out << to_string(rows_offset_value)) : (out << "<null>"));
  out << ")";
}


TAnalyticWindow::~TAnalyticWindow() throw() {
}


void TAnalyticWindow::__set_type(const TAnalyticWindowType::type val) {
  this->type = val;
}

void TAnalyticWindow::__set_window_start(const TAnalyticWindowBoundary& val) {
  this->window_start = val;
__isset.window_start = true;
}

void TAnalyticWindow::__set_window_end(const TAnalyticWindowBoundary& val) {
  this->window_end = val;
__isset.window_end = true;
}

uint32_t TAnalyticWindow::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast272;
          xfer += iprot->readI32(ecast272);
          this->type = (TAnalyticWindowType::type)ecast272;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window_start.read(iprot);
          this->__isset.window_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window_end.read(iprot);
          this->__isset.window_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAnalyticWindow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAnalyticWindow");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.window_start) {
    xfer += oprot->writeFieldBegin("window_start", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->window_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.window_end) {
    xfer += oprot->writeFieldBegin("window_end", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->window_end.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAnalyticWindow &a, TAnalyticWindow &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.window_start, b.window_start);
  swap(a.window_end, b.window_end);
  swap(a.__isset, b.__isset);
}

TAnalyticWindow::TAnalyticWindow(const TAnalyticWindow& other273) {
  type = other273.type;
  window_start = other273.window_start;
  window_end = other273.window_end;
  __isset = other273.__isset;
}
TAnalyticWindow& TAnalyticWindow::operator=(const TAnalyticWindow& other274) {
  type = other274.type;
  window_start = other274.window_start;
  window_end = other274.window_end;
  __isset = other274.__isset;
  return *this;
}
void TAnalyticWindow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAnalyticWindow(";
  out << "type=" << to_string(type);
  out << ", " << "window_start="; (__isset.window_start ? (out << to_string(window_start)) : (out << "<null>"));
  out << ", " << "window_end="; (__isset.window_end ? (out << to_string(window_end)) : (out << "<null>"));
  out << ")";
}


TAnalyticNode::~TAnalyticNode() throw() {
}


void TAnalyticNode::__set_partition_exprs(const std::vector< ::palo::TExpr> & val) {
  this->partition_exprs = val;
}

void TAnalyticNode::__set_order_by_exprs(const std::vector< ::palo::TExpr> & val) {
  this->order_by_exprs = val;
}

void TAnalyticNode::__set_analytic_functions(const std::vector< ::palo::TExpr> & val) {
  this->analytic_functions = val;
}

void TAnalyticNode::__set_window(const TAnalyticWindow& val) {
  this->window = val;
__isset.window = true;
}

void TAnalyticNode::__set_intermediate_tuple_id(const  ::palo::TTupleId val) {
  this->intermediate_tuple_id = val;
}

void TAnalyticNode::__set_output_tuple_id(const  ::palo::TTupleId val) {
  this->output_tuple_id = val;
}

void TAnalyticNode::__set_buffered_tuple_id(const  ::palo::TTupleId val) {
  this->buffered_tuple_id = val;
__isset.buffered_tuple_id = true;
}

void TAnalyticNode::__set_partition_by_eq(const  ::palo::TExpr& val) {
  this->partition_by_eq = val;
__isset.partition_by_eq = true;
}

void TAnalyticNode::__set_order_by_eq(const  ::palo::TExpr& val) {
  this->order_by_eq = val;
__isset.order_by_eq = true;
}

uint32_t TAnalyticNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_exprs = false;
  bool isset_order_by_exprs = false;
  bool isset_analytic_functions = false;
  bool isset_intermediate_tuple_id = false;
  bool isset_output_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_exprs.clear();
            uint32_t _size275;
            ::apache::thrift::protocol::TType _etype278;
            xfer += iprot->readListBegin(_etype278, _size275);
            this->partition_exprs.resize(_size275);
            uint32_t _i279;
            for (_i279 = 0; _i279 < _size275; ++_i279)
            {
              xfer += this->partition_exprs[_i279].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->order_by_exprs.clear();
            uint32_t _size280;
            ::apache::thrift::protocol::TType _etype283;
            xfer += iprot->readListBegin(_etype283, _size280);
            this->order_by_exprs.resize(_size280);
            uint32_t _i284;
            for (_i284 = 0; _i284 < _size280; ++_i284)
            {
              xfer += this->order_by_exprs[_i284].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_order_by_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->analytic_functions.clear();
            uint32_t _size285;
            ::apache::thrift::protocol::TType _etype288;
            xfer += iprot->readListBegin(_etype288, _size285);
            this->analytic_functions.resize(_size285);
            uint32_t _i289;
            for (_i289 = 0; _i289 < _size285; ++_i289)
            {
              xfer += this->analytic_functions[_i289].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_analytic_functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window.read(iprot);
          this->__isset.window = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->intermediate_tuple_id);
          isset_intermediate_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffered_tuple_id);
          this->__isset.buffered_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition_by_eq.read(iprot);
          this->__isset.partition_by_eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->order_by_eq.read(iprot);
          this->__isset.order_by_eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_order_by_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_analytic_functions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_intermediate_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAnalyticNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAnalyticNode");

  xfer += oprot->writeFieldBegin("partition_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter290;
    for (_iter290 = this->partition_exprs.begin(); _iter290 != this->partition_exprs.end(); ++_iter290)
    {
      xfer += (*_iter290).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order_by_exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->order_by_exprs.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter291;
    for (_iter291 = this->order_by_exprs.begin(); _iter291 != this->order_by_exprs.end(); ++_iter291)
    {
      xfer += (*_iter291).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("analytic_functions", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->analytic_functions.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter292;
    for (_iter292 = this->analytic_functions.begin(); _iter292 != this->analytic_functions.end(); ++_iter292)
    {
      xfer += (*_iter292).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.window) {
    xfer += oprot->writeFieldBegin("window", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->window.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("intermediate_tuple_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->intermediate_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.buffered_tuple_id) {
    xfer += oprot->writeFieldBegin("buffered_tuple_id", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->buffered_tuple_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_by_eq) {
    xfer += oprot->writeFieldBegin("partition_by_eq", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->partition_by_eq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order_by_eq) {
    xfer += oprot->writeFieldBegin("order_by_eq", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->order_by_eq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAnalyticNode &a, TAnalyticNode &b) {
  using ::std::swap;
  swap(a.partition_exprs, b.partition_exprs);
  swap(a.order_by_exprs, b.order_by_exprs);
  swap(a.analytic_functions, b.analytic_functions);
  swap(a.window, b.window);
  swap(a.intermediate_tuple_id, b.intermediate_tuple_id);
  swap(a.output_tuple_id, b.output_tuple_id);
  swap(a.buffered_tuple_id, b.buffered_tuple_id);
  swap(a.partition_by_eq, b.partition_by_eq);
  swap(a.order_by_eq, b.order_by_eq);
  swap(a.__isset, b.__isset);
}

TAnalyticNode::TAnalyticNode(const TAnalyticNode& other293) {
  partition_exprs = other293.partition_exprs;
  order_by_exprs = other293.order_by_exprs;
  analytic_functions = other293.analytic_functions;
  window = other293.window;
  intermediate_tuple_id = other293.intermediate_tuple_id;
  output_tuple_id = other293.output_tuple_id;
  buffered_tuple_id = other293.buffered_tuple_id;
  partition_by_eq = other293.partition_by_eq;
  order_by_eq = other293.order_by_eq;
  __isset = other293.__isset;
}
TAnalyticNode& TAnalyticNode::operator=(const TAnalyticNode& other294) {
  partition_exprs = other294.partition_exprs;
  order_by_exprs = other294.order_by_exprs;
  analytic_functions = other294.analytic_functions;
  window = other294.window;
  intermediate_tuple_id = other294.intermediate_tuple_id;
  output_tuple_id = other294.output_tuple_id;
  buffered_tuple_id = other294.buffered_tuple_id;
  partition_by_eq = other294.partition_by_eq;
  order_by_eq = other294.order_by_eq;
  __isset = other294.__isset;
  return *this;
}
void TAnalyticNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAnalyticNode(";
  out << "partition_exprs=" << to_string(partition_exprs);
  out << ", " << "order_by_exprs=" << to_string(order_by_exprs);
  out << ", " << "analytic_functions=" << to_string(analytic_functions);
  out << ", " << "window="; (__isset.window ? (out << to_string(window)) : (out << "<null>"));
  out << ", " << "intermediate_tuple_id=" << to_string(intermediate_tuple_id);
  out << ", " << "output_tuple_id=" << to_string(output_tuple_id);
  out << ", " << "buffered_tuple_id="; (__isset.buffered_tuple_id ? (out << to_string(buffered_tuple_id)) : (out << "<null>"));
  out << ", " << "partition_by_eq="; (__isset.partition_by_eq ? (out << to_string(partition_by_eq)) : (out << "<null>"));
  out << ", " << "order_by_eq="; (__isset.order_by_eq ? (out << to_string(order_by_eq)) : (out << "<null>"));
  out << ")";
}


TMergeNode::~TMergeNode() throw() {
}


void TMergeNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TMergeNode::__set_result_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
  this->result_expr_lists = val;
}

void TMergeNode::__set_const_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
  this->const_expr_lists = val;
}

uint32_t TMergeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_result_expr_lists = false;
  bool isset_const_expr_lists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_expr_lists.clear();
            uint32_t _size295;
            ::apache::thrift::protocol::TType _etype298;
            xfer += iprot->readListBegin(_etype298, _size295);
            this->result_expr_lists.resize(_size295);
            uint32_t _i299;
            for (_i299 = 0; _i299 < _size295; ++_i299)
            {
              {
                this->result_expr_lists[_i299].clear();
                uint32_t _size300;
                ::apache::thrift::protocol::TType _etype303;
                xfer += iprot->readListBegin(_etype303, _size300);
                this->result_expr_lists[_i299].resize(_size300);
                uint32_t _i304;
                for (_i304 = 0; _i304 < _size300; ++_i304)
                {
                  xfer += this->result_expr_lists[_i299][_i304].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_result_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->const_expr_lists.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _etype308;
            xfer += iprot->readListBegin(_etype308, _size305);
            this->const_expr_lists.resize(_size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              {
                this->const_expr_lists[_i309].clear();
                uint32_t _size310;
                ::apache::thrift::protocol::TType _etype313;
                xfer += iprot->readListBegin(_etype313, _size310);
                this->const_expr_lists[_i309].resize(_size310);
                uint32_t _i314;
                for (_i314 = 0; _i314 < _size310; ++_i314)
                {
                  xfer += this->const_expr_lists[_i309][_i314].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_const_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_result_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_const_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMergeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMergeNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_expr_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->result_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter315;
    for (_iter315 = this->result_expr_lists.begin(); _iter315 != this->result_expr_lists.end(); ++_iter315)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter315).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter316;
        for (_iter316 = (*_iter315).begin(); _iter316 != (*_iter315).end(); ++_iter316)
        {
          xfer += (*_iter316).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("const_expr_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->const_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter317;
    for (_iter317 = this->const_expr_lists.begin(); _iter317 != this->const_expr_lists.end(); ++_iter317)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter317).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter318;
        for (_iter318 = (*_iter317).begin(); _iter318 != (*_iter317).end(); ++_iter318)
        {
          xfer += (*_iter318).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMergeNode &a, TMergeNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.result_expr_lists, b.result_expr_lists);
  swap(a.const_expr_lists, b.const_expr_lists);
}

TMergeNode::TMergeNode(const TMergeNode& other319) {
  tuple_id = other319.tuple_id;
  result_expr_lists = other319.result_expr_lists;
  const_expr_lists = other319.const_expr_lists;
}
TMergeNode& TMergeNode::operator=(const TMergeNode& other320) {
  tuple_id = other320.tuple_id;
  result_expr_lists = other320.result_expr_lists;
  const_expr_lists = other320.const_expr_lists;
  return *this;
}
void TMergeNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMergeNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "result_expr_lists=" << to_string(result_expr_lists);
  out << ", " << "const_expr_lists=" << to_string(const_expr_lists);
  out << ")";
}


TUnionNode::~TUnionNode() throw() {
}


void TUnionNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

void TUnionNode::__set_result_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
  this->result_expr_lists = val;
}

void TUnionNode::__set_const_expr_lists(const std::vector<std::vector< ::palo::TExpr> > & val) {
  this->const_expr_lists = val;
}

void TUnionNode::__set_first_materialized_child_idx(const int64_t val) {
  this->first_materialized_child_idx = val;
}

uint32_t TUnionNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_result_expr_lists = false;
  bool isset_const_expr_lists = false;
  bool isset_first_materialized_child_idx = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_expr_lists.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->result_expr_lists.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              {
                this->result_expr_lists[_i325].clear();
                uint32_t _size326;
                ::apache::thrift::protocol::TType _etype329;
                xfer += iprot->readListBegin(_etype329, _size326);
                this->result_expr_lists[_i325].resize(_size326);
                uint32_t _i330;
                for (_i330 = 0; _i330 < _size326; ++_i330)
                {
                  xfer += this->result_expr_lists[_i325][_i330].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_result_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->const_expr_lists.clear();
            uint32_t _size331;
            ::apache::thrift::protocol::TType _etype334;
            xfer += iprot->readListBegin(_etype334, _size331);
            this->const_expr_lists.resize(_size331);
            uint32_t _i335;
            for (_i335 = 0; _i335 < _size331; ++_i335)
            {
              {
                this->const_expr_lists[_i335].clear();
                uint32_t _size336;
                ::apache::thrift::protocol::TType _etype339;
                xfer += iprot->readListBegin(_etype339, _size336);
                this->const_expr_lists[_i335].resize(_size336);
                uint32_t _i340;
                for (_i340 = 0; _i340 < _size336; ++_i340)
                {
                  xfer += this->const_expr_lists[_i335][_i340].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_const_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first_materialized_child_idx);
          isset_first_materialized_child_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_result_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_const_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_first_materialized_child_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUnionNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUnionNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_expr_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->result_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter341;
    for (_iter341 = this->result_expr_lists.begin(); _iter341 != this->result_expr_lists.end(); ++_iter341)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter341).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter342;
        for (_iter342 = (*_iter341).begin(); _iter342 != (*_iter341).end(); ++_iter342)
        {
          xfer += (*_iter342).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("const_expr_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->const_expr_lists.size()));
    std::vector<std::vector< ::palo::TExpr> > ::const_iterator _iter343;
    for (_iter343 = this->const_expr_lists.begin(); _iter343 != this->const_expr_lists.end(); ++_iter343)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter343).size()));
        std::vector< ::palo::TExpr> ::const_iterator _iter344;
        for (_iter344 = (*_iter343).begin(); _iter344 != (*_iter343).end(); ++_iter344)
        {
          xfer += (*_iter344).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first_materialized_child_idx", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->first_materialized_child_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUnionNode &a, TUnionNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.result_expr_lists, b.result_expr_lists);
  swap(a.const_expr_lists, b.const_expr_lists);
  swap(a.first_materialized_child_idx, b.first_materialized_child_idx);
}

TUnionNode::TUnionNode(const TUnionNode& other345) {
  tuple_id = other345.tuple_id;
  result_expr_lists = other345.result_expr_lists;
  const_expr_lists = other345.const_expr_lists;
  first_materialized_child_idx = other345.first_materialized_child_idx;
}
TUnionNode& TUnionNode::operator=(const TUnionNode& other346) {
  tuple_id = other346.tuple_id;
  result_expr_lists = other346.result_expr_lists;
  const_expr_lists = other346.const_expr_lists;
  first_materialized_child_idx = other346.first_materialized_child_idx;
  return *this;
}
void TUnionNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUnionNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "result_expr_lists=" << to_string(result_expr_lists);
  out << ", " << "const_expr_lists=" << to_string(const_expr_lists);
  out << ", " << "first_materialized_child_idx=" << to_string(first_materialized_child_idx);
  out << ")";
}


TExchangeNode::~TExchangeNode() throw() {
}


void TExchangeNode::__set_input_row_tuples(const std::vector< ::palo::TTupleId> & val) {
  this->input_row_tuples = val;
}

void TExchangeNode::__set_sort_info(const TSortInfo& val) {
  this->sort_info = val;
__isset.sort_info = true;
}

void TExchangeNode::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

uint32_t TExchangeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_input_row_tuples = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->input_row_tuples.clear();
            uint32_t _size347;
            ::apache::thrift::protocol::TType _etype350;
            xfer += iprot->readListBegin(_etype350, _size347);
            this->input_row_tuples.resize(_size347);
            uint32_t _i351;
            for (_i351 = 0; _i351 < _size347; ++_i351)
            {
              xfer += iprot->readI32(this->input_row_tuples[_i351]);
            }
            xfer += iprot->readListEnd();
          }
          isset_input_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_info.read(iprot);
          this->__isset.sort_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_input_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExchangeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExchangeNode");

  xfer += oprot->writeFieldBegin("input_row_tuples", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->input_row_tuples.size()));
    std::vector< ::palo::TTupleId> ::const_iterator _iter352;
    for (_iter352 = this->input_row_tuples.begin(); _iter352 != this->input_row_tuples.end(); ++_iter352)
    {
      xfer += oprot->writeI32((*_iter352));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_info) {
    xfer += oprot->writeFieldBegin("sort_info", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->sort_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExchangeNode &a, TExchangeNode &b) {
  using ::std::swap;
  swap(a.input_row_tuples, b.input_row_tuples);
  swap(a.sort_info, b.sort_info);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

TExchangeNode::TExchangeNode(const TExchangeNode& other353) {
  input_row_tuples = other353.input_row_tuples;
  sort_info = other353.sort_info;
  offset = other353.offset;
  __isset = other353.__isset;
}
TExchangeNode& TExchangeNode::operator=(const TExchangeNode& other354) {
  input_row_tuples = other354.input_row_tuples;
  sort_info = other354.sort_info;
  offset = other354.offset;
  __isset = other354.__isset;
  return *this;
}
void TExchangeNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExchangeNode(";
  out << "input_row_tuples=" << to_string(input_row_tuples);
  out << ", " << "sort_info="; (__isset.sort_info ? (out << to_string(sort_info)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ")";
}


TOlapRewriteNode::~TOlapRewriteNode() throw() {
}


void TOlapRewriteNode::__set_columns(const std::vector< ::palo::TExpr> & val) {
  this->columns = val;
}

void TOlapRewriteNode::__set_column_types(const std::vector< ::palo::TColumnType> & val) {
  this->column_types = val;
}

void TOlapRewriteNode::__set_output_tuple_id(const  ::palo::TTupleId val) {
  this->output_tuple_id = val;
}

uint32_t TOlapRewriteNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_column_types = false;
  bool isset_output_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size355;
            ::apache::thrift::protocol::TType _etype358;
            xfer += iprot->readListBegin(_etype358, _size355);
            this->columns.resize(_size355);
            uint32_t _i359;
            for (_i359 = 0; _i359 < _size355; ++_i359)
            {
              xfer += this->columns[_i359].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_types.clear();
            uint32_t _size360;
            ::apache::thrift::protocol::TType _etype363;
            xfer += iprot->readListBegin(_etype363, _size360);
            this->column_types.resize(_size360);
            uint32_t _i364;
            for (_i364 = 0; _i364 < _size360; ++_i364)
            {
              xfer += this->column_types[_i364].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_column_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOlapRewriteNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOlapRewriteNode");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::palo::TExpr> ::const_iterator _iter365;
    for (_iter365 = this->columns.begin(); _iter365 != this->columns.end(); ++_iter365)
    {
      xfer += (*_iter365).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_types.size()));
    std::vector< ::palo::TColumnType> ::const_iterator _iter366;
    for (_iter366 = this->column_types.begin(); _iter366 != this->column_types.end(); ++_iter366)
    {
      xfer += (*_iter366).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOlapRewriteNode &a, TOlapRewriteNode &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.column_types, b.column_types);
  swap(a.output_tuple_id, b.output_tuple_id);
}

TOlapRewriteNode::TOlapRewriteNode(const TOlapRewriteNode& other367) {
  columns = other367.columns;
  column_types = other367.column_types;
  output_tuple_id = other367.output_tuple_id;
}
TOlapRewriteNode& TOlapRewriteNode::operator=(const TOlapRewriteNode& other368) {
  columns = other368.columns;
  column_types = other368.column_types;
  output_tuple_id = other368.output_tuple_id;
  return *this;
}
void TOlapRewriteNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOlapRewriteNode(";
  out << "columns=" << to_string(columns);
  out << ", " << "column_types=" << to_string(column_types);
  out << ", " << "output_tuple_id=" << to_string(output_tuple_id);
  out << ")";
}


TKuduScanNode::~TKuduScanNode() throw() {
}


void TKuduScanNode::__set_tuple_id(const  ::palo::TTupleId val) {
  this->tuple_id = val;
}

uint32_t TKuduScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduScanNode &a, TKuduScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
}

TKuduScanNode::TKuduScanNode(const TKuduScanNode& other369) {
  tuple_id = other369.tuple_id;
}
TKuduScanNode& TKuduScanNode::operator=(const TKuduScanNode& other370) {
  tuple_id = other370.tuple_id;
  return *this;
}
void TKuduScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ")";
}


TPlanNode::~TPlanNode() throw() {
}


void TPlanNode::__set_node_id(const  ::palo::TPlanNodeId val) {
  this->node_id = val;
}

void TPlanNode::__set_node_type(const TPlanNodeType::type val) {
  this->node_type = val;
}

void TPlanNode::__set_num_children(const int32_t val) {
  this->num_children = val;
}

void TPlanNode::__set_limit(const int64_t val) {
  this->limit = val;
}

void TPlanNode::__set_row_tuples(const std::vector< ::palo::TTupleId> & val) {
  this->row_tuples = val;
}

void TPlanNode::__set_nullable_tuples(const std::vector<bool> & val) {
  this->nullable_tuples = val;
}

void TPlanNode::__set_conjuncts(const std::vector< ::palo::TExpr> & val) {
  this->conjuncts = val;
__isset.conjuncts = true;
}

void TPlanNode::__set_compact_data(const bool val) {
  this->compact_data = val;
}

void TPlanNode::__set_hash_join_node(const THashJoinNode& val) {
  this->hash_join_node = val;
__isset.hash_join_node = true;
}

void TPlanNode::__set_agg_node(const TAggregationNode& val) {
  this->agg_node = val;
__isset.agg_node = true;
}

void TPlanNode::__set_sort_node(const TSortNode& val) {
  this->sort_node = val;
__isset.sort_node = true;
}

void TPlanNode::__set_merge_node(const TMergeNode& val) {
  this->merge_node = val;
__isset.merge_node = true;
}

void TPlanNode::__set_exchange_node(const TExchangeNode& val) {
  this->exchange_node = val;
__isset.exchange_node = true;
}

void TPlanNode::__set_mysql_scan_node(const TMySQLScanNode& val) {
  this->mysql_scan_node = val;
__isset.mysql_scan_node = true;
}

void TPlanNode::__set_olap_scan_node(const TOlapScanNode& val) {
  this->olap_scan_node = val;
__isset.olap_scan_node = true;
}

void TPlanNode::__set_csv_scan_node(const TCsvScanNode& val) {
  this->csv_scan_node = val;
__isset.csv_scan_node = true;
}

void TPlanNode::__set_broker_scan_node(const TBrokerScanNode& val) {
  this->broker_scan_node = val;
__isset.broker_scan_node = true;
}

void TPlanNode::__set_pre_agg_node(const TPreAggregationNode& val) {
  this->pre_agg_node = val;
__isset.pre_agg_node = true;
}

void TPlanNode::__set_schema_scan_node(const TSchemaScanNode& val) {
  this->schema_scan_node = val;
__isset.schema_scan_node = true;
}

void TPlanNode::__set_merge_join_node(const TMergeJoinNode& val) {
  this->merge_join_node = val;
__isset.merge_join_node = true;
}

void TPlanNode::__set_meta_scan_node(const TMetaScanNode& val) {
  this->meta_scan_node = val;
__isset.meta_scan_node = true;
}

void TPlanNode::__set_analytic_node(const TAnalyticNode& val) {
  this->analytic_node = val;
__isset.analytic_node = true;
}

void TPlanNode::__set_olap_rewrite_node(const TOlapRewriteNode& val) {
  this->olap_rewrite_node = val;
__isset.olap_rewrite_node = true;
}

void TPlanNode::__set_kudu_scan_node(const TKuduScanNode& val) {
  this->kudu_scan_node = val;
__isset.kudu_scan_node = true;
}

void TPlanNode::__set_union_node(const TUnionNode& val) {
  this->union_node = val;
__isset.union_node = true;
}

uint32_t TPlanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_node_type = false;
  bool isset_num_children = false;
  bool isset_limit = false;
  bool isset_row_tuples = false;
  bool isset_nullable_tuples = false;
  bool isset_compact_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast371;
          xfer += iprot->readI32(ecast371);
          this->node_type = (TPlanNodeType::type)ecast371;
          isset_node_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          isset_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_tuples.clear();
            uint32_t _size372;
            ::apache::thrift::protocol::TType _etype375;
            xfer += iprot->readListBegin(_etype375, _size372);
            this->row_tuples.resize(_size372);
            uint32_t _i376;
            for (_i376 = 0; _i376 < _size372; ++_i376)
            {
              xfer += iprot->readI32(this->row_tuples[_i376]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nullable_tuples.clear();
            uint32_t _size377;
            ::apache::thrift::protocol::TType _etype380;
            xfer += iprot->readListBegin(_etype380, _size377);
            this->nullable_tuples.resize(_size377);
            uint32_t _i381;
            for (_i381 = 0; _i381 < _size377; ++_i381)
            {
              xfer += iprot->readBool(this->nullable_tuples[_i381]);
            }
            xfer += iprot->readListEnd();
          }
          isset_nullable_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->conjuncts.clear();
            uint32_t _size382;
            ::apache::thrift::protocol::TType _etype385;
            xfer += iprot->readListBegin(_etype385, _size382);
            this->conjuncts.resize(_size382);
            uint32_t _i386;
            for (_i386 = 0; _i386 < _size382; ++_i386)
            {
              xfer += this->conjuncts[_i386].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compact_data);
          isset_compact_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hash_join_node.read(iprot);
          this->__isset.hash_join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agg_node.read(iprot);
          this->__isset.agg_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_node.read(iprot);
          this->__isset.sort_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->merge_node.read(iprot);
          this->__isset.merge_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->exchange_node.read(iprot);
          this->__isset.exchange_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mysql_scan_node.read(iprot);
          this->__isset.mysql_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->olap_scan_node.read(iprot);
          this->__isset.olap_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->csv_scan_node.read(iprot);
          this->__isset.csv_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->broker_scan_node.read(iprot);
          this->__isset.broker_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pre_agg_node.read(iprot);
          this->__isset.pre_agg_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema_scan_node.read(iprot);
          this->__isset.schema_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->merge_join_node.read(iprot);
          this->__isset.merge_join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meta_scan_node.read(iprot);
          this->__isset.meta_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->analytic_node.read(iprot);
          this->__isset.analytic_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->olap_rewrite_node.read(iprot);
          this->__isset.olap_rewrite_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kudu_scan_node.read(iprot);
          this->__isset.kudu_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->union_node.read(iprot);
          this->__isset.union_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_node_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullable_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compact_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanNode");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->node_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_tuples", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->row_tuples.size()));
    std::vector< ::palo::TTupleId> ::const_iterator _iter387;
    for (_iter387 = this->row_tuples.begin(); _iter387 != this->row_tuples.end(); ++_iter387)
    {
      xfer += oprot->writeI32((*_iter387));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable_tuples", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nullable_tuples.size()));
    std::vector<bool> ::const_iterator _iter388;
    for (_iter388 = this->nullable_tuples.begin(); _iter388 != this->nullable_tuples.end(); ++_iter388)
    {
      xfer += oprot->writeBool((*_iter388));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.conjuncts) {
    xfer += oprot->writeFieldBegin("conjuncts", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->conjuncts.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter389;
      for (_iter389 = this->conjuncts.begin(); _iter389 != this->conjuncts.end(); ++_iter389)
      {
        xfer += (*_iter389).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("compact_data", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->compact_data);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hash_join_node) {
    xfer += oprot->writeFieldBegin("hash_join_node", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->hash_join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agg_node) {
    xfer += oprot->writeFieldBegin("agg_node", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->agg_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_node) {
    xfer += oprot->writeFieldBegin("sort_node", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->sort_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_node) {
    xfer += oprot->writeFieldBegin("merge_node", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->merge_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchange_node) {
    xfer += oprot->writeFieldBegin("exchange_node", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->exchange_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mysql_scan_node) {
    xfer += oprot->writeFieldBegin("mysql_scan_node", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->mysql_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.olap_scan_node) {
    xfer += oprot->writeFieldBegin("olap_scan_node", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->olap_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.csv_scan_node) {
    xfer += oprot->writeFieldBegin("csv_scan_node", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->csv_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.broker_scan_node) {
    xfer += oprot->writeFieldBegin("broker_scan_node", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->broker_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_agg_node) {
    xfer += oprot->writeFieldBegin("pre_agg_node", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->pre_agg_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schema_scan_node) {
    xfer += oprot->writeFieldBegin("schema_scan_node", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->schema_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_join_node) {
    xfer += oprot->writeFieldBegin("merge_join_node", ::apache::thrift::protocol::T_STRUCT, 23);
    xfer += this->merge_join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.meta_scan_node) {
    xfer += oprot->writeFieldBegin("meta_scan_node", ::apache::thrift::protocol::T_STRUCT, 24);
    xfer += this->meta_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.analytic_node) {
    xfer += oprot->writeFieldBegin("analytic_node", ::apache::thrift::protocol::T_STRUCT, 25);
    xfer += this->analytic_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.olap_rewrite_node) {
    xfer += oprot->writeFieldBegin("olap_rewrite_node", ::apache::thrift::protocol::T_STRUCT, 26);
    xfer += this->olap_rewrite_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_scan_node) {
    xfer += oprot->writeFieldBegin("kudu_scan_node", ::apache::thrift::protocol::T_STRUCT, 27);
    xfer += this->kudu_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.union_node) {
    xfer += oprot->writeFieldBegin("union_node", ::apache::thrift::protocol::T_STRUCT, 28);
    xfer += this->union_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanNode &a, TPlanNode &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.node_type, b.node_type);
  swap(a.num_children, b.num_children);
  swap(a.limit, b.limit);
  swap(a.row_tuples, b.row_tuples);
  swap(a.nullable_tuples, b.nullable_tuples);
  swap(a.conjuncts, b.conjuncts);
  swap(a.compact_data, b.compact_data);
  swap(a.hash_join_node, b.hash_join_node);
  swap(a.agg_node, b.agg_node);
  swap(a.sort_node, b.sort_node);
  swap(a.merge_node, b.merge_node);
  swap(a.exchange_node, b.exchange_node);
  swap(a.mysql_scan_node, b.mysql_scan_node);
  swap(a.olap_scan_node, b.olap_scan_node);
  swap(a.csv_scan_node, b.csv_scan_node);
  swap(a.broker_scan_node, b.broker_scan_node);
  swap(a.pre_agg_node, b.pre_agg_node);
  swap(a.schema_scan_node, b.schema_scan_node);
  swap(a.merge_join_node, b.merge_join_node);
  swap(a.meta_scan_node, b.meta_scan_node);
  swap(a.analytic_node, b.analytic_node);
  swap(a.olap_rewrite_node, b.olap_rewrite_node);
  swap(a.kudu_scan_node, b.kudu_scan_node);
  swap(a.union_node, b.union_node);
  swap(a.__isset, b.__isset);
}

TPlanNode::TPlanNode(const TPlanNode& other390) {
  node_id = other390.node_id;
  node_type = other390.node_type;
  num_children = other390.num_children;
  limit = other390.limit;
  row_tuples = other390.row_tuples;
  nullable_tuples = other390.nullable_tuples;
  conjuncts = other390.conjuncts;
  compact_data = other390.compact_data;
  hash_join_node = other390.hash_join_node;
  agg_node = other390.agg_node;
  sort_node = other390.sort_node;
  merge_node = other390.merge_node;
  exchange_node = other390.exchange_node;
  mysql_scan_node = other390.mysql_scan_node;
  olap_scan_node = other390.olap_scan_node;
  csv_scan_node = other390.csv_scan_node;
  broker_scan_node = other390.broker_scan_node;
  pre_agg_node = other390.pre_agg_node;
  schema_scan_node = other390.schema_scan_node;
  merge_join_node = other390.merge_join_node;
  meta_scan_node = other390.meta_scan_node;
  analytic_node = other390.analytic_node;
  olap_rewrite_node = other390.olap_rewrite_node;
  kudu_scan_node = other390.kudu_scan_node;
  union_node = other390.union_node;
  __isset = other390.__isset;
}
TPlanNode& TPlanNode::operator=(const TPlanNode& other391) {
  node_id = other391.node_id;
  node_type = other391.node_type;
  num_children = other391.num_children;
  limit = other391.limit;
  row_tuples = other391.row_tuples;
  nullable_tuples = other391.nullable_tuples;
  conjuncts = other391.conjuncts;
  compact_data = other391.compact_data;
  hash_join_node = other391.hash_join_node;
  agg_node = other391.agg_node;
  sort_node = other391.sort_node;
  merge_node = other391.merge_node;
  exchange_node = other391.exchange_node;
  mysql_scan_node = other391.mysql_scan_node;
  olap_scan_node = other391.olap_scan_node;
  csv_scan_node = other391.csv_scan_node;
  broker_scan_node = other391.broker_scan_node;
  pre_agg_node = other391.pre_agg_node;
  schema_scan_node = other391.schema_scan_node;
  merge_join_node = other391.merge_join_node;
  meta_scan_node = other391.meta_scan_node;
  analytic_node = other391.analytic_node;
  olap_rewrite_node = other391.olap_rewrite_node;
  kudu_scan_node = other391.kudu_scan_node;
  union_node = other391.union_node;
  __isset = other391.__isset;
  return *this;
}
void TPlanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanNode(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "node_type=" << to_string(node_type);
  out << ", " << "num_children=" << to_string(num_children);
  out << ", " << "limit=" << to_string(limit);
  out << ", " << "row_tuples=" << to_string(row_tuples);
  out << ", " << "nullable_tuples=" << to_string(nullable_tuples);
  out << ", " << "conjuncts="; (__isset.conjuncts ? (out << to_string(conjuncts)) : (out << "<null>"));
  out << ", " << "compact_data=" << to_string(compact_data);
  out << ", " << "hash_join_node="; (__isset.hash_join_node ? (out << to_string(hash_join_node)) : (out << "<null>"));
  out << ", " << "agg_node="; (__isset.agg_node ? (out << to_string(agg_node)) : (out << "<null>"));
  out << ", " << "sort_node="; (__isset.sort_node ? (out << to_string(sort_node)) : (out << "<null>"));
  out << ", " << "merge_node="; (__isset.merge_node ? (out << to_string(merge_node)) : (out << "<null>"));
  out << ", " << "exchange_node="; (__isset.exchange_node ? (out << to_string(exchange_node)) : (out << "<null>"));
  out << ", " << "mysql_scan_node="; (__isset.mysql_scan_node ? (out << to_string(mysql_scan_node)) : (out << "<null>"));
  out << ", " << "olap_scan_node="; (__isset.olap_scan_node ? (out << to_string(olap_scan_node)) : (out << "<null>"));
  out << ", " << "csv_scan_node="; (__isset.csv_scan_node ? (out << to_string(csv_scan_node)) : (out << "<null>"));
  out << ", " << "broker_scan_node="; (__isset.broker_scan_node ? (out << to_string(broker_scan_node)) : (out << "<null>"));
  out << ", " << "pre_agg_node="; (__isset.pre_agg_node ? (out << to_string(pre_agg_node)) : (out << "<null>"));
  out << ", " << "schema_scan_node="; (__isset.schema_scan_node ? (out << to_string(schema_scan_node)) : (out << "<null>"));
  out << ", " << "merge_join_node="; (__isset.merge_join_node ? (out << to_string(merge_join_node)) : (out << "<null>"));
  out << ", " << "meta_scan_node="; (__isset.meta_scan_node ? (out << to_string(meta_scan_node)) : (out << "<null>"));
  out << ", " << "analytic_node="; (__isset.analytic_node ? (out << to_string(analytic_node)) : (out << "<null>"));
  out << ", " << "olap_rewrite_node="; (__isset.olap_rewrite_node ? (out << to_string(olap_rewrite_node)) : (out << "<null>"));
  out << ", " << "kudu_scan_node="; (__isset.kudu_scan_node ? (out << to_string(kudu_scan_node)) : (out << "<null>"));
  out << ", " << "union_node="; (__isset.union_node ? (out << to_string(union_node)) : (out << "<null>"));
  out << ")";
}


TPlan::~TPlan() throw() {
}


void TPlan::__set_nodes(const std::vector<TPlanNode> & val) {
  this->nodes = val;
}

uint32_t TPlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size392;
            ::apache::thrift::protocol::TType _etype395;
            xfer += iprot->readListBegin(_etype395, _size392);
            this->nodes.resize(_size392);
            uint32_t _i396;
            for (_i396 = 0; _i396 < _size392; ++_i396)
            {
              xfer += this->nodes[_i396].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlan");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TPlanNode> ::const_iterator _iter397;
    for (_iter397 = this->nodes.begin(); _iter397 != this->nodes.end(); ++_iter397)
    {
      xfer += (*_iter397).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlan &a, TPlan &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

TPlan::TPlan(const TPlan& other398) {
  nodes = other398.nodes;
}
TPlan& TPlan::operator=(const TPlan& other399) {
  nodes = other399.nodes;
  return *this;
}
void TPlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlan(";
  out << "nodes=" << to_string(nodes);
  out << ")";
}

} // namespace
