/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Descriptors_TYPES_H
#define Descriptors_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Types_types.h"
#include "Exprs_types.h"


namespace palo {

struct THdfsFileFormat {
  enum type {
    TEXT = 0,
    LZO_TEXT = 1,
    RC_FILE = 2,
    SEQUENCE_FILE = 3,
    AVRO = 4,
    PARQUET = 5
  };
};

extern const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES;

struct TSchemaTableType {
  enum type {
    SCH_AUTHORS = 0,
    SCH_CHARSETS = 1,
    SCH_COLLATIONS = 2,
    SCH_COLLATION_CHARACTER_SET_APPLICABILITY = 3,
    SCH_COLUMNS = 4,
    SCH_COLUMN_PRIVILEGES = 5,
    SCH_CREATE_TABLE = 6,
    SCH_ENGINES = 7,
    SCH_EVENTS = 8,
    SCH_FILES = 9,
    SCH_GLOBAL_STATUS = 10,
    SCH_GLOBAL_VARIABLES = 11,
    SCH_KEY_COLUMN_USAGE = 12,
    SCH_OPEN_TABLES = 13,
    SCH_PARTITIONS = 14,
    SCH_PLUGINS = 15,
    SCH_PROCESSLIST = 16,
    SCH_PROFILES = 17,
    SCH_REFERENTIAL_CONSTRAINTS = 18,
    SCH_PROCEDURES = 19,
    SCH_SCHEMATA = 20,
    SCH_SCHEMA_PRIVILEGES = 21,
    SCH_SESSION_STATUS = 22,
    SCH_SESSION_VARIABLES = 23,
    SCH_STATISTICS = 24,
    SCH_STATUS = 25,
    SCH_TABLES = 26,
    SCH_TABLE_CONSTRAINTS = 27,
    SCH_TABLE_NAMES = 28,
    SCH_TABLE_PRIVILEGES = 29,
    SCH_TRIGGERS = 30,
    SCH_USER_PRIVILEGES = 31,
    SCH_VARIABLES = 32,
    SCH_VIEWS = 33,
    SCH_INVALID = 34
  };
};

extern const std::map<int, const char*> _TSchemaTableType_VALUES_TO_NAMES;

struct THdfsCompression {
  enum type {
    NONE = 0,
    DEFAULT = 1,
    GZIP = 2,
    DEFLATE = 3,
    BZIP2 = 4,
    SNAPPY = 5,
    SNAPPY_BLOCKED = 6
  };
};

extern const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES;

class TSlotDescriptor;

class TOlapTable;

class TMySQLTable;

class TKuduPartitionByHashParam;

class TKuduRangePartition;

class TKuduPartitionByRangeParam;

class TKuduPartitionParam;

class TKuduTable;

class TSchemaTable;

class TBrokerTable;

class TTableDescriptor;

class TTupleDescriptor;

class TDescriptorTable;


class TSlotDescriptor {
 public:

  TSlotDescriptor(const TSlotDescriptor&);
  TSlotDescriptor& operator=(const TSlotDescriptor&);
  TSlotDescriptor() : id(0), parent(0), columnPos(0), byteOffset(0), nullIndicatorByte(0), nullIndicatorBit(0), colName(), slotIdx(0), isMaterialized(0) {
  }

  virtual ~TSlotDescriptor() throw();
   ::palo::TSlotId id;
   ::palo::TTupleId parent;
   ::palo::TTypeDesc slotType;
  int32_t columnPos;
  int32_t byteOffset;
  int32_t nullIndicatorByte;
  int32_t nullIndicatorBit;
  std::string colName;
  int32_t slotIdx;
  bool isMaterialized;

  void __set_id(const  ::palo::TSlotId val);

  void __set_parent(const  ::palo::TTupleId val);

  void __set_slotType(const  ::palo::TTypeDesc& val);

  void __set_columnPos(const int32_t val);

  void __set_byteOffset(const int32_t val);

  void __set_nullIndicatorByte(const int32_t val);

  void __set_nullIndicatorBit(const int32_t val);

  void __set_colName(const std::string& val);

  void __set_slotIdx(const int32_t val);

  void __set_isMaterialized(const bool val);

  bool operator == (const TSlotDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(parent == rhs.parent))
      return false;
    if (!(slotType == rhs.slotType))
      return false;
    if (!(columnPos == rhs.columnPos))
      return false;
    if (!(byteOffset == rhs.byteOffset))
      return false;
    if (!(nullIndicatorByte == rhs.nullIndicatorByte))
      return false;
    if (!(nullIndicatorBit == rhs.nullIndicatorBit))
      return false;
    if (!(colName == rhs.colName))
      return false;
    if (!(slotIdx == rhs.slotIdx))
      return false;
    if (!(isMaterialized == rhs.isMaterialized))
      return false;
    return true;
  }
  bool operator != (const TSlotDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSlotDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSlotDescriptor &a, TSlotDescriptor &b);

inline std::ostream& operator<<(std::ostream& out, const TSlotDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


class TOlapTable {
 public:

  TOlapTable(const TOlapTable&);
  TOlapTable& operator=(const TOlapTable&);
  TOlapTable() : tableName() {
  }

  virtual ~TOlapTable() throw();
  std::string tableName;

  void __set_tableName(const std::string& val);

  bool operator == (const TOlapTable & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const TOlapTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOlapTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOlapTable &a, TOlapTable &b);

inline std::ostream& operator<<(std::ostream& out, const TOlapTable& obj)
{
  obj.printTo(out);
  return out;
}


class TMySQLTable {
 public:

  TMySQLTable(const TMySQLTable&);
  TMySQLTable& operator=(const TMySQLTable&);
  TMySQLTable() : host(), port(), user(), passwd(), db(), table() {
  }

  virtual ~TMySQLTable() throw();
  std::string host;
  std::string port;
  std::string user;
  std::string passwd;
  std::string db;
  std::string table;

  void __set_host(const std::string& val);

  void __set_port(const std::string& val);

  void __set_user(const std::string& val);

  void __set_passwd(const std::string& val);

  void __set_db(const std::string& val);

  void __set_table(const std::string& val);

  bool operator == (const TMySQLTable & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(db == rhs.db))
      return false;
    if (!(table == rhs.table))
      return false;
    return true;
  }
  bool operator != (const TMySQLTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMySQLTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMySQLTable &a, TMySQLTable &b);

inline std::ostream& operator<<(std::ostream& out, const TMySQLTable& obj)
{
  obj.printTo(out);
  return out;
}


class TKuduPartitionByHashParam {
 public:

  TKuduPartitionByHashParam(const TKuduPartitionByHashParam&);
  TKuduPartitionByHashParam& operator=(const TKuduPartitionByHashParam&);
  TKuduPartitionByHashParam() : num_partitions(0) {
  }

  virtual ~TKuduPartitionByHashParam() throw();
  std::vector<std::string>  columns;
  int32_t num_partitions;

  void __set_columns(const std::vector<std::string> & val);

  void __set_num_partitions(const int32_t val);

  bool operator == (const TKuduPartitionByHashParam & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (!(num_partitions == rhs.num_partitions))
      return false;
    return true;
  }
  bool operator != (const TKuduPartitionByHashParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduPartitionByHashParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduPartitionByHashParam &a, TKuduPartitionByHashParam &b);

inline std::ostream& operator<<(std::ostream& out, const TKuduPartitionByHashParam& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TKuduRangePartition__isset {
  _TKuduRangePartition__isset() : lower_bound_values(false), is_lower_bound_inclusive(false), upper_bound_values(false), is_upper_bound_inclusive(false) {}
  bool lower_bound_values :1;
  bool is_lower_bound_inclusive :1;
  bool upper_bound_values :1;
  bool is_upper_bound_inclusive :1;
} _TKuduRangePartition__isset;

class TKuduRangePartition {
 public:

  TKuduRangePartition(const TKuduRangePartition&);
  TKuduRangePartition& operator=(const TKuduRangePartition&);
  TKuduRangePartition() : is_lower_bound_inclusive(0), is_upper_bound_inclusive(0) {
  }

  virtual ~TKuduRangePartition() throw();
  std::vector< ::palo::TExpr>  lower_bound_values;
  bool is_lower_bound_inclusive;
  std::vector< ::palo::TExpr>  upper_bound_values;
  bool is_upper_bound_inclusive;

  _TKuduRangePartition__isset __isset;

  void __set_lower_bound_values(const std::vector< ::palo::TExpr> & val);

  void __set_is_lower_bound_inclusive(const bool val);

  void __set_upper_bound_values(const std::vector< ::palo::TExpr> & val);

  void __set_is_upper_bound_inclusive(const bool val);

  bool operator == (const TKuduRangePartition & rhs) const
  {
    if (__isset.lower_bound_values != rhs.__isset.lower_bound_values)
      return false;
    else if (__isset.lower_bound_values && !(lower_bound_values == rhs.lower_bound_values))
      return false;
    if (__isset.is_lower_bound_inclusive != rhs.__isset.is_lower_bound_inclusive)
      return false;
    else if (__isset.is_lower_bound_inclusive && !(is_lower_bound_inclusive == rhs.is_lower_bound_inclusive))
      return false;
    if (__isset.upper_bound_values != rhs.__isset.upper_bound_values)
      return false;
    else if (__isset.upper_bound_values && !(upper_bound_values == rhs.upper_bound_values))
      return false;
    if (__isset.is_upper_bound_inclusive != rhs.__isset.is_upper_bound_inclusive)
      return false;
    else if (__isset.is_upper_bound_inclusive && !(is_upper_bound_inclusive == rhs.is_upper_bound_inclusive))
      return false;
    return true;
  }
  bool operator != (const TKuduRangePartition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduRangePartition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduRangePartition &a, TKuduRangePartition &b);

inline std::ostream& operator<<(std::ostream& out, const TKuduRangePartition& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TKuduPartitionByRangeParam__isset {
  _TKuduPartitionByRangeParam__isset() : range_partitions(false) {}
  bool range_partitions :1;
} _TKuduPartitionByRangeParam__isset;

class TKuduPartitionByRangeParam {
 public:

  TKuduPartitionByRangeParam(const TKuduPartitionByRangeParam&);
  TKuduPartitionByRangeParam& operator=(const TKuduPartitionByRangeParam&);
  TKuduPartitionByRangeParam() {
  }

  virtual ~TKuduPartitionByRangeParam() throw();
  std::vector<std::string>  columns;
  std::vector<TKuduRangePartition>  range_partitions;

  _TKuduPartitionByRangeParam__isset __isset;

  void __set_columns(const std::vector<std::string> & val);

  void __set_range_partitions(const std::vector<TKuduRangePartition> & val);

  bool operator == (const TKuduPartitionByRangeParam & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (__isset.range_partitions != rhs.__isset.range_partitions)
      return false;
    else if (__isset.range_partitions && !(range_partitions == rhs.range_partitions))
      return false;
    return true;
  }
  bool operator != (const TKuduPartitionByRangeParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduPartitionByRangeParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduPartitionByRangeParam &a, TKuduPartitionByRangeParam &b);

inline std::ostream& operator<<(std::ostream& out, const TKuduPartitionByRangeParam& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TKuduPartitionParam__isset {
  _TKuduPartitionParam__isset() : by_hash_param(false), by_range_param(false) {}
  bool by_hash_param :1;
  bool by_range_param :1;
} _TKuduPartitionParam__isset;

class TKuduPartitionParam {
 public:

  TKuduPartitionParam(const TKuduPartitionParam&);
  TKuduPartitionParam& operator=(const TKuduPartitionParam&);
  TKuduPartitionParam() {
  }

  virtual ~TKuduPartitionParam() throw();
  TKuduPartitionByHashParam by_hash_param;
  TKuduPartitionByRangeParam by_range_param;

  _TKuduPartitionParam__isset __isset;

  void __set_by_hash_param(const TKuduPartitionByHashParam& val);

  void __set_by_range_param(const TKuduPartitionByRangeParam& val);

  bool operator == (const TKuduPartitionParam & rhs) const
  {
    if (__isset.by_hash_param != rhs.__isset.by_hash_param)
      return false;
    else if (__isset.by_hash_param && !(by_hash_param == rhs.by_hash_param))
      return false;
    if (__isset.by_range_param != rhs.__isset.by_range_param)
      return false;
    else if (__isset.by_range_param && !(by_range_param == rhs.by_range_param))
      return false;
    return true;
  }
  bool operator != (const TKuduPartitionParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduPartitionParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduPartitionParam &a, TKuduPartitionParam &b);

inline std::ostream& operator<<(std::ostream& out, const TKuduPartitionParam& obj)
{
  obj.printTo(out);
  return out;
}


class TKuduTable {
 public:

  TKuduTable(const TKuduTable&);
  TKuduTable& operator=(const TKuduTable&);
  TKuduTable() : table_name() {
  }

  virtual ~TKuduTable() throw();
  std::string table_name;
  std::vector<std::string>  master_addresses;
  std::vector<std::string>  key_columns;
  std::vector<TKuduPartitionParam>  partition_by;

  void __set_table_name(const std::string& val);

  void __set_master_addresses(const std::vector<std::string> & val);

  void __set_key_columns(const std::vector<std::string> & val);

  void __set_partition_by(const std::vector<TKuduPartitionParam> & val);

  bool operator == (const TKuduTable & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(master_addresses == rhs.master_addresses))
      return false;
    if (!(key_columns == rhs.key_columns))
      return false;
    if (!(partition_by == rhs.partition_by))
      return false;
    return true;
  }
  bool operator != (const TKuduTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TKuduTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduTable &a, TKuduTable &b);

inline std::ostream& operator<<(std::ostream& out, const TKuduTable& obj)
{
  obj.printTo(out);
  return out;
}


class TSchemaTable {
 public:

  TSchemaTable(const TSchemaTable&);
  TSchemaTable& operator=(const TSchemaTable&);
  TSchemaTable() : tableType((TSchemaTableType::type)0) {
  }

  virtual ~TSchemaTable() throw();
  TSchemaTableType::type tableType;

  void __set_tableType(const TSchemaTableType::type val);

  bool operator == (const TSchemaTable & rhs) const
  {
    if (!(tableType == rhs.tableType))
      return false;
    return true;
  }
  bool operator != (const TSchemaTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSchemaTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSchemaTable &a, TSchemaTable &b);

inline std::ostream& operator<<(std::ostream& out, const TSchemaTable& obj)
{
  obj.printTo(out);
  return out;
}


class TBrokerTable {
 public:

  TBrokerTable(const TBrokerTable&);
  TBrokerTable& operator=(const TBrokerTable&);
  TBrokerTable() {
  }

  virtual ~TBrokerTable() throw();

  bool operator == (const TBrokerTable & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TBrokerTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBrokerTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBrokerTable &a, TBrokerTable &b);

inline std::ostream& operator<<(std::ostream& out, const TBrokerTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTableDescriptor__isset {
  _TTableDescriptor__isset() : mysqlTable(false), olapTable(false), schemaTable(false), kuduTable(false), BrokerTable(false) {}
  bool mysqlTable :1;
  bool olapTable :1;
  bool schemaTable :1;
  bool kuduTable :1;
  bool BrokerTable :1;
} _TTableDescriptor__isset;

class TTableDescriptor {
 public:

  TTableDescriptor(const TTableDescriptor&);
  TTableDescriptor& operator=(const TTableDescriptor&);
  TTableDescriptor() : id(0), tableType(( ::palo::TTableType::type)0), numCols(0), numClusteringCols(0), tableName(), dbName() {
  }

  virtual ~TTableDescriptor() throw();
   ::palo::TTableId id;
   ::palo::TTableType::type tableType;
  int32_t numCols;
  int32_t numClusteringCols;
  std::string tableName;
  std::string dbName;
  TMySQLTable mysqlTable;
  TOlapTable olapTable;
  TSchemaTable schemaTable;
  TKuduTable kuduTable;
  TBrokerTable BrokerTable;

  _TTableDescriptor__isset __isset;

  void __set_id(const  ::palo::TTableId val);

  void __set_tableType(const  ::palo::TTableType::type val);

  void __set_numCols(const int32_t val);

  void __set_numClusteringCols(const int32_t val);

  void __set_tableName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_mysqlTable(const TMySQLTable& val);

  void __set_olapTable(const TOlapTable& val);

  void __set_schemaTable(const TSchemaTable& val);

  void __set_kuduTable(const TKuduTable& val);

  void __set_BrokerTable(const TBrokerTable& val);

  bool operator == (const TTableDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (!(numCols == rhs.numCols))
      return false;
    if (!(numClusteringCols == rhs.numClusteringCols))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (__isset.mysqlTable != rhs.__isset.mysqlTable)
      return false;
    else if (__isset.mysqlTable && !(mysqlTable == rhs.mysqlTable))
      return false;
    if (__isset.olapTable != rhs.__isset.olapTable)
      return false;
    else if (__isset.olapTable && !(olapTable == rhs.olapTable))
      return false;
    if (__isset.schemaTable != rhs.__isset.schemaTable)
      return false;
    else if (__isset.schemaTable && !(schemaTable == rhs.schemaTable))
      return false;
    if (__isset.kuduTable != rhs.__isset.kuduTable)
      return false;
    else if (__isset.kuduTable && !(kuduTable == rhs.kuduTable))
      return false;
    if (__isset.BrokerTable != rhs.__isset.BrokerTable)
      return false;
    else if (__isset.BrokerTable && !(BrokerTable == rhs.BrokerTable))
      return false;
    return true;
  }
  bool operator != (const TTableDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableDescriptor &a, TTableDescriptor &b);

inline std::ostream& operator<<(std::ostream& out, const TTableDescriptor& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TTupleDescriptor__isset {
  _TTupleDescriptor__isset() : tableId(false), numNullSlots(false) {}
  bool tableId :1;
  bool numNullSlots :1;
} _TTupleDescriptor__isset;

class TTupleDescriptor {
 public:

  TTupleDescriptor(const TTupleDescriptor&);
  TTupleDescriptor& operator=(const TTupleDescriptor&);
  TTupleDescriptor() : id(0), byteSize(0), numNullBytes(0), tableId(0), numNullSlots(0) {
  }

  virtual ~TTupleDescriptor() throw();
   ::palo::TTupleId id;
  int32_t byteSize;
  int32_t numNullBytes;
   ::palo::TTableId tableId;
  int32_t numNullSlots;

  _TTupleDescriptor__isset __isset;

  void __set_id(const  ::palo::TTupleId val);

  void __set_byteSize(const int32_t val);

  void __set_numNullBytes(const int32_t val);

  void __set_tableId(const  ::palo::TTableId val);

  void __set_numNullSlots(const int32_t val);

  bool operator == (const TTupleDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(byteSize == rhs.byteSize))
      return false;
    if (!(numNullBytes == rhs.numNullBytes))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    if (__isset.numNullSlots != rhs.__isset.numNullSlots)
      return false;
    else if (__isset.numNullSlots && !(numNullSlots == rhs.numNullSlots))
      return false;
    return true;
  }
  bool operator != (const TTupleDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTupleDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTupleDescriptor &a, TTupleDescriptor &b);

inline std::ostream& operator<<(std::ostream& out, const TTupleDescriptor& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TDescriptorTable__isset {
  _TDescriptorTable__isset() : slotDescriptors(false), tableDescriptors(false) {}
  bool slotDescriptors :1;
  bool tableDescriptors :1;
} _TDescriptorTable__isset;

class TDescriptorTable {
 public:

  TDescriptorTable(const TDescriptorTable&);
  TDescriptorTable& operator=(const TDescriptorTable&);
  TDescriptorTable() {
  }

  virtual ~TDescriptorTable() throw();
  std::vector<TSlotDescriptor>  slotDescriptors;
  std::vector<TTupleDescriptor>  tupleDescriptors;
  std::vector<TTableDescriptor>  tableDescriptors;

  _TDescriptorTable__isset __isset;

  void __set_slotDescriptors(const std::vector<TSlotDescriptor> & val);

  void __set_tupleDescriptors(const std::vector<TTupleDescriptor> & val);

  void __set_tableDescriptors(const std::vector<TTableDescriptor> & val);

  bool operator == (const TDescriptorTable & rhs) const
  {
    if (__isset.slotDescriptors != rhs.__isset.slotDescriptors)
      return false;
    else if (__isset.slotDescriptors && !(slotDescriptors == rhs.slotDescriptors))
      return false;
    if (!(tupleDescriptors == rhs.tupleDescriptors))
      return false;
    if (__isset.tableDescriptors != rhs.__isset.tableDescriptors)
      return false;
    else if (__isset.tableDescriptors && !(tableDescriptors == rhs.tableDescriptors))
      return false;
    return true;
  }
  bool operator != (const TDescriptorTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDescriptorTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDescriptorTable &a, TDescriptorTable &b);

inline std::ostream& operator<<(std::ostream& out, const TDescriptorTable& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
