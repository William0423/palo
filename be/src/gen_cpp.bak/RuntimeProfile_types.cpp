/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "RuntimeProfile_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {


TCounter::~TCounter() throw() {
}


void TCounter::__set_name(const std::string& val) {
  this->name = val;
}

void TCounter::__set_type(const  ::palo::TUnit::type val) {
  this->type = val;
}

void TCounter::__set_value(const int64_t val) {
  this->value = val;
}

uint32_t TCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = ( ::palo::TUnit::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCounter");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCounter &a, TCounter &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.value, b.value);
}

TCounter::TCounter(const TCounter& other1) {
  name = other1.name;
  type = other1.type;
  value = other1.value;
}
TCounter& TCounter::operator=(const TCounter& other2) {
  name = other2.name;
  type = other2.type;
  value = other2.value;
  return *this;
}
void TCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCounter(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TRuntimeProfileNode::~TRuntimeProfileNode() throw() {
}


void TRuntimeProfileNode::__set_name(const std::string& val) {
  this->name = val;
}

void TRuntimeProfileNode::__set_num_children(const int32_t val) {
  this->num_children = val;
}

void TRuntimeProfileNode::__set_counters(const std::vector<TCounter> & val) {
  this->counters = val;
}

void TRuntimeProfileNode::__set_metadata(const int64_t val) {
  this->metadata = val;
}

void TRuntimeProfileNode::__set_indent(const bool val) {
  this->indent = val;
}

void TRuntimeProfileNode::__set_info_strings(const std::map<std::string, std::string> & val) {
  this->info_strings = val;
}

void TRuntimeProfileNode::__set_info_strings_display_order(const std::vector<std::string> & val) {
  this->info_strings_display_order = val;
}

void TRuntimeProfileNode::__set_child_counters_map(const std::map<std::string, std::set<std::string> > & val) {
  this->child_counters_map = val;
}

uint32_t TRuntimeProfileNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_num_children = false;
  bool isset_counters = false;
  bool isset_metadata = false;
  bool isset_indent = false;
  bool isset_info_strings = false;
  bool isset_info_strings_display_order = false;
  bool isset_child_counters_map = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counters.clear();
            uint32_t _size3;
            ::apache::thrift::protocol::TType _etype6;
            xfer += iprot->readListBegin(_etype6, _size3);
            this->counters.resize(_size3);
            uint32_t _i7;
            for (_i7 = 0; _i7 < _size3; ++_i7)
            {
              xfer += this->counters[_i7].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->metadata);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->indent);
          isset_indent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->info_strings.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _ktype9;
            ::apache::thrift::protocol::TType _vtype10;
            xfer += iprot->readMapBegin(_ktype9, _vtype10, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              std::string _key13;
              xfer += iprot->readString(_key13);
              std::string& _val14 = this->info_strings[_key13];
              xfer += iprot->readString(_val14);
            }
            xfer += iprot->readMapEnd();
          }
          isset_info_strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->info_strings_display_order.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->info_strings_display_order.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readString(this->info_strings_display_order[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          isset_info_strings_display_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->child_counters_map.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _ktype21;
            ::apache::thrift::protocol::TType _vtype22;
            xfer += iprot->readMapBegin(_ktype21, _vtype22, _size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              std::string _key25;
              xfer += iprot->readString(_key25);
              std::set<std::string> & _val26 = this->child_counters_map[_key25];
              {
                _val26.clear();
                uint32_t _size27;
                ::apache::thrift::protocol::TType _etype30;
                xfer += iprot->readSetBegin(_etype30, _size27);
                uint32_t _i31;
                for (_i31 = 0; _i31 < _size27; ++_i31)
                {
                  std::string _elem32;
                  xfer += iprot->readString(_elem32);
                  _val26.insert(_elem32);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_child_counters_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_counters)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_indent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_info_strings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_info_strings_display_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_child_counters_map)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRuntimeProfileNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRuntimeProfileNode");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counters", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->counters.size()));
    std::vector<TCounter> ::const_iterator _iter33;
    for (_iter33 = this->counters.begin(); _iter33 != this->counters.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indent", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->indent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("info_strings", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->info_strings.size()));
    std::map<std::string, std::string> ::const_iterator _iter34;
    for (_iter34 = this->info_strings.begin(); _iter34 != this->info_strings.end(); ++_iter34)
    {
      xfer += oprot->writeString(_iter34->first);
      xfer += oprot->writeString(_iter34->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("info_strings_display_order", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->info_strings_display_order.size()));
    std::vector<std::string> ::const_iterator _iter35;
    for (_iter35 = this->info_strings_display_order.begin(); _iter35 != this->info_strings_display_order.end(); ++_iter35)
    {
      xfer += oprot->writeString((*_iter35));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_counters_map", ::apache::thrift::protocol::T_MAP, 8);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->child_counters_map.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter36;
    for (_iter36 = this->child_counters_map.begin(); _iter36 != this->child_counters_map.end(); ++_iter36)
    {
      xfer += oprot->writeString(_iter36->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter36->second.size()));
        std::set<std::string> ::const_iterator _iter37;
        for (_iter37 = _iter36->second.begin(); _iter37 != _iter36->second.end(); ++_iter37)
        {
          xfer += oprot->writeString((*_iter37));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRuntimeProfileNode &a, TRuntimeProfileNode &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.num_children, b.num_children);
  swap(a.counters, b.counters);
  swap(a.metadata, b.metadata);
  swap(a.indent, b.indent);
  swap(a.info_strings, b.info_strings);
  swap(a.info_strings_display_order, b.info_strings_display_order);
  swap(a.child_counters_map, b.child_counters_map);
}

TRuntimeProfileNode::TRuntimeProfileNode(const TRuntimeProfileNode& other38) {
  name = other38.name;
  num_children = other38.num_children;
  counters = other38.counters;
  metadata = other38.metadata;
  indent = other38.indent;
  info_strings = other38.info_strings;
  info_strings_display_order = other38.info_strings_display_order;
  child_counters_map = other38.child_counters_map;
}
TRuntimeProfileNode& TRuntimeProfileNode::operator=(const TRuntimeProfileNode& other39) {
  name = other39.name;
  num_children = other39.num_children;
  counters = other39.counters;
  metadata = other39.metadata;
  indent = other39.indent;
  info_strings = other39.info_strings;
  info_strings_display_order = other39.info_strings_display_order;
  child_counters_map = other39.child_counters_map;
  return *this;
}
void TRuntimeProfileNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRuntimeProfileNode(";
  out << "name=" << to_string(name);
  out << ", " << "num_children=" << to_string(num_children);
  out << ", " << "counters=" << to_string(counters);
  out << ", " << "metadata=" << to_string(metadata);
  out << ", " << "indent=" << to_string(indent);
  out << ", " << "info_strings=" << to_string(info_strings);
  out << ", " << "info_strings_display_order=" << to_string(info_strings_display_order);
  out << ", " << "child_counters_map=" << to_string(child_counters_map);
  out << ")";
}


TRuntimeProfileTree::~TRuntimeProfileTree() throw() {
}


void TRuntimeProfileTree::__set_nodes(const std::vector<TRuntimeProfileNode> & val) {
  this->nodes = val;
}

uint32_t TRuntimeProfileTree::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->nodes.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->nodes[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRuntimeProfileTree::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRuntimeProfileTree");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TRuntimeProfileNode> ::const_iterator _iter45;
    for (_iter45 = this->nodes.begin(); _iter45 != this->nodes.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRuntimeProfileTree &a, TRuntimeProfileTree &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

TRuntimeProfileTree::TRuntimeProfileTree(const TRuntimeProfileTree& other46) {
  nodes = other46.nodes;
}
TRuntimeProfileTree& TRuntimeProfileTree::operator=(const TRuntimeProfileTree& other47) {
  nodes = other47.nodes;
  return *this;
}
void TRuntimeProfileTree::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRuntimeProfileTree(";
  out << "nodes=" << to_string(nodes);
  out << ")";
}

} // namespace
