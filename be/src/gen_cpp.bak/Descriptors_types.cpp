/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Descriptors_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTHdfsFileFormatValues[] = {
  THdfsFileFormat::TEXT,
  THdfsFileFormat::LZO_TEXT,
  THdfsFileFormat::RC_FILE,
  THdfsFileFormat::SEQUENCE_FILE,
  THdfsFileFormat::AVRO,
  THdfsFileFormat::PARQUET
};
const char* _kTHdfsFileFormatNames[] = {
  "TEXT",
  "LZO_TEXT",
  "RC_FILE",
  "SEQUENCE_FILE",
  "AVRO",
  "PARQUET"
};
const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTHdfsFileFormatValues, _kTHdfsFileFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTSchemaTableTypeValues[] = {
  TSchemaTableType::SCH_AUTHORS,
  TSchemaTableType::SCH_CHARSETS,
  TSchemaTableType::SCH_COLLATIONS,
  TSchemaTableType::SCH_COLLATION_CHARACTER_SET_APPLICABILITY,
  TSchemaTableType::SCH_COLUMNS,
  TSchemaTableType::SCH_COLUMN_PRIVILEGES,
  TSchemaTableType::SCH_CREATE_TABLE,
  TSchemaTableType::SCH_ENGINES,
  TSchemaTableType::SCH_EVENTS,
  TSchemaTableType::SCH_FILES,
  TSchemaTableType::SCH_GLOBAL_STATUS,
  TSchemaTableType::SCH_GLOBAL_VARIABLES,
  TSchemaTableType::SCH_KEY_COLUMN_USAGE,
  TSchemaTableType::SCH_OPEN_TABLES,
  TSchemaTableType::SCH_PARTITIONS,
  TSchemaTableType::SCH_PLUGINS,
  TSchemaTableType::SCH_PROCESSLIST,
  TSchemaTableType::SCH_PROFILES,
  TSchemaTableType::SCH_REFERENTIAL_CONSTRAINTS,
  TSchemaTableType::SCH_PROCEDURES,
  TSchemaTableType::SCH_SCHEMATA,
  TSchemaTableType::SCH_SCHEMA_PRIVILEGES,
  TSchemaTableType::SCH_SESSION_STATUS,
  TSchemaTableType::SCH_SESSION_VARIABLES,
  TSchemaTableType::SCH_STATISTICS,
  TSchemaTableType::SCH_STATUS,
  TSchemaTableType::SCH_TABLES,
  TSchemaTableType::SCH_TABLE_CONSTRAINTS,
  TSchemaTableType::SCH_TABLE_NAMES,
  TSchemaTableType::SCH_TABLE_PRIVILEGES,
  TSchemaTableType::SCH_TRIGGERS,
  TSchemaTableType::SCH_USER_PRIVILEGES,
  TSchemaTableType::SCH_VARIABLES,
  TSchemaTableType::SCH_VIEWS,
  TSchemaTableType::SCH_INVALID
};
const char* _kTSchemaTableTypeNames[] = {
  "SCH_AUTHORS",
  "SCH_CHARSETS",
  "SCH_COLLATIONS",
  "SCH_COLLATION_CHARACTER_SET_APPLICABILITY",
  "SCH_COLUMNS",
  "SCH_COLUMN_PRIVILEGES",
  "SCH_CREATE_TABLE",
  "SCH_ENGINES",
  "SCH_EVENTS",
  "SCH_FILES",
  "SCH_GLOBAL_STATUS",
  "SCH_GLOBAL_VARIABLES",
  "SCH_KEY_COLUMN_USAGE",
  "SCH_OPEN_TABLES",
  "SCH_PARTITIONS",
  "SCH_PLUGINS",
  "SCH_PROCESSLIST",
  "SCH_PROFILES",
  "SCH_REFERENTIAL_CONSTRAINTS",
  "SCH_PROCEDURES",
  "SCH_SCHEMATA",
  "SCH_SCHEMA_PRIVILEGES",
  "SCH_SESSION_STATUS",
  "SCH_SESSION_VARIABLES",
  "SCH_STATISTICS",
  "SCH_STATUS",
  "SCH_TABLES",
  "SCH_TABLE_CONSTRAINTS",
  "SCH_TABLE_NAMES",
  "SCH_TABLE_PRIVILEGES",
  "SCH_TRIGGERS",
  "SCH_USER_PRIVILEGES",
  "SCH_VARIABLES",
  "SCH_VIEWS",
  "SCH_INVALID"
};
const std::map<int, const char*> _TSchemaTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(35, _kTSchemaTableTypeValues, _kTSchemaTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTHdfsCompressionValues[] = {
  THdfsCompression::NONE,
  THdfsCompression::DEFAULT,
  THdfsCompression::GZIP,
  THdfsCompression::DEFLATE,
  THdfsCompression::BZIP2,
  THdfsCompression::SNAPPY,
  THdfsCompression::SNAPPY_BLOCKED
};
const char* _kTHdfsCompressionNames[] = {
  "NONE",
  "DEFAULT",
  "GZIP",
  "DEFLATE",
  "BZIP2",
  "SNAPPY",
  "SNAPPY_BLOCKED"
};
const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTHdfsCompressionValues, _kTHdfsCompressionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TSlotDescriptor::~TSlotDescriptor() throw() {
}


void TSlotDescriptor::__set_id(const  ::palo::TSlotId val) {
  this->id = val;
}

void TSlotDescriptor::__set_parent(const  ::palo::TTupleId val) {
  this->parent = val;
}

void TSlotDescriptor::__set_slotType(const  ::palo::TTypeDesc& val) {
  this->slotType = val;
}

void TSlotDescriptor::__set_columnPos(const int32_t val) {
  this->columnPos = val;
}

void TSlotDescriptor::__set_byteOffset(const int32_t val) {
  this->byteOffset = val;
}

void TSlotDescriptor::__set_nullIndicatorByte(const int32_t val) {
  this->nullIndicatorByte = val;
}

void TSlotDescriptor::__set_nullIndicatorBit(const int32_t val) {
  this->nullIndicatorBit = val;
}

void TSlotDescriptor::__set_colName(const std::string& val) {
  this->colName = val;
}

void TSlotDescriptor::__set_slotIdx(const int32_t val) {
  this->slotIdx = val;
}

void TSlotDescriptor::__set_isMaterialized(const bool val) {
  this->isMaterialized = val;
}

uint32_t TSlotDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_parent = false;
  bool isset_slotType = false;
  bool isset_columnPos = false;
  bool isset_byteOffset = false;
  bool isset_nullIndicatorByte = false;
  bool isset_nullIndicatorBit = false;
  bool isset_colName = false;
  bool isset_slotIdx = false;
  bool isset_isMaterialized = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent);
          isset_parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slotType.read(iprot);
          isset_slotType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnPos);
          isset_columnPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->byteOffset);
          isset_byteOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nullIndicatorByte);
          isset_nullIndicatorByte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nullIndicatorBit);
          isset_nullIndicatorBit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          isset_colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slotIdx);
          isset_slotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isMaterialized);
          isset_isMaterialized = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slotType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnPos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_byteOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullIndicatorByte)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullIndicatorBit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slotIdx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isMaterialized)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSlotDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSlotDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->parent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slotType", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->slotType.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnPos", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->columnPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteOffset", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->byteOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullIndicatorByte", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->nullIndicatorByte);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullIndicatorBit", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->nullIndicatorBit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->colName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slotIdx", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->slotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isMaterialized", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->isMaterialized);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSlotDescriptor &a, TSlotDescriptor &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.parent, b.parent);
  swap(a.slotType, b.slotType);
  swap(a.columnPos, b.columnPos);
  swap(a.byteOffset, b.byteOffset);
  swap(a.nullIndicatorByte, b.nullIndicatorByte);
  swap(a.nullIndicatorBit, b.nullIndicatorBit);
  swap(a.colName, b.colName);
  swap(a.slotIdx, b.slotIdx);
  swap(a.isMaterialized, b.isMaterialized);
}

TSlotDescriptor::TSlotDescriptor(const TSlotDescriptor& other0) {
  id = other0.id;
  parent = other0.parent;
  slotType = other0.slotType;
  columnPos = other0.columnPos;
  byteOffset = other0.byteOffset;
  nullIndicatorByte = other0.nullIndicatorByte;
  nullIndicatorBit = other0.nullIndicatorBit;
  colName = other0.colName;
  slotIdx = other0.slotIdx;
  isMaterialized = other0.isMaterialized;
}
TSlotDescriptor& TSlotDescriptor::operator=(const TSlotDescriptor& other1) {
  id = other1.id;
  parent = other1.parent;
  slotType = other1.slotType;
  columnPos = other1.columnPos;
  byteOffset = other1.byteOffset;
  nullIndicatorByte = other1.nullIndicatorByte;
  nullIndicatorBit = other1.nullIndicatorBit;
  colName = other1.colName;
  slotIdx = other1.slotIdx;
  isMaterialized = other1.isMaterialized;
  return *this;
}
void TSlotDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSlotDescriptor(";
  out << "id=" << to_string(id);
  out << ", " << "parent=" << to_string(parent);
  out << ", " << "slotType=" << to_string(slotType);
  out << ", " << "columnPos=" << to_string(columnPos);
  out << ", " << "byteOffset=" << to_string(byteOffset);
  out << ", " << "nullIndicatorByte=" << to_string(nullIndicatorByte);
  out << ", " << "nullIndicatorBit=" << to_string(nullIndicatorBit);
  out << ", " << "colName=" << to_string(colName);
  out << ", " << "slotIdx=" << to_string(slotIdx);
  out << ", " << "isMaterialized=" << to_string(isMaterialized);
  out << ")";
}


TOlapTable::~TOlapTable() throw() {
}


void TOlapTable::__set_tableName(const std::string& val) {
  this->tableName = val;
}

uint32_t TOlapTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOlapTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOlapTable");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TOlapTable &a, TOlapTable &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
}

TOlapTable::TOlapTable(const TOlapTable& other2) {
  tableName = other2.tableName;
}
TOlapTable& TOlapTable::operator=(const TOlapTable& other3) {
  tableName = other3.tableName;
  return *this;
}
void TOlapTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOlapTable(";
  out << "tableName=" << to_string(tableName);
  out << ")";
}


TMySQLTable::~TMySQLTable() throw() {
}


void TMySQLTable::__set_host(const std::string& val) {
  this->host = val;
}

void TMySQLTable::__set_port(const std::string& val) {
  this->port = val;
}

void TMySQLTable::__set_user(const std::string& val) {
  this->user = val;
}

void TMySQLTable::__set_passwd(const std::string& val) {
  this->passwd = val;
}

void TMySQLTable::__set_db(const std::string& val) {
  this->db = val;
}

void TMySQLTable::__set_table(const std::string& val) {
  this->table = val;
}

uint32_t TMySQLTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_port = false;
  bool isset_user = false;
  bool isset_passwd = false;
  bool isset_db = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          isset_passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_passwd)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMySQLTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMySQLTable");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMySQLTable &a, TMySQLTable &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.db, b.db);
  swap(a.table, b.table);
}

TMySQLTable::TMySQLTable(const TMySQLTable& other4) {
  host = other4.host;
  port = other4.port;
  user = other4.user;
  passwd = other4.passwd;
  db = other4.db;
  table = other4.table;
}
TMySQLTable& TMySQLTable::operator=(const TMySQLTable& other5) {
  host = other5.host;
  port = other5.port;
  user = other5.user;
  passwd = other5.passwd;
  db = other5.db;
  table = other5.table;
  return *this;
}
void TMySQLTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMySQLTable(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ", " << "user=" << to_string(user);
  out << ", " << "passwd=" << to_string(passwd);
  out << ", " << "db=" << to_string(db);
  out << ", " << "table=" << to_string(table);
  out << ")";
}


TKuduPartitionByHashParam::~TKuduPartitionByHashParam() throw() {
}


void TKuduPartitionByHashParam::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
}

void TKuduPartitionByHashParam::__set_num_partitions(const int32_t val) {
  this->num_partitions = val;
}

uint32_t TKuduPartitionByHashParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_num_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->columns.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->columns[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_partitions);
          isset_num_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduPartitionByHashParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduPartitionByHashParam");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter11;
    for (_iter11 = this->columns.begin(); _iter11 != this->columns.end(); ++_iter11)
    {
      xfer += oprot->writeString((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_partitions", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_partitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduPartitionByHashParam &a, TKuduPartitionByHashParam &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.num_partitions, b.num_partitions);
}

TKuduPartitionByHashParam::TKuduPartitionByHashParam(const TKuduPartitionByHashParam& other12) {
  columns = other12.columns;
  num_partitions = other12.num_partitions;
}
TKuduPartitionByHashParam& TKuduPartitionByHashParam::operator=(const TKuduPartitionByHashParam& other13) {
  columns = other13.columns;
  num_partitions = other13.num_partitions;
  return *this;
}
void TKuduPartitionByHashParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduPartitionByHashParam(";
  out << "columns=" << to_string(columns);
  out << ", " << "num_partitions=" << to_string(num_partitions);
  out << ")";
}


TKuduRangePartition::~TKuduRangePartition() throw() {
}


void TKuduRangePartition::__set_lower_bound_values(const std::vector< ::palo::TExpr> & val) {
  this->lower_bound_values = val;
__isset.lower_bound_values = true;
}

void TKuduRangePartition::__set_is_lower_bound_inclusive(const bool val) {
  this->is_lower_bound_inclusive = val;
__isset.is_lower_bound_inclusive = true;
}

void TKuduRangePartition::__set_upper_bound_values(const std::vector< ::palo::TExpr> & val) {
  this->upper_bound_values = val;
__isset.upper_bound_values = true;
}

void TKuduRangePartition::__set_is_upper_bound_inclusive(const bool val) {
  this->is_upper_bound_inclusive = val;
__isset.is_upper_bound_inclusive = true;
}

uint32_t TKuduRangePartition::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lower_bound_values.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->lower_bound_values.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->lower_bound_values[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lower_bound_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_lower_bound_inclusive);
          this->__isset.is_lower_bound_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->upper_bound_values.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->upper_bound_values.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->upper_bound_values[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.upper_bound_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_upper_bound_inclusive);
          this->__isset.is_upper_bound_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKuduRangePartition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduRangePartition");

  if (this->__isset.lower_bound_values) {
    xfer += oprot->writeFieldBegin("lower_bound_values", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lower_bound_values.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter24;
      for (_iter24 = this->lower_bound_values.begin(); _iter24 != this->lower_bound_values.end(); ++_iter24)
      {
        xfer += (*_iter24).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_lower_bound_inclusive) {
    xfer += oprot->writeFieldBegin("is_lower_bound_inclusive", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->is_lower_bound_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upper_bound_values) {
    xfer += oprot->writeFieldBegin("upper_bound_values", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->upper_bound_values.size()));
      std::vector< ::palo::TExpr> ::const_iterator _iter25;
      for (_iter25 = this->upper_bound_values.begin(); _iter25 != this->upper_bound_values.end(); ++_iter25)
      {
        xfer += (*_iter25).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_upper_bound_inclusive) {
    xfer += oprot->writeFieldBegin("is_upper_bound_inclusive", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_upper_bound_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduRangePartition &a, TKuduRangePartition &b) {
  using ::std::swap;
  swap(a.lower_bound_values, b.lower_bound_values);
  swap(a.is_lower_bound_inclusive, b.is_lower_bound_inclusive);
  swap(a.upper_bound_values, b.upper_bound_values);
  swap(a.is_upper_bound_inclusive, b.is_upper_bound_inclusive);
  swap(a.__isset, b.__isset);
}

TKuduRangePartition::TKuduRangePartition(const TKuduRangePartition& other26) {
  lower_bound_values = other26.lower_bound_values;
  is_lower_bound_inclusive = other26.is_lower_bound_inclusive;
  upper_bound_values = other26.upper_bound_values;
  is_upper_bound_inclusive = other26.is_upper_bound_inclusive;
  __isset = other26.__isset;
}
TKuduRangePartition& TKuduRangePartition::operator=(const TKuduRangePartition& other27) {
  lower_bound_values = other27.lower_bound_values;
  is_lower_bound_inclusive = other27.is_lower_bound_inclusive;
  upper_bound_values = other27.upper_bound_values;
  is_upper_bound_inclusive = other27.is_upper_bound_inclusive;
  __isset = other27.__isset;
  return *this;
}
void TKuduRangePartition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduRangePartition(";
  out << "lower_bound_values="; (__isset.lower_bound_values ? (out << to_string(lower_bound_values)) : (out << "<null>"));
  out << ", " << "is_lower_bound_inclusive="; (__isset.is_lower_bound_inclusive ? (out << to_string(is_lower_bound_inclusive)) : (out << "<null>"));
  out << ", " << "upper_bound_values="; (__isset.upper_bound_values ? (out << to_string(upper_bound_values)) : (out << "<null>"));
  out << ", " << "is_upper_bound_inclusive="; (__isset.is_upper_bound_inclusive ? (out << to_string(is_upper_bound_inclusive)) : (out << "<null>"));
  out << ")";
}


TKuduPartitionByRangeParam::~TKuduPartitionByRangeParam() throw() {
}


void TKuduPartitionByRangeParam::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
}

void TKuduPartitionByRangeParam::__set_range_partitions(const std::vector<TKuduRangePartition> & val) {
  this->range_partitions = val;
__isset.range_partitions = true;
}

uint32_t TKuduPartitionByRangeParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->columns.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->columns[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_partitions.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->range_partitions.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->range_partitions[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduPartitionByRangeParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduPartitionByRangeParam");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter38;
    for (_iter38 = this->columns.begin(); _iter38 != this->columns.end(); ++_iter38)
    {
      xfer += oprot->writeString((*_iter38));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.range_partitions) {
    xfer += oprot->writeFieldBegin("range_partitions", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->range_partitions.size()));
      std::vector<TKuduRangePartition> ::const_iterator _iter39;
      for (_iter39 = this->range_partitions.begin(); _iter39 != this->range_partitions.end(); ++_iter39)
      {
        xfer += (*_iter39).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduPartitionByRangeParam &a, TKuduPartitionByRangeParam &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.range_partitions, b.range_partitions);
  swap(a.__isset, b.__isset);
}

TKuduPartitionByRangeParam::TKuduPartitionByRangeParam(const TKuduPartitionByRangeParam& other40) {
  columns = other40.columns;
  range_partitions = other40.range_partitions;
  __isset = other40.__isset;
}
TKuduPartitionByRangeParam& TKuduPartitionByRangeParam::operator=(const TKuduPartitionByRangeParam& other41) {
  columns = other41.columns;
  range_partitions = other41.range_partitions;
  __isset = other41.__isset;
  return *this;
}
void TKuduPartitionByRangeParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduPartitionByRangeParam(";
  out << "columns=" << to_string(columns);
  out << ", " << "range_partitions="; (__isset.range_partitions ? (out << to_string(range_partitions)) : (out << "<null>"));
  out << ")";
}


TKuduPartitionParam::~TKuduPartitionParam() throw() {
}


void TKuduPartitionParam::__set_by_hash_param(const TKuduPartitionByHashParam& val) {
  this->by_hash_param = val;
__isset.by_hash_param = true;
}

void TKuduPartitionParam::__set_by_range_param(const TKuduPartitionByRangeParam& val) {
  this->by_range_param = val;
__isset.by_range_param = true;
}

uint32_t TKuduPartitionParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->by_hash_param.read(iprot);
          this->__isset.by_hash_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->by_range_param.read(iprot);
          this->__isset.by_range_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKuduPartitionParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduPartitionParam");

  if (this->__isset.by_hash_param) {
    xfer += oprot->writeFieldBegin("by_hash_param", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->by_hash_param.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.by_range_param) {
    xfer += oprot->writeFieldBegin("by_range_param", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->by_range_param.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduPartitionParam &a, TKuduPartitionParam &b) {
  using ::std::swap;
  swap(a.by_hash_param, b.by_hash_param);
  swap(a.by_range_param, b.by_range_param);
  swap(a.__isset, b.__isset);
}

TKuduPartitionParam::TKuduPartitionParam(const TKuduPartitionParam& other42) {
  by_hash_param = other42.by_hash_param;
  by_range_param = other42.by_range_param;
  __isset = other42.__isset;
}
TKuduPartitionParam& TKuduPartitionParam::operator=(const TKuduPartitionParam& other43) {
  by_hash_param = other43.by_hash_param;
  by_range_param = other43.by_range_param;
  __isset = other43.__isset;
  return *this;
}
void TKuduPartitionParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduPartitionParam(";
  out << "by_hash_param="; (__isset.by_hash_param ? (out << to_string(by_hash_param)) : (out << "<null>"));
  out << ", " << "by_range_param="; (__isset.by_range_param ? (out << to_string(by_range_param)) : (out << "<null>"));
  out << ")";
}


TKuduTable::~TKuduTable() throw() {
}


void TKuduTable::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TKuduTable::__set_master_addresses(const std::vector<std::string> & val) {
  this->master_addresses = val;
}

void TKuduTable::__set_key_columns(const std::vector<std::string> & val) {
  this->key_columns = val;
}

void TKuduTable::__set_partition_by(const std::vector<TKuduPartitionParam> & val) {
  this->partition_by = val;
}

uint32_t TKuduTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_master_addresses = false;
  bool isset_key_columns = false;
  bool isset_partition_by = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->master_addresses.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->master_addresses.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += iprot->readString(this->master_addresses[_i48]);
            }
            xfer += iprot->readListEnd();
          }
          isset_master_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_columns.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->key_columns.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += iprot->readString(this->key_columns[_i53]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_by.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->partition_by.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->partition_by[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_master_addresses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_by)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TKuduTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduTable");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("master_addresses", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->master_addresses.size()));
    std::vector<std::string> ::const_iterator _iter59;
    for (_iter59 = this->master_addresses.begin(); _iter59 != this->master_addresses.end(); ++_iter59)
    {
      xfer += oprot->writeString((*_iter59));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key_columns.size()));
    std::vector<std::string> ::const_iterator _iter60;
    for (_iter60 = this->key_columns.begin(); _iter60 != this->key_columns.end(); ++_iter60)
    {
      xfer += oprot->writeString((*_iter60));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_by", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_by.size()));
    std::vector<TKuduPartitionParam> ::const_iterator _iter61;
    for (_iter61 = this->partition_by.begin(); _iter61 != this->partition_by.end(); ++_iter61)
    {
      xfer += (*_iter61).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKuduTable &a, TKuduTable &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.master_addresses, b.master_addresses);
  swap(a.key_columns, b.key_columns);
  swap(a.partition_by, b.partition_by);
}

TKuduTable::TKuduTable(const TKuduTable& other62) {
  table_name = other62.table_name;
  master_addresses = other62.master_addresses;
  key_columns = other62.key_columns;
  partition_by = other62.partition_by;
}
TKuduTable& TKuduTable::operator=(const TKuduTable& other63) {
  table_name = other63.table_name;
  master_addresses = other63.master_addresses;
  key_columns = other63.key_columns;
  partition_by = other63.partition_by;
  return *this;
}
void TKuduTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduTable(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "master_addresses=" << to_string(master_addresses);
  out << ", " << "key_columns=" << to_string(key_columns);
  out << ", " << "partition_by=" << to_string(partition_by);
  out << ")";
}


TSchemaTable::~TSchemaTable() throw() {
}


void TSchemaTable::__set_tableType(const TSchemaTableType::type val) {
  this->tableType = val;
}

uint32_t TSchemaTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->tableType = (TSchemaTableType::type)ecast64;
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSchemaTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSchemaTable");

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->tableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSchemaTable &a, TSchemaTable &b) {
  using ::std::swap;
  swap(a.tableType, b.tableType);
}

TSchemaTable::TSchemaTable(const TSchemaTable& other65) {
  tableType = other65.tableType;
}
TSchemaTable& TSchemaTable::operator=(const TSchemaTable& other66) {
  tableType = other66.tableType;
  return *this;
}
void TSchemaTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSchemaTable(";
  out << "tableType=" << to_string(tableType);
  out << ")";
}


TBrokerTable::~TBrokerTable() throw() {
}


uint32_t TBrokerTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TBrokerTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBrokerTable");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBrokerTable &a, TBrokerTable &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TBrokerTable::TBrokerTable(const TBrokerTable& other67) {
  (void) other67;
}
TBrokerTable& TBrokerTable::operator=(const TBrokerTable& other68) {
  (void) other68;
  return *this;
}
void TBrokerTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBrokerTable(";
  out << ")";
}


TTableDescriptor::~TTableDescriptor() throw() {
}


void TTableDescriptor::__set_id(const  ::palo::TTableId val) {
  this->id = val;
}

void TTableDescriptor::__set_tableType(const  ::palo::TTableType::type val) {
  this->tableType = val;
}

void TTableDescriptor::__set_numCols(const int32_t val) {
  this->numCols = val;
}

void TTableDescriptor::__set_numClusteringCols(const int32_t val) {
  this->numClusteringCols = val;
}

void TTableDescriptor::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void TTableDescriptor::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TTableDescriptor::__set_mysqlTable(const TMySQLTable& val) {
  this->mysqlTable = val;
__isset.mysqlTable = true;
}

void TTableDescriptor::__set_olapTable(const TOlapTable& val) {
  this->olapTable = val;
__isset.olapTable = true;
}

void TTableDescriptor::__set_schemaTable(const TSchemaTable& val) {
  this->schemaTable = val;
__isset.schemaTable = true;
}

void TTableDescriptor::__set_kuduTable(const TKuduTable& val) {
  this->kuduTable = val;
__isset.kuduTable = true;
}

void TTableDescriptor::__set_BrokerTable(const TBrokerTable& val) {
  this->BrokerTable = val;
__isset.BrokerTable = true;
}

uint32_t TTableDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_tableType = false;
  bool isset_numCols = false;
  bool isset_numClusteringCols = false;
  bool isset_tableName = false;
  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast69;
          xfer += iprot->readI32(ecast69);
          this->tableType = ( ::palo::TTableType::type)ecast69;
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numCols);
          isset_numCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numClusteringCols);
          isset_numClusteringCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mysqlTable.read(iprot);
          this->__isset.mysqlTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->olapTable.read(iprot);
          this->__isset.olapTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemaTable.read(iprot);
          this->__isset.schemaTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kuduTable.read(iprot);
          this->__isset.kuduTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->BrokerTable.read(iprot);
          this->__isset.BrokerTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numClusteringCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->tableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numCols", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->numCols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numClusteringCols", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->numClusteringCols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mysqlTable) {
    xfer += oprot->writeFieldBegin("mysqlTable", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->mysqlTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.olapTable) {
    xfer += oprot->writeFieldBegin("olapTable", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->olapTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schemaTable) {
    xfer += oprot->writeFieldBegin("schemaTable", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->schemaTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kuduTable) {
    xfer += oprot->writeFieldBegin("kuduTable", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->kuduTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.BrokerTable) {
    xfer += oprot->writeFieldBegin("BrokerTable", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->BrokerTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDescriptor &a, TTableDescriptor &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.tableType, b.tableType);
  swap(a.numCols, b.numCols);
  swap(a.numClusteringCols, b.numClusteringCols);
  swap(a.tableName, b.tableName);
  swap(a.dbName, b.dbName);
  swap(a.mysqlTable, b.mysqlTable);
  swap(a.olapTable, b.olapTable);
  swap(a.schemaTable, b.schemaTable);
  swap(a.kuduTable, b.kuduTable);
  swap(a.BrokerTable, b.BrokerTable);
  swap(a.__isset, b.__isset);
}

TTableDescriptor::TTableDescriptor(const TTableDescriptor& other70) {
  id = other70.id;
  tableType = other70.tableType;
  numCols = other70.numCols;
  numClusteringCols = other70.numClusteringCols;
  tableName = other70.tableName;
  dbName = other70.dbName;
  mysqlTable = other70.mysqlTable;
  olapTable = other70.olapTable;
  schemaTable = other70.schemaTable;
  kuduTable = other70.kuduTable;
  BrokerTable = other70.BrokerTable;
  __isset = other70.__isset;
}
TTableDescriptor& TTableDescriptor::operator=(const TTableDescriptor& other71) {
  id = other71.id;
  tableType = other71.tableType;
  numCols = other71.numCols;
  numClusteringCols = other71.numClusteringCols;
  tableName = other71.tableName;
  dbName = other71.dbName;
  mysqlTable = other71.mysqlTable;
  olapTable = other71.olapTable;
  schemaTable = other71.schemaTable;
  kuduTable = other71.kuduTable;
  BrokerTable = other71.BrokerTable;
  __isset = other71.__isset;
  return *this;
}
void TTableDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableDescriptor(";
  out << "id=" << to_string(id);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "numCols=" << to_string(numCols);
  out << ", " << "numClusteringCols=" << to_string(numClusteringCols);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "mysqlTable="; (__isset.mysqlTable ? (out << to_string(mysqlTable)) : (out << "<null>"));
  out << ", " << "olapTable="; (__isset.olapTable ? (out << to_string(olapTable)) : (out << "<null>"));
  out << ", " << "schemaTable="; (__isset.schemaTable ? (out << to_string(schemaTable)) : (out << "<null>"));
  out << ", " << "kuduTable="; (__isset.kuduTable ? (out << to_string(kuduTable)) : (out << "<null>"));
  out << ", " << "BrokerTable="; (__isset.BrokerTable ? (out << to_string(BrokerTable)) : (out << "<null>"));
  out << ")";
}


TTupleDescriptor::~TTupleDescriptor() throw() {
}


void TTupleDescriptor::__set_id(const  ::palo::TTupleId val) {
  this->id = val;
}

void TTupleDescriptor::__set_byteSize(const int32_t val) {
  this->byteSize = val;
}

void TTupleDescriptor::__set_numNullBytes(const int32_t val) {
  this->numNullBytes = val;
}

void TTupleDescriptor::__set_tableId(const  ::palo::TTableId val) {
  this->tableId = val;
__isset.tableId = true;
}

void TTupleDescriptor::__set_numNullSlots(const int32_t val) {
  this->numNullSlots = val;
__isset.numNullSlots = true;
}

uint32_t TTupleDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_byteSize = false;
  bool isset_numNullBytes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->byteSize);
          isset_byteSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numNullBytes);
          isset_numNullBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numNullSlots);
          this->__isset.numNullSlots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_byteSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNullBytes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTupleDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTupleDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->byteSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNullBytes", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->numNullBytes);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.numNullSlots) {
    xfer += oprot->writeFieldBegin("numNullSlots", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->numNullSlots);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTupleDescriptor &a, TTupleDescriptor &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.byteSize, b.byteSize);
  swap(a.numNullBytes, b.numNullBytes);
  swap(a.tableId, b.tableId);
  swap(a.numNullSlots, b.numNullSlots);
  swap(a.__isset, b.__isset);
}

TTupleDescriptor::TTupleDescriptor(const TTupleDescriptor& other72) {
  id = other72.id;
  byteSize = other72.byteSize;
  numNullBytes = other72.numNullBytes;
  tableId = other72.tableId;
  numNullSlots = other72.numNullSlots;
  __isset = other72.__isset;
}
TTupleDescriptor& TTupleDescriptor::operator=(const TTupleDescriptor& other73) {
  id = other73.id;
  byteSize = other73.byteSize;
  numNullBytes = other73.numNullBytes;
  tableId = other73.tableId;
  numNullSlots = other73.numNullSlots;
  __isset = other73.__isset;
  return *this;
}
void TTupleDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTupleDescriptor(";
  out << "id=" << to_string(id);
  out << ", " << "byteSize=" << to_string(byteSize);
  out << ", " << "numNullBytes=" << to_string(numNullBytes);
  out << ", " << "tableId="; (__isset.tableId ? (out << to_string(tableId)) : (out << "<null>"));
  out << ", " << "numNullSlots="; (__isset.numNullSlots ? (out << to_string(numNullSlots)) : (out << "<null>"));
  out << ")";
}


TDescriptorTable::~TDescriptorTable() throw() {
}


void TDescriptorTable::__set_slotDescriptors(const std::vector<TSlotDescriptor> & val) {
  this->slotDescriptors = val;
__isset.slotDescriptors = true;
}

void TDescriptorTable::__set_tupleDescriptors(const std::vector<TTupleDescriptor> & val) {
  this->tupleDescriptors = val;
}

void TDescriptorTable::__set_tableDescriptors(const std::vector<TTableDescriptor> & val) {
  this->tableDescriptors = val;
__isset.tableDescriptors = true;
}

uint32_t TDescriptorTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tupleDescriptors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->slotDescriptors.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->slotDescriptors.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += this->slotDescriptors[_i78].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.slotDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tupleDescriptors.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->tupleDescriptors.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += this->tupleDescriptors[_i83].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tupleDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableDescriptors.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->tableDescriptors.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->tableDescriptors[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tableDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tupleDescriptors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDescriptorTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescriptorTable");

  if (this->__isset.slotDescriptors) {
    xfer += oprot->writeFieldBegin("slotDescriptors", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->slotDescriptors.size()));
      std::vector<TSlotDescriptor> ::const_iterator _iter89;
      for (_iter89 = this->slotDescriptors.begin(); _iter89 != this->slotDescriptors.end(); ++_iter89)
      {
        xfer += (*_iter89).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tupleDescriptors", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tupleDescriptors.size()));
    std::vector<TTupleDescriptor> ::const_iterator _iter90;
    for (_iter90 = this->tupleDescriptors.begin(); _iter90 != this->tupleDescriptors.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableDescriptors) {
    xfer += oprot->writeFieldBegin("tableDescriptors", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableDescriptors.size()));
      std::vector<TTableDescriptor> ::const_iterator _iter91;
      for (_iter91 = this->tableDescriptors.begin(); _iter91 != this->tableDescriptors.end(); ++_iter91)
      {
        xfer += (*_iter91).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDescriptorTable &a, TDescriptorTable &b) {
  using ::std::swap;
  swap(a.slotDescriptors, b.slotDescriptors);
  swap(a.tupleDescriptors, b.tupleDescriptors);
  swap(a.tableDescriptors, b.tableDescriptors);
  swap(a.__isset, b.__isset);
}

TDescriptorTable::TDescriptorTable(const TDescriptorTable& other92) {
  slotDescriptors = other92.slotDescriptors;
  tupleDescriptors = other92.tupleDescriptors;
  tableDescriptors = other92.tableDescriptors;
  __isset = other92.__isset;
}
TDescriptorTable& TDescriptorTable::operator=(const TDescriptorTable& other93) {
  slotDescriptors = other93.slotDescriptors;
  tupleDescriptors = other93.tupleDescriptors;
  tableDescriptors = other93.tableDescriptors;
  __isset = other93.__isset;
  return *this;
}
void TDescriptorTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDescriptorTable(";
  out << "slotDescriptors="; (__isset.slotDescriptors ? (out << to_string(slotDescriptors)) : (out << "<null>"));
  out << ", " << "tupleDescriptors=" << to_string(tupleDescriptors);
  out << ", " << "tableDescriptors="; (__isset.tableDescriptors ? (out << to_string(tableDescriptors)) : (out << "<null>"));
  out << ")";
}

} // namespace
