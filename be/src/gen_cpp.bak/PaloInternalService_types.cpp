/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "PaloInternalService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace palo {

int _kTQueryTypeValues[] = {
  TQueryType::SELECT,
  TQueryType::LOAD
};
const char* _kTQueryTypeNames[] = {
  "SELECT",
  "LOAD"
};
const std::map<int, const char*> _TQueryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTQueryTypeValues, _kTQueryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTErrorHubTypeValues[] = {
  TErrorHubType::MYSQL,
  TErrorHubType::NULL_TYPE
};
const char* _kTErrorHubTypeNames[] = {
  "MYSQL",
  "NULL_TYPE"
};
const std::map<int, const char*> _TErrorHubType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTErrorHubTypeValues, _kTErrorHubTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPaloInternalServiceVersionValues[] = {
  PaloInternalServiceVersion::V1
};
const char* _kPaloInternalServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _PaloInternalServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kPaloInternalServiceVersionValues, _kPaloInternalServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TMysqlErrorHubInfo::~TMysqlErrorHubInfo() throw() {
}


void TMysqlErrorHubInfo::__set_host(const std::string& val) {
  this->host = val;
}

void TMysqlErrorHubInfo::__set_port(const int32_t val) {
  this->port = val;
}

void TMysqlErrorHubInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TMysqlErrorHubInfo::__set_passwd(const std::string& val) {
  this->passwd = val;
}

void TMysqlErrorHubInfo::__set_db(const std::string& val) {
  this->db = val;
}

void TMysqlErrorHubInfo::__set_table(const std::string& val) {
  this->table = val;
}

uint32_t TMysqlErrorHubInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host = false;
  bool isset_port = false;
  bool isset_user = false;
  bool isset_passwd = false;
  bool isset_db = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          isset_passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_passwd)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMysqlErrorHubInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMysqlErrorHubInfo");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMysqlErrorHubInfo &a, TMysqlErrorHubInfo &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.db, b.db);
  swap(a.table, b.table);
}

TMysqlErrorHubInfo::TMysqlErrorHubInfo(const TMysqlErrorHubInfo& other0) {
  host = other0.host;
  port = other0.port;
  user = other0.user;
  passwd = other0.passwd;
  db = other0.db;
  table = other0.table;
}
TMysqlErrorHubInfo& TMysqlErrorHubInfo::operator=(const TMysqlErrorHubInfo& other1) {
  host = other1.host;
  port = other1.port;
  user = other1.user;
  passwd = other1.passwd;
  db = other1.db;
  table = other1.table;
  return *this;
}
void TMysqlErrorHubInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMysqlErrorHubInfo(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ", " << "user=" << to_string(user);
  out << ", " << "passwd=" << to_string(passwd);
  out << ", " << "db=" << to_string(db);
  out << ", " << "table=" << to_string(table);
  out << ")";
}


TLoadErrorHubInfo::~TLoadErrorHubInfo() throw() {
}


void TLoadErrorHubInfo::__set_type(const TErrorHubType::type val) {
  this->type = val;
}

void TLoadErrorHubInfo::__set_mysql_info(const TMysqlErrorHubInfo& val) {
  this->mysql_info = val;
__isset.mysql_info = true;
}

uint32_t TLoadErrorHubInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->type = (TErrorHubType::type)ecast2;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mysql_info.read(iprot);
          this->__isset.mysql_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLoadErrorHubInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLoadErrorHubInfo");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mysql_info) {
    xfer += oprot->writeFieldBegin("mysql_info", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->mysql_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLoadErrorHubInfo &a, TLoadErrorHubInfo &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.mysql_info, b.mysql_info);
  swap(a.__isset, b.__isset);
}

TLoadErrorHubInfo::TLoadErrorHubInfo(const TLoadErrorHubInfo& other3) {
  type = other3.type;
  mysql_info = other3.mysql_info;
  __isset = other3.__isset;
}
TLoadErrorHubInfo& TLoadErrorHubInfo::operator=(const TLoadErrorHubInfo& other4) {
  type = other4.type;
  mysql_info = other4.mysql_info;
  __isset = other4.__isset;
  return *this;
}
void TLoadErrorHubInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLoadErrorHubInfo(";
  out << "type=" << to_string(type);
  out << ", " << "mysql_info="; (__isset.mysql_info ? (out << to_string(mysql_info)) : (out << "<null>"));
  out << ")";
}


TQueryOptions::~TQueryOptions() throw() {
}


void TQueryOptions::__set_abort_on_error(const bool val) {
  this->abort_on_error = val;
__isset.abort_on_error = true;
}

void TQueryOptions::__set_max_errors(const int32_t val) {
  this->max_errors = val;
__isset.max_errors = true;
}

void TQueryOptions::__set_disable_codegen(const bool val) {
  this->disable_codegen = val;
__isset.disable_codegen = true;
}

void TQueryOptions::__set_batch_size(const int32_t val) {
  this->batch_size = val;
__isset.batch_size = true;
}

void TQueryOptions::__set_num_nodes(const int32_t val) {
  this->num_nodes = val;
__isset.num_nodes = true;
}

void TQueryOptions::__set_max_scan_range_length(const int64_t val) {
  this->max_scan_range_length = val;
__isset.max_scan_range_length = true;
}

void TQueryOptions::__set_num_scanner_threads(const int32_t val) {
  this->num_scanner_threads = val;
__isset.num_scanner_threads = true;
}

void TQueryOptions::__set_max_io_buffers(const int32_t val) {
  this->max_io_buffers = val;
__isset.max_io_buffers = true;
}

void TQueryOptions::__set_allow_unsupported_formats(const bool val) {
  this->allow_unsupported_formats = val;
__isset.allow_unsupported_formats = true;
}

void TQueryOptions::__set_default_order_by_limit(const int64_t val) {
  this->default_order_by_limit = val;
__isset.default_order_by_limit = true;
}

void TQueryOptions::__set_debug_action(const std::string& val) {
  this->debug_action = val;
__isset.debug_action = true;
}

void TQueryOptions::__set_mem_limit(const int64_t val) {
  this->mem_limit = val;
__isset.mem_limit = true;
}

void TQueryOptions::__set_abort_on_default_limit_exceeded(const bool val) {
  this->abort_on_default_limit_exceeded = val;
__isset.abort_on_default_limit_exceeded = true;
}

void TQueryOptions::__set_query_timeout(const int32_t val) {
  this->query_timeout = val;
__isset.query_timeout = true;
}

void TQueryOptions::__set_is_report_success(const bool val) {
  this->is_report_success = val;
__isset.is_report_success = true;
}

void TQueryOptions::__set_codegen_level(const int32_t val) {
  this->codegen_level = val;
__isset.codegen_level = true;
}

void TQueryOptions::__set_kudu_latest_observed_ts(const int64_t val) {
  this->kudu_latest_observed_ts = val;
__isset.kudu_latest_observed_ts = true;
}

void TQueryOptions::__set_query_type(const TQueryType::type val) {
  this->query_type = val;
__isset.query_type = true;
}

uint32_t TQueryOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abort_on_error);
          this->__isset.abort_on_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_errors);
          this->__isset.max_errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->disable_codegen);
          this->__isset.disable_codegen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batch_size);
          this->__isset.batch_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_nodes);
          this->__isset.num_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_scan_range_length);
          this->__isset.max_scan_range_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_scanner_threads);
          this->__isset.num_scanner_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_io_buffers);
          this->__isset.max_io_buffers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->allow_unsupported_formats);
          this->__isset.allow_unsupported_formats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->default_order_by_limit);
          this->__isset.default_order_by_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->debug_action);
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_limit);
          this->__isset.mem_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abort_on_default_limit_exceeded);
          this->__isset.abort_on_default_limit_exceeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->query_timeout);
          this->__isset.query_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_report_success);
          this->__isset.is_report_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->codegen_level);
          this->__isset.codegen_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->kudu_latest_observed_ts);
          this->__isset.kudu_latest_observed_ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->query_type = (TQueryType::type)ecast5;
          this->__isset.query_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryOptions");

  if (this->__isset.abort_on_error) {
    xfer += oprot->writeFieldBegin("abort_on_error", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->abort_on_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_errors) {
    xfer += oprot->writeFieldBegin("max_errors", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->max_errors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disable_codegen) {
    xfer += oprot->writeFieldBegin("disable_codegen", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->disable_codegen);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batch_size) {
    xfer += oprot->writeFieldBegin("batch_size", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->batch_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_nodes) {
    xfer += oprot->writeFieldBegin("num_nodes", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->num_nodes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_scan_range_length) {
    xfer += oprot->writeFieldBegin("max_scan_range_length", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->max_scan_range_length);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_scanner_threads) {
    xfer += oprot->writeFieldBegin("num_scanner_threads", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->num_scanner_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_io_buffers) {
    xfer += oprot->writeFieldBegin("max_io_buffers", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->max_io_buffers);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.allow_unsupported_formats) {
    xfer += oprot->writeFieldBegin("allow_unsupported_formats", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->allow_unsupported_formats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_order_by_limit) {
    xfer += oprot->writeFieldBegin("default_order_by_limit", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->default_order_by_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mem_limit) {
    xfer += oprot->writeFieldBegin("mem_limit", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->mem_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.abort_on_default_limit_exceeded) {
    xfer += oprot->writeFieldBegin("abort_on_default_limit_exceeded", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->abort_on_default_limit_exceeded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_timeout) {
    xfer += oprot->writeFieldBegin("query_timeout", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->query_timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_report_success) {
    xfer += oprot->writeFieldBegin("is_report_success", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->is_report_success);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.codegen_level) {
    xfer += oprot->writeFieldBegin("codegen_level", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->codegen_level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_latest_observed_ts) {
    xfer += oprot->writeFieldBegin("kudu_latest_observed_ts", ::apache::thrift::protocol::T_I64, 17);
    xfer += oprot->writeI64(this->kudu_latest_observed_ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_type) {
    xfer += oprot->writeFieldBegin("query_type", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->query_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryOptions &a, TQueryOptions &b) {
  using ::std::swap;
  swap(a.abort_on_error, b.abort_on_error);
  swap(a.max_errors, b.max_errors);
  swap(a.disable_codegen, b.disable_codegen);
  swap(a.batch_size, b.batch_size);
  swap(a.num_nodes, b.num_nodes);
  swap(a.max_scan_range_length, b.max_scan_range_length);
  swap(a.num_scanner_threads, b.num_scanner_threads);
  swap(a.max_io_buffers, b.max_io_buffers);
  swap(a.allow_unsupported_formats, b.allow_unsupported_formats);
  swap(a.default_order_by_limit, b.default_order_by_limit);
  swap(a.debug_action, b.debug_action);
  swap(a.mem_limit, b.mem_limit);
  swap(a.abort_on_default_limit_exceeded, b.abort_on_default_limit_exceeded);
  swap(a.query_timeout, b.query_timeout);
  swap(a.is_report_success, b.is_report_success);
  swap(a.codegen_level, b.codegen_level);
  swap(a.kudu_latest_observed_ts, b.kudu_latest_observed_ts);
  swap(a.query_type, b.query_type);
  swap(a.__isset, b.__isset);
}

TQueryOptions::TQueryOptions(const TQueryOptions& other6) {
  abort_on_error = other6.abort_on_error;
  max_errors = other6.max_errors;
  disable_codegen = other6.disable_codegen;
  batch_size = other6.batch_size;
  num_nodes = other6.num_nodes;
  max_scan_range_length = other6.max_scan_range_length;
  num_scanner_threads = other6.num_scanner_threads;
  max_io_buffers = other6.max_io_buffers;
  allow_unsupported_formats = other6.allow_unsupported_formats;
  default_order_by_limit = other6.default_order_by_limit;
  debug_action = other6.debug_action;
  mem_limit = other6.mem_limit;
  abort_on_default_limit_exceeded = other6.abort_on_default_limit_exceeded;
  query_timeout = other6.query_timeout;
  is_report_success = other6.is_report_success;
  codegen_level = other6.codegen_level;
  kudu_latest_observed_ts = other6.kudu_latest_observed_ts;
  query_type = other6.query_type;
  __isset = other6.__isset;
}
TQueryOptions& TQueryOptions::operator=(const TQueryOptions& other7) {
  abort_on_error = other7.abort_on_error;
  max_errors = other7.max_errors;
  disable_codegen = other7.disable_codegen;
  batch_size = other7.batch_size;
  num_nodes = other7.num_nodes;
  max_scan_range_length = other7.max_scan_range_length;
  num_scanner_threads = other7.num_scanner_threads;
  max_io_buffers = other7.max_io_buffers;
  allow_unsupported_formats = other7.allow_unsupported_formats;
  default_order_by_limit = other7.default_order_by_limit;
  debug_action = other7.debug_action;
  mem_limit = other7.mem_limit;
  abort_on_default_limit_exceeded = other7.abort_on_default_limit_exceeded;
  query_timeout = other7.query_timeout;
  is_report_success = other7.is_report_success;
  codegen_level = other7.codegen_level;
  kudu_latest_observed_ts = other7.kudu_latest_observed_ts;
  query_type = other7.query_type;
  __isset = other7.__isset;
  return *this;
}
void TQueryOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryOptions(";
  out << "abort_on_error="; (__isset.abort_on_error ? (out << to_string(abort_on_error)) : (out << "<null>"));
  out << ", " << "max_errors="; (__isset.max_errors ? (out << to_string(max_errors)) : (out << "<null>"));
  out << ", " << "disable_codegen="; (__isset.disable_codegen ? (out << to_string(disable_codegen)) : (out << "<null>"));
  out << ", " << "batch_size="; (__isset.batch_size ? (out << to_string(batch_size)) : (out << "<null>"));
  out << ", " << "num_nodes="; (__isset.num_nodes ? (out << to_string(num_nodes)) : (out << "<null>"));
  out << ", " << "max_scan_range_length="; (__isset.max_scan_range_length ? (out << to_string(max_scan_range_length)) : (out << "<null>"));
  out << ", " << "num_scanner_threads="; (__isset.num_scanner_threads ? (out << to_string(num_scanner_threads)) : (out << "<null>"));
  out << ", " << "max_io_buffers="; (__isset.max_io_buffers ? (out << to_string(max_io_buffers)) : (out << "<null>"));
  out << ", " << "allow_unsupported_formats="; (__isset.allow_unsupported_formats ? (out << to_string(allow_unsupported_formats)) : (out << "<null>"));
  out << ", " << "default_order_by_limit="; (__isset.default_order_by_limit ? (out << to_string(default_order_by_limit)) : (out << "<null>"));
  out << ", " << "debug_action="; (__isset.debug_action ? (out << to_string(debug_action)) : (out << "<null>"));
  out << ", " << "mem_limit="; (__isset.mem_limit ? (out << to_string(mem_limit)) : (out << "<null>"));
  out << ", " << "abort_on_default_limit_exceeded="; (__isset.abort_on_default_limit_exceeded ? (out << to_string(abort_on_default_limit_exceeded)) : (out << "<null>"));
  out << ", " << "query_timeout="; (__isset.query_timeout ? (out << to_string(query_timeout)) : (out << "<null>"));
  out << ", " << "is_report_success="; (__isset.is_report_success ? (out << to_string(is_report_success)) : (out << "<null>"));
  out << ", " << "codegen_level="; (__isset.codegen_level ? (out << to_string(codegen_level)) : (out << "<null>"));
  out << ", " << "kudu_latest_observed_ts="; (__isset.kudu_latest_observed_ts ? (out << to_string(kudu_latest_observed_ts)) : (out << "<null>"));
  out << ", " << "query_type="; (__isset.query_type ? (out << to_string(query_type)) : (out << "<null>"));
  out << ")";
}


TScanRangeParams::~TScanRangeParams() throw() {
}


void TScanRangeParams::__set_scan_range(const  ::palo::TScanRange& val) {
  this->scan_range = val;
}

void TScanRangeParams::__set_volume_id(const int32_t val) {
  this->volume_id = val;
__isset.volume_id = true;
}

uint32_t TScanRangeParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scan_range = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scan_range.read(iprot);
          isset_scan_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->volume_id);
          this->__isset.volume_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scan_range)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScanRangeParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScanRangeParams");

  xfer += oprot->writeFieldBegin("scan_range", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->scan_range.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.volume_id) {
    xfer += oprot->writeFieldBegin("volume_id", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->volume_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScanRangeParams &a, TScanRangeParams &b) {
  using ::std::swap;
  swap(a.scan_range, b.scan_range);
  swap(a.volume_id, b.volume_id);
  swap(a.__isset, b.__isset);
}

TScanRangeParams::TScanRangeParams(const TScanRangeParams& other8) {
  scan_range = other8.scan_range;
  volume_id = other8.volume_id;
  __isset = other8.__isset;
}
TScanRangeParams& TScanRangeParams::operator=(const TScanRangeParams& other9) {
  scan_range = other9.scan_range;
  volume_id = other9.volume_id;
  __isset = other9.__isset;
  return *this;
}
void TScanRangeParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScanRangeParams(";
  out << "scan_range=" << to_string(scan_range);
  out << ", " << "volume_id="; (__isset.volume_id ? (out << to_string(volume_id)) : (out << "<null>"));
  out << ")";
}


TPlanFragmentDestination::~TPlanFragmentDestination() throw() {
}


void TPlanFragmentDestination::__set_fragment_instance_id(const  ::palo::TUniqueId& val) {
  this->fragment_instance_id = val;
}

void TPlanFragmentDestination::__set_server(const  ::palo::TNetworkAddress& val) {
  this->server = val;
}

uint32_t TPlanFragmentDestination::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fragment_instance_id = false;
  bool isset_server = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->server.read(iprot);
          isset_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_server)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanFragmentDestination::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanFragmentDestination");

  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->server.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanFragmentDestination &a, TPlanFragmentDestination &b) {
  using ::std::swap;
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.server, b.server);
}

TPlanFragmentDestination::TPlanFragmentDestination(const TPlanFragmentDestination& other10) {
  fragment_instance_id = other10.fragment_instance_id;
  server = other10.server;
}
TPlanFragmentDestination& TPlanFragmentDestination::operator=(const TPlanFragmentDestination& other11) {
  fragment_instance_id = other11.fragment_instance_id;
  server = other11.server;
  return *this;
}
void TPlanFragmentDestination::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanFragmentDestination(";
  out << "fragment_instance_id=" << to_string(fragment_instance_id);
  out << ", " << "server=" << to_string(server);
  out << ")";
}


TPlanFragmentExecParams::~TPlanFragmentExecParams() throw() {
}


void TPlanFragmentExecParams::__set_query_id(const  ::palo::TUniqueId& val) {
  this->query_id = val;
}

void TPlanFragmentExecParams::__set_fragment_instance_id(const  ::palo::TUniqueId& val) {
  this->fragment_instance_id = val;
}

void TPlanFragmentExecParams::__set_per_node_scan_ranges(const std::map< ::palo::TPlanNodeId, std::vector<TScanRangeParams> > & val) {
  this->per_node_scan_ranges = val;
}

void TPlanFragmentExecParams::__set_per_exch_num_senders(const std::map< ::palo::TPlanNodeId, int32_t> & val) {
  this->per_exch_num_senders = val;
}

void TPlanFragmentExecParams::__set_destinations(const std::vector<TPlanFragmentDestination> & val) {
  this->destinations = val;
}

void TPlanFragmentExecParams::__set_debug_node_id(const  ::palo::TPlanNodeId val) {
  this->debug_node_id = val;
__isset.debug_node_id = true;
}

void TPlanFragmentExecParams::__set_debug_phase(const  ::palo::TExecNodePhase::type val) {
  this->debug_phase = val;
__isset.debug_phase = true;
}

void TPlanFragmentExecParams::__set_debug_action(const  ::palo::TDebugAction::type val) {
  this->debug_action = val;
__isset.debug_action = true;
}

void TPlanFragmentExecParams::__set_sender_id(const int32_t val) {
  this->sender_id = val;
__isset.sender_id = true;
}

uint32_t TPlanFragmentExecParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_query_id = false;
  bool isset_fragment_instance_id = false;
  bool isset_per_node_scan_ranges = false;
  bool isset_per_exch_num_senders = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_id.read(iprot);
          isset_query_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_node_scan_ranges.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            xfer += iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
               ::palo::TPlanNodeId _key17;
              xfer += iprot->readI32(_key17);
              std::vector<TScanRangeParams> & _val18 = this->per_node_scan_ranges[_key17];
              {
                _val18.clear();
                uint32_t _size19;
                ::apache::thrift::protocol::TType _etype22;
                xfer += iprot->readListBegin(_etype22, _size19);
                _val18.resize(_size19);
                uint32_t _i23;
                for (_i23 = 0; _i23 < _size19; ++_i23)
                {
                  xfer += _val18[_i23].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_per_node_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_exch_num_senders.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            xfer += iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
               ::palo::TPlanNodeId _key29;
              xfer += iprot->readI32(_key29);
              int32_t& _val30 = this->per_exch_num_senders[_key29];
              xfer += iprot->readI32(_val30);
            }
            xfer += iprot->readMapEnd();
          }
          isset_per_exch_num_senders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->destinations.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->destinations.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->destinations[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.destinations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->debug_node_id);
          this->__isset.debug_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast36;
          xfer += iprot->readI32(ecast36);
          this->debug_phase = ( ::palo::TExecNodePhase::type)ecast36;
          this->__isset.debug_phase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast37;
          xfer += iprot->readI32(ecast37);
          this->debug_action = ( ::palo::TDebugAction::type)ecast37;
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sender_id);
          this->__isset.sender_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_query_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_node_scan_ranges)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_exch_num_senders)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanFragmentExecParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanFragmentExecParams");

  xfer += oprot->writeFieldBegin("query_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->query_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("per_node_scan_ranges", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->per_node_scan_ranges.size()));
    std::map< ::palo::TPlanNodeId, std::vector<TScanRangeParams> > ::const_iterator _iter38;
    for (_iter38 = this->per_node_scan_ranges.begin(); _iter38 != this->per_node_scan_ranges.end(); ++_iter38)
    {
      xfer += oprot->writeI32(_iter38->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter38->second.size()));
        std::vector<TScanRangeParams> ::const_iterator _iter39;
        for (_iter39 = _iter38->second.begin(); _iter39 != _iter38->second.end(); ++_iter39)
        {
          xfer += (*_iter39).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("per_exch_num_senders", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->per_exch_num_senders.size()));
    std::map< ::palo::TPlanNodeId, int32_t> ::const_iterator _iter40;
    for (_iter40 = this->per_exch_num_senders.begin(); _iter40 != this->per_exch_num_senders.end(); ++_iter40)
    {
      xfer += oprot->writeI32(_iter40->first);
      xfer += oprot->writeI32(_iter40->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destinations", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->destinations.size()));
    std::vector<TPlanFragmentDestination> ::const_iterator _iter41;
    for (_iter41 = this->destinations.begin(); _iter41 != this->destinations.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.debug_node_id) {
    xfer += oprot->writeFieldBegin("debug_node_id", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->debug_node_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_phase) {
    xfer += oprot->writeFieldBegin("debug_phase", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->debug_phase);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sender_id) {
    xfer += oprot->writeFieldBegin("sender_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->sender_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanFragmentExecParams &a, TPlanFragmentExecParams &b) {
  using ::std::swap;
  swap(a.query_id, b.query_id);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.per_node_scan_ranges, b.per_node_scan_ranges);
  swap(a.per_exch_num_senders, b.per_exch_num_senders);
  swap(a.destinations, b.destinations);
  swap(a.debug_node_id, b.debug_node_id);
  swap(a.debug_phase, b.debug_phase);
  swap(a.debug_action, b.debug_action);
  swap(a.sender_id, b.sender_id);
  swap(a.__isset, b.__isset);
}

TPlanFragmentExecParams::TPlanFragmentExecParams(const TPlanFragmentExecParams& other42) {
  query_id = other42.query_id;
  fragment_instance_id = other42.fragment_instance_id;
  per_node_scan_ranges = other42.per_node_scan_ranges;
  per_exch_num_senders = other42.per_exch_num_senders;
  destinations = other42.destinations;
  debug_node_id = other42.debug_node_id;
  debug_phase = other42.debug_phase;
  debug_action = other42.debug_action;
  sender_id = other42.sender_id;
  __isset = other42.__isset;
}
TPlanFragmentExecParams& TPlanFragmentExecParams::operator=(const TPlanFragmentExecParams& other43) {
  query_id = other43.query_id;
  fragment_instance_id = other43.fragment_instance_id;
  per_node_scan_ranges = other43.per_node_scan_ranges;
  per_exch_num_senders = other43.per_exch_num_senders;
  destinations = other43.destinations;
  debug_node_id = other43.debug_node_id;
  debug_phase = other43.debug_phase;
  debug_action = other43.debug_action;
  sender_id = other43.sender_id;
  __isset = other43.__isset;
  return *this;
}
void TPlanFragmentExecParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanFragmentExecParams(";
  out << "query_id=" << to_string(query_id);
  out << ", " << "fragment_instance_id=" << to_string(fragment_instance_id);
  out << ", " << "per_node_scan_ranges=" << to_string(per_node_scan_ranges);
  out << ", " << "per_exch_num_senders=" << to_string(per_exch_num_senders);
  out << ", " << "destinations=" << to_string(destinations);
  out << ", " << "debug_node_id="; (__isset.debug_node_id ? (out << to_string(debug_node_id)) : (out << "<null>"));
  out << ", " << "debug_phase="; (__isset.debug_phase ? (out << to_string(debug_phase)) : (out << "<null>"));
  out << ", " << "debug_action="; (__isset.debug_action ? (out << to_string(debug_action)) : (out << "<null>"));
  out << ", " << "sender_id="; (__isset.sender_id ? (out << to_string(sender_id)) : (out << "<null>"));
  out << ")";
}


TQueryGlobals::~TQueryGlobals() throw() {
}


void TQueryGlobals::__set_now_string(const std::string& val) {
  this->now_string = val;
}

uint32_t TQueryGlobals::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_now_string = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->now_string);
          isset_now_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_now_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TQueryGlobals::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryGlobals");

  xfer += oprot->writeFieldBegin("now_string", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->now_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryGlobals &a, TQueryGlobals &b) {
  using ::std::swap;
  swap(a.now_string, b.now_string);
}

TQueryGlobals::TQueryGlobals(const TQueryGlobals& other44) {
  now_string = other44.now_string;
}
TQueryGlobals& TQueryGlobals::operator=(const TQueryGlobals& other45) {
  now_string = other45.now_string;
  return *this;
}
void TQueryGlobals::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryGlobals(";
  out << "now_string=" << to_string(now_string);
  out << ")";
}


TExecPlanFragmentParams::~TExecPlanFragmentParams() throw() {
}


void TExecPlanFragmentParams::__set_protocol_version(const PaloInternalServiceVersion::type val) {
  this->protocol_version = val;
}

void TExecPlanFragmentParams::__set_fragment(const  ::palo::TPlanFragment& val) {
  this->fragment = val;
__isset.fragment = true;
}

void TExecPlanFragmentParams::__set_desc_tbl(const  ::palo::TDescriptorTable& val) {
  this->desc_tbl = val;
__isset.desc_tbl = true;
}

void TExecPlanFragmentParams::__set_params(const TPlanFragmentExecParams& val) {
  this->params = val;
__isset.params = true;
}

void TExecPlanFragmentParams::__set_coord(const  ::palo::TNetworkAddress& val) {
  this->coord = val;
__isset.coord = true;
}

void TExecPlanFragmentParams::__set_backend_num(const int32_t val) {
  this->backend_num = val;
__isset.backend_num = true;
}

void TExecPlanFragmentParams::__set_query_globals(const TQueryGlobals& val) {
  this->query_globals = val;
__isset.query_globals = true;
}

void TExecPlanFragmentParams::__set_query_options(const TQueryOptions& val) {
  this->query_options = val;
__isset.query_options = true;
}

void TExecPlanFragmentParams::__set_is_report_success(const bool val) {
  this->is_report_success = val;
__isset.is_report_success = true;
}

void TExecPlanFragmentParams::__set_resource_info(const  ::palo::TResourceInfo& val) {
  this->resource_info = val;
__isset.resource_info = true;
}

void TExecPlanFragmentParams::__set_import_label(const std::string& val) {
  this->import_label = val;
__isset.import_label = true;
}

void TExecPlanFragmentParams::__set_db_name(const std::string& val) {
  this->db_name = val;
__isset.db_name = true;
}

void TExecPlanFragmentParams::__set_load_job_id(const int64_t val) {
  this->load_job_id = val;
__isset.load_job_id = true;
}

void TExecPlanFragmentParams::__set_load_error_hub_info(const TLoadErrorHubInfo& val) {
  this->load_error_hub_info = val;
__isset.load_error_hub_info = true;
}

uint32_t TExecPlanFragmentParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast46;
          xfer += iprot->readI32(ecast46);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast46;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment.read(iprot);
          this->__isset.fragment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->desc_tbl.read(iprot);
          this->__isset.desc_tbl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->coord.read(iprot);
          this->__isset.coord = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backend_num);
          this->__isset.backend_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_globals.read(iprot);
          this->__isset.query_globals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_options.read(iprot);
          this->__isset.query_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_report_success);
          this->__isset.is_report_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_info.read(iprot);
          this->__isset.resource_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->import_label);
          this->__isset.import_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->load_job_id);
          this->__isset.load_job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_error_hub_info.read(iprot);
          this->__isset.load_error_hub_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecPlanFragmentParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecPlanFragmentParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fragment) {
    xfer += oprot->writeFieldBegin("fragment", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fragment.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.desc_tbl) {
    xfer += oprot->writeFieldBegin("desc_tbl", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->desc_tbl.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.params) {
    xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.coord) {
    xfer += oprot->writeFieldBegin("coord", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->coord.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backend_num) {
    xfer += oprot->writeFieldBegin("backend_num", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->backend_num);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_globals) {
    xfer += oprot->writeFieldBegin("query_globals", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->query_globals.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_options) {
    xfer += oprot->writeFieldBegin("query_options", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->query_options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_report_success) {
    xfer += oprot->writeFieldBegin("is_report_success", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_report_success);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_info) {
    xfer += oprot->writeFieldBegin("resource_info", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->resource_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.import_label) {
    xfer += oprot->writeFieldBegin("import_label", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->import_label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.load_job_id) {
    xfer += oprot->writeFieldBegin("load_job_id", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->load_job_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.load_error_hub_info) {
    xfer += oprot->writeFieldBegin("load_error_hub_info", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->load_error_hub_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecPlanFragmentParams &a, TExecPlanFragmentParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment, b.fragment);
  swap(a.desc_tbl, b.desc_tbl);
  swap(a.params, b.params);
  swap(a.coord, b.coord);
  swap(a.backend_num, b.backend_num);
  swap(a.query_globals, b.query_globals);
  swap(a.query_options, b.query_options);
  swap(a.is_report_success, b.is_report_success);
  swap(a.resource_info, b.resource_info);
  swap(a.import_label, b.import_label);
  swap(a.db_name, b.db_name);
  swap(a.load_job_id, b.load_job_id);
  swap(a.load_error_hub_info, b.load_error_hub_info);
  swap(a.__isset, b.__isset);
}

TExecPlanFragmentParams::TExecPlanFragmentParams(const TExecPlanFragmentParams& other47) {
  protocol_version = other47.protocol_version;
  fragment = other47.fragment;
  desc_tbl = other47.desc_tbl;
  params = other47.params;
  coord = other47.coord;
  backend_num = other47.backend_num;
  query_globals = other47.query_globals;
  query_options = other47.query_options;
  is_report_success = other47.is_report_success;
  resource_info = other47.resource_info;
  import_label = other47.import_label;
  db_name = other47.db_name;
  load_job_id = other47.load_job_id;
  load_error_hub_info = other47.load_error_hub_info;
  __isset = other47.__isset;
}
TExecPlanFragmentParams& TExecPlanFragmentParams::operator=(const TExecPlanFragmentParams& other48) {
  protocol_version = other48.protocol_version;
  fragment = other48.fragment;
  desc_tbl = other48.desc_tbl;
  params = other48.params;
  coord = other48.coord;
  backend_num = other48.backend_num;
  query_globals = other48.query_globals;
  query_options = other48.query_options;
  is_report_success = other48.is_report_success;
  resource_info = other48.resource_info;
  import_label = other48.import_label;
  db_name = other48.db_name;
  load_job_id = other48.load_job_id;
  load_error_hub_info = other48.load_error_hub_info;
  __isset = other48.__isset;
  return *this;
}
void TExecPlanFragmentParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecPlanFragmentParams(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "fragment="; (__isset.fragment ? (out << to_string(fragment)) : (out << "<null>"));
  out << ", " << "desc_tbl="; (__isset.desc_tbl ? (out << to_string(desc_tbl)) : (out << "<null>"));
  out << ", " << "params="; (__isset.params ? (out << to_string(params)) : (out << "<null>"));
  out << ", " << "coord="; (__isset.coord ? (out << to_string(coord)) : (out << "<null>"));
  out << ", " << "backend_num="; (__isset.backend_num ? (out << to_string(backend_num)) : (out << "<null>"));
  out << ", " << "query_globals="; (__isset.query_globals ? (out << to_string(query_globals)) : (out << "<null>"));
  out << ", " << "query_options="; (__isset.query_options ? (out << to_string(query_options)) : (out << "<null>"));
  out << ", " << "is_report_success="; (__isset.is_report_success ? (out << to_string(is_report_success)) : (out << "<null>"));
  out << ", " << "resource_info="; (__isset.resource_info ? (out << to_string(resource_info)) : (out << "<null>"));
  out << ", " << "import_label="; (__isset.import_label ? (out << to_string(import_label)) : (out << "<null>"));
  out << ", " << "db_name="; (__isset.db_name ? (out << to_string(db_name)) : (out << "<null>"));
  out << ", " << "load_job_id="; (__isset.load_job_id ? (out << to_string(load_job_id)) : (out << "<null>"));
  out << ", " << "load_error_hub_info="; (__isset.load_error_hub_info ? (out << to_string(load_error_hub_info)) : (out << "<null>"));
  out << ")";
}


TExecPlanFragmentResult::~TExecPlanFragmentResult() throw() {
}


void TExecPlanFragmentResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

uint32_t TExecPlanFragmentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TExecPlanFragmentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecPlanFragmentResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecPlanFragmentResult &a, TExecPlanFragmentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TExecPlanFragmentResult::TExecPlanFragmentResult(const TExecPlanFragmentResult& other49) {
  status = other49.status;
  __isset = other49.__isset;
}
TExecPlanFragmentResult& TExecPlanFragmentResult::operator=(const TExecPlanFragmentResult& other50) {
  status = other50.status;
  __isset = other50.__isset;
  return *this;
}
void TExecPlanFragmentResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecPlanFragmentResult(";
  out << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


TCancelPlanFragmentParams::~TCancelPlanFragmentParams() throw() {
}


void TCancelPlanFragmentParams::__set_protocol_version(const PaloInternalServiceVersion::type val) {
  this->protocol_version = val;
}

void TCancelPlanFragmentParams::__set_fragment_instance_id(const  ::palo::TUniqueId& val) {
  this->fragment_instance_id = val;
__isset.fragment_instance_id = true;
}

uint32_t TCancelPlanFragmentParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast51;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          this->__isset.fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelPlanFragmentParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelPlanFragmentParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fragment_instance_id) {
    xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelPlanFragmentParams &a, TCancelPlanFragmentParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.__isset, b.__isset);
}

TCancelPlanFragmentParams::TCancelPlanFragmentParams(const TCancelPlanFragmentParams& other52) {
  protocol_version = other52.protocol_version;
  fragment_instance_id = other52.fragment_instance_id;
  __isset = other52.__isset;
}
TCancelPlanFragmentParams& TCancelPlanFragmentParams::operator=(const TCancelPlanFragmentParams& other53) {
  protocol_version = other53.protocol_version;
  fragment_instance_id = other53.fragment_instance_id;
  __isset = other53.__isset;
  return *this;
}
void TCancelPlanFragmentParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelPlanFragmentParams(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "fragment_instance_id="; (__isset.fragment_instance_id ? (out << to_string(fragment_instance_id)) : (out << "<null>"));
  out << ")";
}


TCancelPlanFragmentResult::~TCancelPlanFragmentResult() throw() {
}


void TCancelPlanFragmentResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

uint32_t TCancelPlanFragmentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCancelPlanFragmentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCancelPlanFragmentResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelPlanFragmentResult &a, TCancelPlanFragmentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TCancelPlanFragmentResult::TCancelPlanFragmentResult(const TCancelPlanFragmentResult& other54) {
  status = other54.status;
  __isset = other54.__isset;
}
TCancelPlanFragmentResult& TCancelPlanFragmentResult::operator=(const TCancelPlanFragmentResult& other55) {
  status = other55.status;
  __isset = other55.__isset;
  return *this;
}
void TCancelPlanFragmentResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCancelPlanFragmentResult(";
  out << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


TTransmitDataParams::~TTransmitDataParams() throw() {
}


void TTransmitDataParams::__set_protocol_version(const PaloInternalServiceVersion::type val) {
  this->protocol_version = val;
}

void TTransmitDataParams::__set_dest_fragment_instance_id(const  ::palo::TUniqueId& val) {
  this->dest_fragment_instance_id = val;
__isset.dest_fragment_instance_id = true;
}

void TTransmitDataParams::__set_dest_node_id(const  ::palo::TPlanNodeId val) {
  this->dest_node_id = val;
__isset.dest_node_id = true;
}

void TTransmitDataParams::__set_row_batch(const  ::palo::TRowBatch& val) {
  this->row_batch = val;
__isset.row_batch = true;
}

void TTransmitDataParams::__set_eos(const bool val) {
  this->eos = val;
__isset.eos = true;
}

void TTransmitDataParams::__set_be_number(const int32_t val) {
  this->be_number = val;
__isset.be_number = true;
}

void TTransmitDataParams::__set_packet_seq(const int64_t val) {
  this->packet_seq = val;
__isset.packet_seq = true;
}

void TTransmitDataParams::__set_sender_id(const int32_t val) {
  this->sender_id = val;
__isset.sender_id = true;
}

uint32_t TTransmitDataParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast56;
          xfer += iprot->readI32(ecast56);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast56;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dest_fragment_instance_id.read(iprot);
          this->__isset.dest_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          this->__isset.dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_batch.read(iprot);
          this->__isset.row_batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->eos);
          this->__isset.eos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->be_number);
          this->__isset.be_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packet_seq);
          this->__isset.packet_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sender_id);
          this->__isset.sender_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTransmitDataParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTransmitDataParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dest_fragment_instance_id) {
    xfer += oprot->writeFieldBegin("dest_fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->dest_fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dest_node_id) {
    xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->dest_node_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_batch) {
    xfer += oprot->writeFieldBegin("row_batch", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->row_batch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.eos) {
    xfer += oprot->writeFieldBegin("eos", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->eos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.be_number) {
    xfer += oprot->writeFieldBegin("be_number", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->be_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.packet_seq) {
    xfer += oprot->writeFieldBegin("packet_seq", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->packet_seq);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sender_id) {
    xfer += oprot->writeFieldBegin("sender_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->sender_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTransmitDataParams &a, TTransmitDataParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.dest_fragment_instance_id, b.dest_fragment_instance_id);
  swap(a.dest_node_id, b.dest_node_id);
  swap(a.row_batch, b.row_batch);
  swap(a.eos, b.eos);
  swap(a.be_number, b.be_number);
  swap(a.packet_seq, b.packet_seq);
  swap(a.sender_id, b.sender_id);
  swap(a.__isset, b.__isset);
}

TTransmitDataParams::TTransmitDataParams(const TTransmitDataParams& other57) {
  protocol_version = other57.protocol_version;
  dest_fragment_instance_id = other57.dest_fragment_instance_id;
  dest_node_id = other57.dest_node_id;
  row_batch = other57.row_batch;
  eos = other57.eos;
  be_number = other57.be_number;
  packet_seq = other57.packet_seq;
  sender_id = other57.sender_id;
  __isset = other57.__isset;
}
TTransmitDataParams& TTransmitDataParams::operator=(const TTransmitDataParams& other58) {
  protocol_version = other58.protocol_version;
  dest_fragment_instance_id = other58.dest_fragment_instance_id;
  dest_node_id = other58.dest_node_id;
  row_batch = other58.row_batch;
  eos = other58.eos;
  be_number = other58.be_number;
  packet_seq = other58.packet_seq;
  sender_id = other58.sender_id;
  __isset = other58.__isset;
  return *this;
}
void TTransmitDataParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTransmitDataParams(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "dest_fragment_instance_id="; (__isset.dest_fragment_instance_id ? (out << to_string(dest_fragment_instance_id)) : (out << "<null>"));
  out << ", " << "dest_node_id="; (__isset.dest_node_id ? (out << to_string(dest_node_id)) : (out << "<null>"));
  out << ", " << "row_batch="; (__isset.row_batch ? (out << to_string(row_batch)) : (out << "<null>"));
  out << ", " << "eos="; (__isset.eos ? (out << to_string(eos)) : (out << "<null>"));
  out << ", " << "be_number="; (__isset.be_number ? (out << to_string(be_number)) : (out << "<null>"));
  out << ", " << "packet_seq="; (__isset.packet_seq ? (out << to_string(packet_seq)) : (out << "<null>"));
  out << ", " << "sender_id="; (__isset.sender_id ? (out << to_string(sender_id)) : (out << "<null>"));
  out << ")";
}


TTransmitDataResult::~TTransmitDataResult() throw() {
}


void TTransmitDataResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

void TTransmitDataResult::__set_packet_seq(const int64_t val) {
  this->packet_seq = val;
__isset.packet_seq = true;
}

void TTransmitDataResult::__set_dest_fragment_instance_id(const  ::palo::TUniqueId& val) {
  this->dest_fragment_instance_id = val;
__isset.dest_fragment_instance_id = true;
}

void TTransmitDataResult::__set_dest_node_id(const  ::palo::TPlanNodeId val) {
  this->dest_node_id = val;
__isset.dest_node_id = true;
}

uint32_t TTransmitDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packet_seq);
          this->__isset.packet_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dest_fragment_instance_id.read(iprot);
          this->__isset.dest_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          this->__isset.dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTransmitDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTransmitDataResult");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.packet_seq) {
    xfer += oprot->writeFieldBegin("packet_seq", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->packet_seq);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dest_fragment_instance_id) {
    xfer += oprot->writeFieldBegin("dest_fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->dest_fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dest_node_id) {
    xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->dest_node_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTransmitDataResult &a, TTransmitDataResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.packet_seq, b.packet_seq);
  swap(a.dest_fragment_instance_id, b.dest_fragment_instance_id);
  swap(a.dest_node_id, b.dest_node_id);
  swap(a.__isset, b.__isset);
}

TTransmitDataResult::TTransmitDataResult(const TTransmitDataResult& other59) {
  status = other59.status;
  packet_seq = other59.packet_seq;
  dest_fragment_instance_id = other59.dest_fragment_instance_id;
  dest_node_id = other59.dest_node_id;
  __isset = other59.__isset;
}
TTransmitDataResult& TTransmitDataResult::operator=(const TTransmitDataResult& other60) {
  status = other60.status;
  packet_seq = other60.packet_seq;
  dest_fragment_instance_id = other60.dest_fragment_instance_id;
  dest_node_id = other60.dest_node_id;
  __isset = other60.__isset;
  return *this;
}
void TTransmitDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTransmitDataResult(";
  out << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "packet_seq="; (__isset.packet_seq ? (out << to_string(packet_seq)) : (out << "<null>"));
  out << ", " << "dest_fragment_instance_id="; (__isset.dest_fragment_instance_id ? (out << to_string(dest_fragment_instance_id)) : (out << "<null>"));
  out << ", " << "dest_node_id="; (__isset.dest_node_id ? (out << to_string(dest_node_id)) : (out << "<null>"));
  out << ")";
}


TFetchDataParams::~TFetchDataParams() throw() {
}


void TFetchDataParams::__set_protocol_version(const PaloInternalServiceVersion::type val) {
  this->protocol_version = val;
}

void TFetchDataParams::__set_fragment_instance_id(const  ::palo::TUniqueId& val) {
  this->fragment_instance_id = val;
}

uint32_t TFetchDataParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_fragment_instance_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast61;
          xfer += iprot->readI32(ecast61);
          this->protocol_version = (PaloInternalServiceVersion::type)ecast61;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchDataParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchDataParams");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchDataParams &a, TFetchDataParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment_instance_id, b.fragment_instance_id);
}

TFetchDataParams::TFetchDataParams(const TFetchDataParams& other62) {
  protocol_version = other62.protocol_version;
  fragment_instance_id = other62.fragment_instance_id;
}
TFetchDataParams& TFetchDataParams::operator=(const TFetchDataParams& other63) {
  protocol_version = other63.protocol_version;
  fragment_instance_id = other63.fragment_instance_id;
  return *this;
}
void TFetchDataParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchDataParams(";
  out << "protocol_version=" << to_string(protocol_version);
  out << ", " << "fragment_instance_id=" << to_string(fragment_instance_id);
  out << ")";
}


TFetchDataResult::~TFetchDataResult() throw() {
}


void TFetchDataResult::__set_result_batch(const  ::palo::TResultBatch& val) {
  this->result_batch = val;
}

void TFetchDataResult::__set_eos(const bool val) {
  this->eos = val;
}

void TFetchDataResult::__set_packet_num(const int32_t val) {
  this->packet_num = val;
}

void TFetchDataResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
__isset.status = true;
}

uint32_t TFetchDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result_batch = false;
  bool isset_eos = false;
  bool isset_packet_num = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_batch.read(iprot);
          isset_result_batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->eos);
          isset_eos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->packet_num);
          isset_packet_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result_batch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_packet_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchDataResult");

  xfer += oprot->writeFieldBegin("result_batch", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result_batch.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eos", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->eos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packet_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->packet_num);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchDataResult &a, TFetchDataResult &b) {
  using ::std::swap;
  swap(a.result_batch, b.result_batch);
  swap(a.eos, b.eos);
  swap(a.packet_num, b.packet_num);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TFetchDataResult::TFetchDataResult(const TFetchDataResult& other64) {
  result_batch = other64.result_batch;
  eos = other64.eos;
  packet_num = other64.packet_num;
  status = other64.status;
  __isset = other64.__isset;
}
TFetchDataResult& TFetchDataResult::operator=(const TFetchDataResult& other65) {
  result_batch = other65.result_batch;
  eos = other65.eos;
  packet_num = other65.packet_num;
  status = other65.status;
  __isset = other65.__isset;
  return *this;
}
void TFetchDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchDataResult(";
  out << "result_batch=" << to_string(result_batch);
  out << ", " << "eos=" << to_string(eos);
  out << ", " << "packet_num=" << to_string(packet_num);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


TFetchStartKey::~TFetchStartKey() throw() {
}


void TFetchStartKey::__set_key(const std::vector<std::string> & val) {
  this->key = val;
}

uint32_t TFetchStartKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->key.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += iprot->readString(this->key[_i70]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchStartKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchStartKey");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key.size()));
    std::vector<std::string> ::const_iterator _iter71;
    for (_iter71 = this->key.begin(); _iter71 != this->key.end(); ++_iter71)
    {
      xfer += oprot->writeString((*_iter71));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchStartKey &a, TFetchStartKey &b) {
  using ::std::swap;
  swap(a.key, b.key);
}

TFetchStartKey::TFetchStartKey(const TFetchStartKey& other72) {
  key = other72.key;
}
TFetchStartKey& TFetchStartKey::operator=(const TFetchStartKey& other73) {
  key = other73.key;
  return *this;
}
void TFetchStartKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchStartKey(";
  out << "key=" << to_string(key);
  out << ")";
}


TFetchEndKey::~TFetchEndKey() throw() {
}


void TFetchEndKey::__set_key(const std::vector<std::string> & val) {
  this->key = val;
}

uint32_t TFetchEndKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->key.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += iprot->readString(this->key[_i78]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchEndKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchEndKey");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key.size()));
    std::vector<std::string> ::const_iterator _iter79;
    for (_iter79 = this->key.begin(); _iter79 != this->key.end(); ++_iter79)
    {
      xfer += oprot->writeString((*_iter79));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchEndKey &a, TFetchEndKey &b) {
  using ::std::swap;
  swap(a.key, b.key);
}

TFetchEndKey::TFetchEndKey(const TFetchEndKey& other80) {
  key = other80.key;
}
TFetchEndKey& TFetchEndKey::operator=(const TFetchEndKey& other81) {
  key = other81.key;
  return *this;
}
void TFetchEndKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchEndKey(";
  out << "key=" << to_string(key);
  out << ")";
}


TCondition::~TCondition() throw() {
}


void TCondition::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void TCondition::__set_condition_op(const std::string& val) {
  this->condition_op = val;
}

void TCondition::__set_condition_values(const std::vector<std::string> & val) {
  this->condition_values = val;
}

uint32_t TCondition::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_name = false;
  bool isset_condition_op = false;
  bool isset_condition_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->condition_op);
          isset_condition_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->condition_values.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->condition_values.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += iprot->readString(this->condition_values[_i86]);
            }
            xfer += iprot->readListEnd();
          }
          isset_condition_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_condition_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_condition_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCondition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCondition");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("condition_op", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->condition_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("condition_values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->condition_values.size()));
    std::vector<std::string> ::const_iterator _iter87;
    for (_iter87 = this->condition_values.begin(); _iter87 != this->condition_values.end(); ++_iter87)
    {
      xfer += oprot->writeString((*_iter87));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCondition &a, TCondition &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.condition_op, b.condition_op);
  swap(a.condition_values, b.condition_values);
}

TCondition::TCondition(const TCondition& other88) {
  column_name = other88.column_name;
  condition_op = other88.condition_op;
  condition_values = other88.condition_values;
}
TCondition& TCondition::operator=(const TCondition& other89) {
  column_name = other89.column_name;
  condition_op = other89.condition_op;
  condition_values = other89.condition_values;
  return *this;
}
void TCondition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCondition(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "condition_op=" << to_string(condition_op);
  out << ", " << "condition_values=" << to_string(condition_values);
  out << ")";
}


TFetchRequest::~TFetchRequest() throw() {
}


void TFetchRequest::__set_use_compression(const bool val) {
  this->use_compression = val;
}

void TFetchRequest::__set_num_rows(const int32_t val) {
  this->num_rows = val;
__isset.num_rows = true;
}

void TFetchRequest::__set_schema_hash(const int32_t val) {
  this->schema_hash = val;
}

void TFetchRequest::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TFetchRequest::__set_version(const int32_t val) {
  this->version = val;
}

void TFetchRequest::__set_version_hash(const int64_t val) {
  this->version_hash = val;
}

void TFetchRequest::__set_field(const std::vector<std::string> & val) {
  this->field = val;
}

void TFetchRequest::__set_user(const std::string& val) {
  this->user = val;
__isset.user = true;
}

void TFetchRequest::__set_output(const std::string& val) {
  this->output = val;
__isset.output = true;
}

void TFetchRequest::__set_range(const std::string& val) {
  this->range = val;
__isset.range = true;
}

void TFetchRequest::__set_start_key(const std::vector<TFetchStartKey> & val) {
  this->start_key = val;
}

void TFetchRequest::__set_end_key(const std::vector<TFetchEndKey> & val) {
  this->end_key = val;
}

void TFetchRequest::__set_where(const std::vector<TCondition> & val) {
  this->where = val;
}

void TFetchRequest::__set_end_range(const std::string& val) {
  this->end_range = val;
__isset.end_range = true;
}

void TFetchRequest::__set_aggregation(const bool val) {
  this->aggregation = val;
__isset.aggregation = true;
}

uint32_t TFetchRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_use_compression = false;
  bool isset_schema_hash = false;
  bool isset_tablet_id = false;
  bool isset_version = false;
  bool isset_version_hash = false;
  bool isset_field = false;
  bool isset_start_key = false;
  bool isset_end_key = false;
  bool isset_where = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_compression);
          isset_use_compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_hash);
          isset_version_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->field.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _etype93;
            xfer += iprot->readListBegin(_etype93, _size90);
            this->field.resize(_size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              xfer += iprot->readString(this->field[_i94]);
            }
            xfer += iprot->readListEnd();
          }
          isset_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output);
          this->__isset.output = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->range);
          this->__isset.range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start_key.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->start_key.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += this->start_key[_i99].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->end_key.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->end_key.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->end_key[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->where.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->where.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += this->where[_i109].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_where = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_range);
          this->__isset.end_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->aggregation);
          this->__isset.aggregation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_use_compression)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_field)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_where)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFetchRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFetchRequest");

  xfer += oprot->writeFieldBegin("use_compression", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->use_compression);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.num_rows) {
    xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->num_rows);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_hash", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->version_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->field.size()));
    std::vector<std::string> ::const_iterator _iter110;
    for (_iter110 = this->field.begin(); _iter110 != this->field.end(); ++_iter110)
    {
      xfer += oprot->writeString((*_iter110));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output) {
    xfer += oprot->writeFieldBegin("output", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->output);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range) {
    xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->range);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start_key.size()));
    std::vector<TFetchStartKey> ::const_iterator _iter111;
    for (_iter111 = this->start_key.begin(); _iter111 != this->start_key.end(); ++_iter111)
    {
      xfer += (*_iter111).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->end_key.size()));
    std::vector<TFetchEndKey> ::const_iterator _iter112;
    for (_iter112 = this->end_key.begin(); _iter112 != this->end_key.end(); ++_iter112)
    {
      xfer += (*_iter112).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("where", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->where.size()));
    std::vector<TCondition> ::const_iterator _iter113;
    for (_iter113 = this->where.begin(); _iter113 != this->where.end(); ++_iter113)
    {
      xfer += (*_iter113).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.end_range) {
    xfer += oprot->writeFieldBegin("end_range", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->end_range);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggregation) {
    xfer += oprot->writeFieldBegin("aggregation", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->aggregation);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFetchRequest &a, TFetchRequest &b) {
  using ::std::swap;
  swap(a.use_compression, b.use_compression);
  swap(a.num_rows, b.num_rows);
  swap(a.schema_hash, b.schema_hash);
  swap(a.tablet_id, b.tablet_id);
  swap(a.version, b.version);
  swap(a.version_hash, b.version_hash);
  swap(a.field, b.field);
  swap(a.user, b.user);
  swap(a.output, b.output);
  swap(a.range, b.range);
  swap(a.start_key, b.start_key);
  swap(a.end_key, b.end_key);
  swap(a.where, b.where);
  swap(a.end_range, b.end_range);
  swap(a.aggregation, b.aggregation);
  swap(a.__isset, b.__isset);
}

TFetchRequest::TFetchRequest(const TFetchRequest& other114) {
  use_compression = other114.use_compression;
  num_rows = other114.num_rows;
  schema_hash = other114.schema_hash;
  tablet_id = other114.tablet_id;
  version = other114.version;
  version_hash = other114.version_hash;
  field = other114.field;
  user = other114.user;
  output = other114.output;
  range = other114.range;
  start_key = other114.start_key;
  end_key = other114.end_key;
  where = other114.where;
  end_range = other114.end_range;
  aggregation = other114.aggregation;
  __isset = other114.__isset;
}
TFetchRequest& TFetchRequest::operator=(const TFetchRequest& other115) {
  use_compression = other115.use_compression;
  num_rows = other115.num_rows;
  schema_hash = other115.schema_hash;
  tablet_id = other115.tablet_id;
  version = other115.version;
  version_hash = other115.version_hash;
  field = other115.field;
  user = other115.user;
  output = other115.output;
  range = other115.range;
  start_key = other115.start_key;
  end_key = other115.end_key;
  where = other115.where;
  end_range = other115.end_range;
  aggregation = other115.aggregation;
  __isset = other115.__isset;
  return *this;
}
void TFetchRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFetchRequest(";
  out << "use_compression=" << to_string(use_compression);
  out << ", " << "num_rows="; (__isset.num_rows ? (out << to_string(num_rows)) : (out << "<null>"));
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "tablet_id=" << to_string(tablet_id);
  out << ", " << "version=" << to_string(version);
  out << ", " << "version_hash=" << to_string(version_hash);
  out << ", " << "field=" << to_string(field);
  out << ", " << "user="; (__isset.user ? (out << to_string(user)) : (out << "<null>"));
  out << ", " << "output="; (__isset.output ? (out << to_string(output)) : (out << "<null>"));
  out << ", " << "range="; (__isset.range ? (out << to_string(range)) : (out << "<null>"));
  out << ", " << "start_key=" << to_string(start_key);
  out << ", " << "end_key=" << to_string(end_key);
  out << ", " << "where=" << to_string(where);
  out << ", " << "end_range="; (__isset.end_range ? (out << to_string(end_range)) : (out << "<null>"));
  out << ", " << "aggregation="; (__isset.aggregation ? (out << to_string(aggregation)) : (out << "<null>"));
  out << ")";
}


TShowHintsRequest::~TShowHintsRequest() throw() {
}


void TShowHintsRequest::__set_tablet_id(const  ::palo::TTabletId val) {
  this->tablet_id = val;
}

void TShowHintsRequest::__set_schema_hash(const int32_t val) {
  this->schema_hash = val;
}

void TShowHintsRequest::__set_block_row_count(const int32_t val) {
  this->block_row_count = val;
}

void TShowHintsRequest::__set_end_range(const std::string& val) {
  this->end_range = val;
__isset.end_range = true;
}

void TShowHintsRequest::__set_start_key(const std::vector<TFetchStartKey> & val) {
  this->start_key = val;
}

void TShowHintsRequest::__set_end_key(const std::vector<TFetchEndKey> & val) {
  this->end_key = val;
}

uint32_t TShowHintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tablet_id = false;
  bool isset_schema_hash = false;
  bool isset_block_row_count = false;
  bool isset_start_key = false;
  bool isset_end_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tablet_id);
          isset_tablet_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->schema_hash);
          isset_schema_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_row_count);
          isset_block_row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_range);
          this->__isset.end_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start_key.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _etype119;
            xfer += iprot->readListBegin(_etype119, _size116);
            this->start_key.resize(_size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              xfer += this->start_key[_i120].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->end_key.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readListBegin(_etype124, _size121);
            this->end_key.resize(_size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              xfer += this->end_key[_i125].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tablet_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_block_row_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowHintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowHintsRequest");

  xfer += oprot->writeFieldBegin("tablet_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->tablet_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schema_hash", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->schema_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_row_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->block_row_count);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.end_range) {
    xfer += oprot->writeFieldBegin("end_range", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->end_range);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start_key.size()));
    std::vector<TFetchStartKey> ::const_iterator _iter126;
    for (_iter126 = this->start_key.begin(); _iter126 != this->start_key.end(); ++_iter126)
    {
      xfer += (*_iter126).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->end_key.size()));
    std::vector<TFetchEndKey> ::const_iterator _iter127;
    for (_iter127 = this->end_key.begin(); _iter127 != this->end_key.end(); ++_iter127)
    {
      xfer += (*_iter127).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowHintsRequest &a, TShowHintsRequest &b) {
  using ::std::swap;
  swap(a.tablet_id, b.tablet_id);
  swap(a.schema_hash, b.schema_hash);
  swap(a.block_row_count, b.block_row_count);
  swap(a.end_range, b.end_range);
  swap(a.start_key, b.start_key);
  swap(a.end_key, b.end_key);
  swap(a.__isset, b.__isset);
}

TShowHintsRequest::TShowHintsRequest(const TShowHintsRequest& other128) {
  tablet_id = other128.tablet_id;
  schema_hash = other128.schema_hash;
  block_row_count = other128.block_row_count;
  end_range = other128.end_range;
  start_key = other128.start_key;
  end_key = other128.end_key;
  __isset = other128.__isset;
}
TShowHintsRequest& TShowHintsRequest::operator=(const TShowHintsRequest& other129) {
  tablet_id = other129.tablet_id;
  schema_hash = other129.schema_hash;
  block_row_count = other129.block_row_count;
  end_range = other129.end_range;
  start_key = other129.start_key;
  end_key = other129.end_key;
  __isset = other129.__isset;
  return *this;
}
void TShowHintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowHintsRequest(";
  out << "tablet_id=" << to_string(tablet_id);
  out << ", " << "schema_hash=" << to_string(schema_hash);
  out << ", " << "block_row_count=" << to_string(block_row_count);
  out << ", " << "end_range="; (__isset.end_range ? (out << to_string(end_range)) : (out << "<null>"));
  out << ", " << "start_key=" << to_string(start_key);
  out << ", " << "end_key=" << to_string(end_key);
  out << ")";
}


TExportStatusResult::~TExportStatusResult() throw() {
}


void TExportStatusResult::__set_status(const  ::palo::TStatus& val) {
  this->status = val;
}

void TExportStatusResult::__set_state(const  ::palo::TExportState::type val) {
  this->state = val;
}

void TExportStatusResult::__set_files(const std::vector<std::string> & val) {
  this->files = val;
__isset.files = true;
}

uint32_t TExportStatusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast130;
          xfer += iprot->readI32(ecast130);
          this->state = ( ::palo::TExportState::type)ecast130;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->files.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += iprot->readString(this->files[_i135]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExportStatusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExportStatusResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.files) {
    xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files.size()));
      std::vector<std::string> ::const_iterator _iter136;
      for (_iter136 = this->files.begin(); _iter136 != this->files.end(); ++_iter136)
      {
        xfer += oprot->writeString((*_iter136));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExportStatusResult &a, TExportStatusResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.state, b.state);
  swap(a.files, b.files);
  swap(a.__isset, b.__isset);
}

TExportStatusResult::TExportStatusResult(const TExportStatusResult& other137) {
  status = other137.status;
  state = other137.state;
  files = other137.files;
  __isset = other137.__isset;
}
TExportStatusResult& TExportStatusResult::operator=(const TExportStatusResult& other138) {
  status = other138.status;
  state = other138.state;
  files = other138.files;
  __isset = other138.__isset;
  return *this;
}
void TExportStatusResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExportStatusResult(";
  out << "status=" << to_string(status);
  out << ", " << "state=" << to_string(state);
  out << ", " << "files="; (__isset.files ? (out << to_string(files)) : (out << "<null>"));
  out << ")";
}

} // namespace
